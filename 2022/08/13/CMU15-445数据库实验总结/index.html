

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/hexo_img/icon.jpg">
  <link rel="icon" href="/hexo_img/icon.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#0D3562">
  <meta name="author" content="ZYUE">
  <meta name="keywords" content="">
  
    <meta name="description" content="简要介绍这门课程共五个配套实验，不过关于数据库的是后面4个实验，第一个实验是检验基本C++语言能力的前菜。 实验全部都是完形填空的形式，需要我们实现声明好的函数，自己也可以增加其它成员变量或成员函数来辅助完成实验要求。 实验配套的开源项目是bustub，需要我们从github上clone下来，按照README配置环境就好。我是在VMWARE中装Ubuntu18.04虚拟机来完成实验的，一定要仔细看">
<meta property="og:type" content="article">
<meta property="og:title" content="CMU15-445数据库实验总结">
<meta property="og:url" content="http://example.com/2022/08/13/CMU15-445%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="参天小树">
<meta property="og:description" content="简要介绍这门课程共五个配套实验，不过关于数据库的是后面4个实验，第一个实验是检验基本C++语言能力的前菜。 实验全部都是完形填空的形式，需要我们实现声明好的函数，自己也可以增加其它成员变量或成员函数来辅助完成实验要求。 实验配套的开源项目是bustub，需要我们从github上clone下来，按照README配置环境就好。我是在VMWARE中装Ubuntu18.04虚拟机来完成实验的，一定要仔细看">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/post_img/30.jpg">
<meta property="article:published_time" content="2022-08-13T15:12:18.000Z">
<meta property="article:modified_time" content="2022-08-15T05:00:50.412Z">
<meta property="article:author" content="ZYUE">
<meta property="article:tag" content="项目">
<meta property="article:tag" content="数据库">
<meta property="article:tag" content="可扩展哈希">
<meta property="article:tag" content="缓存池">
<meta property="article:tag" content="LRU">
<meta property="article:tag" content="火山模型">
<meta property="article:tag" content="读锁">
<meta property="article:tag" content="写锁">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/post_img/30.jpg">
  
  
  
  <title>CMU15-445数据库实验总结 - 参天小树</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":false,"baidu":"c03149260ee4667c7ea092624ddee2b5","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  
    <!-- Baidu Analytics -->
    <script async>
      if (!Fluid.ctx.dnt) {
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?c03149260ee4667c7ea092624ddee2b5";
          var s = document.getElementsByTagName("script")[0];
          s.parentNode.insertBefore(hm, s);
        })();
      }
    </script>
  

  

  

  

  

  

  



  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong> </strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/hexo_img/bk2.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="CMU15-445数据库实验总结"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        ZYUE
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-08-13 23:12" pubdate>
          2022年8月13日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          12k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          103 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">CMU15-445数据库实验总结</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="简要介绍"><a href="#简要介绍" class="headerlink" title="简要介绍"></a>简要介绍</h2><p>这门课程共五个配套实验，不过关于数据库的是后面4个实验，第一个实验是检验基本C++语言能力的前菜。</p>
<p>实验全部都是完形填空的形式，需要我们实现声明好的函数，自己也可以增加其它成员变量或成员函数来辅助完成实验要求。</p>
<p>实验配套的开源项目是<code>bustub</code>，需要我们从github上clone下来，按照README配置环境就好。我是在VMWARE中装Ubuntu18.04虚拟机来完成实验的，一定要仔细看环境要求，免得工具链不支持折腾时间。我最开始是用Ubuntu22.04，结果回退代码版本到2021FALL的实验位置后似乎编译不了，又不得不再配环境（因为我菜，不知道怎么修改）。</p>
<p>另外，这门课还开放了<code>Gradescope</code>在线测试平台，非CMU的学生也可以使用，非常不错。因为本地的测试代码都比较简单，Gradescope上面才是严格的测试，注册时要选卡内梅隆基大学和填入口代码，每次上传代码文件时最好运行如下命令检查一下代码格式，因为代码格式检查非常严格，不合规直接0分。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">make format<br>make check-lint<br>make check-clang-tidy<br></code></pre></td></tr></table></figure>

<p>还有一个上传代码的坑点是提交时要另外多加一个文件<code>tmp_tuple_page.h</code>，具体修改见github issue #225。</p>
<p>于自己而言，实验难度大概是 <code>proj0 &lt; proj1 &lt; proj3 &lt;= proj4 &lt;&lt; proj2</code>。其中project2难度最大，是实现可扩展哈希索引，虽然不是2020年听着就非常难的B+树索引，但感觉也不相上下（project2前前后后提交了差不多100次，每次改bug后再提交都得需要运行十几分钟才出结果，难顶…，还好没放弃最终通过全部测试）。project0感觉做不做都没关系，简单的矩阵运算。project1是实现缓存池，其中用到LRU缓存替换策略，管理数据库页面，相对简单。project3是执行查询语句相关的，主要是调用函数，看懂代码中各个类的关联就好。project4是并发控制，实现一个锁管理器（读写锁）和事务回滚的控制。所有实验项目中注意线程安全。在每个Lab前我们需要好好理解实验要求，看懂代码中接口之前的关系，然后理解原理，想好实现思路。</p>
<p>下文主要记录一下各个Lab中的实现思路和遇到问题的解决方法。</p>
<h2 id="Project0-C-Primer"><a href="#Project0-C-Primer" class="headerlink" title="Project0 C++ Primer"></a>Project0 C++ Primer</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>在这个项目中，您将实现三个类：Matrix、RowMatrix、RowMatrixOperations。这些矩阵是简单的二维矩阵，必须支持加法、矩阵乘法和简化的通用矩阵乘法(GEMM) 运算。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>直接写就行，不过注意：</p>
<ul>
<li><p>模板子类在实例化之前不知道他的模板父类是谁，所以在模板子类中调用父类成员需要加：（都可以）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">this</span>-&gt;var_name<br>Parent::var_name<br><span class="hljs-keyword">using</span> Parent::var_name;<br></code></pre></td></tr></table></figure>
</li>
<li><p>const对象只能调用const成员函数；</p>
</li>
<li><p>构造函数中new了对象后，记得在析构函数delete释放掉；</p>
</li>
<li><p>抛出异常：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">throw</span> <span class="hljs-built_in">Exception</span>(ExceptionType::OUT_OF_RANGE, <span class="hljs-string">&quot;index out of range&quot;</span>);<br></code></pre></td></tr></table></figure>
</li>
<li><p>智能指针uni_ptr转换为普通指针使用；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">ptr = uni_ptr.<span class="hljs-built_in">get</span>()<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="Project1-Buffer-Pool-Manager"><a href="#Project1-Buffer-Pool-Manager" class="headerlink" title="Project1 Buffer Pool Manager"></a>Project1 Buffer Pool Manager</h2><h3 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h3><p>第一个编程项目是在存储管理器中实现缓冲池。缓冲池负责将物理页面从主内存来回移动到磁盘。它允许 DBMS 支持大于系统可用内存量的数据库。</p>
<p>因为在BusTub中，数据库中的数据以页为单位存储在磁盘中，使用时要把页面从磁盘加载到内存，此后再使用如果命中缓存也会提高效率。但内存的容量有限，当容量不足时就需要利用合理的规则淘汰掉某些页面，把位置留给有需要的。</p>
<p>在缓存池中，有些页面是空闲的，存在于空闲链表中，即没有数据库页面与它对应；有些数据库页面处于PIN后的状态，它们正在被使用，不能被淘汰；还有些数据库页面处于Unpin状态，在内存容量不足时被淘汰掉。</p>
<p>page_id唯一标识了一个数据库页面，disk_manager 就是根据 page_id 来读取和写入磁盘页；frame_id唯一标识了内存中的一个页面的位置，代表一个内存帧位置，内存页可以存放数据库页面page，它和page_id呼应。</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><h4 id="Task-1-LRU替换策略"><a href="#Task-1-LRU替换策略" class="headerlink" title="Task #1 LRU替换策略"></a>Task #1 LRU替换策略</h4><p>使用LRU缓存替换策略，lru_replacer相当于一个回收站，LRU管理的对象就是内存帧位置frame_id。</p>
<ul>
<li>我们用unordered_map哈希表和list双向链表实现LRU算法，链表节点是一个frame_id帧位置，哈希表存每个链表节点的迭代器位置。这里链表尾部代表最近最久未使用的页面对应的 frame_id；</li>
<li>Pin函数：代表该帧位置对应的页面被某个线程正在使用，不能被替换出去，所以从lru_replacer（umap和list）中移除参数frame_id。从上层的视角而言就是固定某个页面，不被LRU管理；</li>
<li>Unpin函数：与Pin相反，表示没有线程在使用参数frame_id对应的页面，该页面可以被淘汰。所以要把frame_id加入到lru_replacer（umap和list）中，加到链表头部；</li>
<li>Victim函数：查看 lru_replacer 是否有可以牺牲的页面，有的话则取出帧位置 frame_id；</li>
</ul>
<h4 id="Task-2-缓冲池管理器实例"><a href="#Task-2-缓冲池管理器实例" class="headerlink" title="Task #2 缓冲池管理器实例"></a>Task #2 缓冲池管理器实例</h4><p>缓冲池管理器的作用其实就是获取在磁盘的数据库页面、创建新页面、删除页面、写回脏页。这里的一个page_id就唯一标识了一个页面，哈希表page_table_ 管理所有页面，lru_replacer管理的页面是page_table_ 中页面的子集，空闲链表free_list_中是未被使用的页面，和前两个独立。每个函数按注释的要求写就行。</p>
<ul>
<li>每次获取新内存页位置时，优先从空闲链表free_list_中取出，没有再从lru_replacer获取牺牲页；</li>
<li>脏页记得写入磁盘，创建新页时不能从磁盘读，因为此时还没有该页；</li>
<li>NewPgImp()时，成功取得要被替换的页面后再AllocatePage()；</li>
<li>记得将被替换的旧页ResetMemory()，必须要清空原数据；</li>
<li>每次操作记得设置好pin_count_引用计数；</li>
<li>UnpinPgImp后，只有页面的pin_count_为0时，表示没有线程使用，才能被加到空闲链表；</li>
</ul>
<h4 id="Task-3-并行缓冲池管理器"><a href="#Task-3-并行缓冲池管理器" class="headerlink" title="Task #3 并行缓冲池管理器"></a>Task #3 并行缓冲池管理器</h4><p>ParallelBufferPoolManager是一个拥有多个缓冲池管理器实例的类。对于每个操作，ParallelBufferPoolManager选择一个BufferPoolManagerInstance并委托给该实例。</p>
<p>也就是系统中拥有多个缓冲池，每个缓冲池都有自己的锁，减少了一个缓存池时抢占锁的开销，负载均衡的样子。</p>
<p>这里维护一个 next_instance_ 变量，轮询来判断下一次page的操作分配给那个Buffer Pool Manager。该类中只需在NewPgImp()函数加锁。</p>
<h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><p>加锁建议利用RAII机制，如使用lock_guard、unique_lock、scoped_lock等，不然手动lock再unlock麻烦，还可能忘记加解锁而出现问题。我就忘记解锁造成死锁了，后面全部改用unique_lock；</p>
<p>有两种脏页的刷盘时机的策略，一种是每次 Unpin 的时候都刷，这样会刷比较频繁，但能保证异常掉电重启后内容不丢；一种是在 replacer victimized 的时候 lazily 的刷，这样能保证刷的次数最少；这是性能和可靠性的取舍。</p>
<h2 id="Project2-Hash-Index"><a href="#Project2-Hash-Index" class="headerlink" title="Project2 Hash Index"></a>Project2 Hash Index</h2><h3 id="说明-2"><a href="#说明-2" class="headerlink" title="说明"></a>说明</h3><p>第二个项目是为ButsTub DBMS实现一个磁盘支持的可扩展哈希表。哈希索引包含一个directory page，该目录页包含指向bucket page的指针。哈希表将通过第一个实现中的缓冲池访问页面。目录页存储了table和bucket的所有元数据。哈希表需要支持对满&#x2F;空bucket的拆分和合并，以及在全局深度必须更改时支持directory的扩展和收缩。</p>
<p>这里的桶页就是数据库中存储键值对数据的页面。在目录页中桶只是逻辑上的概念，就是一个索引位置，目录页中数组的索引i对应第i个桶，实际上可能有多个桶指向同一个物理桶页面（page）。</p>
<p>我把目录页中一个索引位置称作一个逻辑桶，一个物理桶页面称为桶页，满桶分裂时（空桶合并时）对应调整数据的桶称作镜像桶，它们互为兄弟桶。</p>
<p>每个哈希表的Directory或Bucket页对应于从缓冲池中获取的内存内的内容。每次尝试读写页面的时候，需要使用唯一的page_id从缓冲池中获取页面，然后将他们重新转换为Directory或Bucket页，并且要在任何读写操作之后Unpin这个页面。</p>
<p>建议先理解可扩展哈希索引的原理到位后再开始做此lab，要理解全局深度和局部深度，理解原桶和镜像桶之间的关系。</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><h4 id="Task-1-页面布局"><a href="#Task-1-页面布局" class="headerlink" title="Task #1 页面布局"></a>Task #1 页面布局</h4><h5 id="哈希表目录页"><a href="#哈希表目录页" class="headerlink" title="哈希表目录页"></a>哈希表目录页</h5><table>
<thead>
<tr>
<th align="center">一些成员变量</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">global_depth_</td>
<td align="center">目录的全局深度</td>
</tr>
<tr>
<td align="center">local_depths_</td>
<td align="center">桶的局部深度的数组（uint8_t）</td>
</tr>
<tr>
<td align="center">bucket_page_ids_</td>
<td align="center">桶页的page_id的数组</td>
</tr>
</tbody></table>
<ul>
<li><p>目录页的全局高度global_depth_ 初始值是0，目录页中逻辑桶的索引范围是[0, Size())，也就是存在Size()个有效的逻辑桶，Size()由全局高度计算得到，就是2^global_depth_为有效逻辑桶的个数；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">HashTableDirectoryPage::Size</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> (<span class="hljs-number">1</span> &lt;&lt; global_depth_); &#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>根据目录页中数组大小是512，可知最多有512&#x3D;2^9个桶，所以在头文件定义一个最大全局高度；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_GLOBAL_DEPTH 9</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>关于全局高度或局部高度掩码，是使用最低有效位，掩码与键的hash值&amp;运算得到该键对应的逻辑桶索引；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">HashTableDirectoryPage::GetGlobalDepthMask</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> (<span class="hljs-number">1</span> &lt;&lt; global_depth_) - <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">// 局部高度掩码类似</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>只有当每个桶的局部高度严格小于目录的全局高度时，才执行目录收缩；</p>
</li>
<li><p>增加全局深度要将桶数量翻倍，只是逻辑上翻倍了原来的bucket，两个兄弟桶仍然指向同一个物理桶页面；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HashTableDirectoryPage::IncrGlobalDepth</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">uint32_t</span> old_size = <span class="hljs-built_in">Size</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> i = <span class="hljs-number">0</span>; i &lt; old_size; ++i) &#123;<br>    bucket_page_ids_[i + old_size] = bucket_page_ids_[i];<br>    local_depths_[i + old_size] = local_depths_[i];<br>  &#125;<br>  ++global_depth_;<br>  <span class="hljs-built_in">assert</span>(global_depth_ &lt;= MAX_GLOBAL_DEPTH);<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>获取镜像桶（兄弟桶）的索引，其实就是将原桶索引的最高位取反；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">HashTableDirectoryPage::GetSplitImageIndex</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> bucket_idx)</span> </span>&#123;<br>  <span class="hljs-built_in">assert</span>(bucket_idx &lt; <span class="hljs-built_in">Size</span>());<br>  <span class="hljs-comment">// 用异或，给待分裂桶的下标的最高位取反，得到兄弟桶下标</span><br>  <span class="hljs-type">uint32_t</span> local_deep = local_depths_[bucket_idx];<br>  <span class="hljs-keyword">return</span> bucket_idx ^ (<span class="hljs-number">1</span> &lt;&lt; (local_deep - <span class="hljs-number">1</span>));<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h5 id="哈希表桶页"><a href="#哈希表桶页" class="headerlink" title="哈希表桶页"></a>哈希表桶页</h5><table>
<thead>
<tr>
<th align="center">成员变量</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">occupied_</td>
<td align="center">若数组array_ 的第i个索引曾经被占用过，则occued_的第i位为1</td>
</tr>
<tr>
<td align="center">readable_</td>
<td align="center">若数组array_ 的第i个索引包含一个可读值，则readable_的第i位为1</td>
</tr>
<tr>
<td align="center">array_</td>
<td align="center">保存key-value键值对的数组</td>
</tr>
</tbody></table>
<ul>
<li><p>array_是一个0长度数组，一个桶页面类对象后面的空间都用来存储键值对数据；</p>
</li>
<li><p>插入数据时满了返回false，也不能插入重复的键值对，如下是相等判断，cmp函数等于0就是相等的键，值可以直接比较；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">cmp</span>(key, <span class="hljs-built_in">KeyAt</span>(i)) == <span class="hljs-number">0</span> &amp;&amp; (value == <span class="hljs-built_in">ValueAt</span>(i)<br></code></pre></td></tr></table></figure>
</li>
<li><p>occupied_ 与readable_ 数组类型是char，一个char是8bit，可以表示8个位置，节约空间，对应的函数操作也就需要位运算了。插入数据需要将occupied_ 与readable_ 数组上对应的位置1，删除只需要将occupied_ 数组上对应的位置0。寻找对应位时，先找到所在char，再找到具体第几位。比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">uint8_t</span> ch = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint8_t</span>&gt;(readable_[bucket_idx / <span class="hljs-number">8</span>])<br>找到第几位: (<span class="hljs-number">1</span> &lt;&lt; (bucket_idx % <span class="hljs-number">8</span>))，再进行&amp;或|或~运算等等<br></code></pre></td></tr></table></figure>
</li>
<li><p>求NumReadable()，一个桶页面上可读（该位是1）的键值对数量，可以使用<code>ch &amp;= (ch - 1)</code>；</p>
</li>
<li><p>遍历全数组时，也就是处理每个char时，有向上取整；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> sz = (BUCKET_ARRAY_SIZE + <span class="hljs-number">8</span> - <span class="hljs-number">1</span>) / <span class="hljs-number">8</span>;  <span class="hljs-comment">// 向上取整</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>空或满判断可以直接调用NumReadable()，看是不是等于0或BUCKET_ARRAY_SIZE；</p>
</li>
<li><p>还自定义了两个辅助函数配合桶分裂，取出桶中全部可读数据，重置桶页面（将可读位全部置0）；</p>
</li>
</ul>
<h4 id="Task-2-实现可扩展哈希表"><a href="#Task-2-实现可扩展哈希表" class="headerlink" title="Task #2 实现可扩展哈希表"></a>Task #2 实现可扩展哈希表</h4><ul>
<li><p>构造函数中创建目录页和第一个桶页，并设置第一个桶索引为0，局部高度为0；</p>
</li>
<li><p>普通的取出、插入、删除操作基本就是先取出目录页和对应桶页，然后调用我们在桶页实现的相应函数即可；</p>
</li>
<li><p>插入前判断到桶满了就分裂桶，删除元素后判断桶为空就合并，目录页也相应调整；</p>
</li>
<li><p>分裂满桶的步骤：</p>
<ul>
<li>先获取目录页和对应桶索引；</li>
<li>如果桶的局部高度已经等于MAX_GLOBAL_DEPTH，就不能再扩容；</li>
<li>因为并发问题，再取出桶页面，并再次检查是不是满了；</li>
<li>当桶页的局部高度等于目录的全局高度时，还需要增加全局高度；</li>
<li>将桶局部高度增加一个单位；</li>
<li>取出原桶的所有元素，清空原桶；</li>
<li>创建新的镜像桶页面，设置好镜像桶局部高度和对应索引；</li>
<li>将原桶中的元素重新散列到原桶和镜像桶中；</li>
<li>可能之前存在逻辑桶映射到原桶对应的桶页面，这些信息也要相应的调整；</li>
<li>最后再次尝试插入数据；</li>
</ul>
</li>
<li><p>合并空桶的步骤：</p>
<ul>
<li>先获取目录页和空桶和其镜像桶的索引；</li>
<li>判断桶索引是否有效，即索引（下标）小于Size()；</li>
<li>如果空桶的局部高度已经等于0，就不能再合并；</li>
<li>如果两兄弟桶的局部高度不相等，也不能再合并；</li>
<li>如果两兄弟桶指向的桶页面相同，也不合并；</li>
<li>因为并发问题，再取出桶页面，并再次检查是不是空桶；</li>
<li>删除空桶对应的桶页面；</li>
<li>进行合并，就是改变空桶指向，将空桶（逻辑桶）指向其镜像桶对应的桶页面；</li>
<li>将这两兄弟桶局部高度减一个单位；</li>
<li>遍历所有桶，将指向原空桶或镜像桶的其它桶都指向镜像桶，同时设置减小后的局部高度；</li>
<li>判断全局高度是否需要减少；</li>
<li>递归合并其它可能存在的空桶；</li>
</ul>
</li>
<li><p>每次取出目录页或桶页操作后一定要Unpin，不然内存承受不了，缓存池满了；</p>
</li>
<li><p>取出目录页代码，用到了reinterpret_cast，取出桶页类似，都是将Page页面解释成相应类型；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> KeyType, <span class="hljs-keyword">typename</span> ValueType, <span class="hljs-keyword">typename</span> KeyComparator&gt;<br><span class="hljs-function">HashTableDirectoryPage *<span class="hljs-title">HASH_TABLE_TYPE::FetchDirectoryPage</span><span class="hljs-params">()</span> </span>&#123;<br>  Page *dir_page_raw = buffer_pool_manager_-&gt;<span class="hljs-built_in">FetchPage</span>(directory_page_id_);<br>  <span class="hljs-built_in">assert</span>(dir_page_raw != <span class="hljs-literal">nullptr</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;HashTableDirectoryPage *&gt;(dir_page_raw-&gt;<span class="hljs-built_in">GetData</span>());<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>一些基本代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 创建新页</span><br>Page *buc0_page_raw = buffer_pool_manager_-&gt;<span class="hljs-built_in">NewPage</span>(&amp;buc0_page_id);<br><span class="hljs-comment">// 获取目录页、桶页</span><br>HashTableDirectoryPage *dir_page = <span class="hljs-built_in">FetchDirectoryPage</span>();<br><span class="hljs-type">page_id_t</span> buc_page_id = <span class="hljs-built_in">KeyToPageId</span>(key, dir_page);<br>HASH_TABLE_BUCKET_TYPE *buc_page = <span class="hljs-built_in">FetchBucketPage</span>(buc_page_id);<br><span class="hljs-comment">// unpin页面</span><br>buffer_pool_manager_-&gt;<span class="hljs-built_in">UnpinPage</span>(directory_page_id_, <span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="Task-3-并发控制"><a href="#Task-3-并发控制" class="headerlink" title="Task #3 并发控制"></a>Task #3 并发控制</h4><p>需要时就加锁，哈希表（目录页）有table_latch_，桶页用page对象原始的锁，两者都有读锁和写锁；</p>
<p>桶页加锁用到reinterpret_cast，将桶页类型的对象重解释成page对象；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">Page *buc_page_raw = <span class="hljs-built_in">reinterpret_cast</span>&lt;Page *&gt;(buc_page);<br>buc_page_raw-&gt;<span class="hljs-built_in">RLatch</span>();  	<span class="hljs-comment">// 加读锁</span><br>buc_page_raw-&gt;<span class="hljs-built_in">RUnlatch</span>();  	<span class="hljs-comment">// 解读锁</span><br></code></pre></td></tr></table></figure>

<p>哈希表加锁使用table_latch_；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">table_latch_.<span class="hljs-built_in">WLock</span>();  		<span class="hljs-comment">// 写锁</span><br>table_latch_.<span class="hljs-built_in">WUnlock</span>();<br></code></pre></td></tr></table></figure>

<p>加锁思路：</p>
<ul>
<li>GetValue对哈希表和桶页面上读锁；</li>
<li>Insert对哈希表上读锁，对桶页面上写锁，因为这里只对一个Bucket操作；</li>
<li>SplitInsert需要对哈希表和桶页面都上写锁，因为这里涉及到了Directory的操作；</li>
<li>Remove需要对哈希表上读锁，对桶页面上写锁；</li>
<li>Merge需要对哈希表上写锁，因为只是修改Directory，也并没有取出镜像桶页面；</li>
</ul>
<h4 id="其它-1"><a href="#其它-1" class="headerlink" title="其它"></a>其它</h4><p>我一开始对可扩展哈希索引的概念理解得并不是很清楚，就直接做实验了，后面在桶分裂和桶合并的代码一直存在BUG，一会改这一会改那，提交始终过不了，不是这出问题就是那儿出问题，也连着折腾了好几个晚上。</p>
<p>后面看了些其它博客分析的思路，看了好几遍可扩展哈希索引的概念，理清了思路。也重新从实验一缓存池开始检查代码，发现BPM（缓存池）完成得有瑕疵（lru_replacer容量满了后多删了页面，以及对页面pin_count的检查），所以存在内存泄漏。也在lab2中完善了处理哈希表扩展、收缩的小细节（如忘了uppin页面，没有处理其它被分裂或合并影响的桶等等），再后面改着改着BUG就通关全部测试了；</p>
<p>可以使用断言<code>assert</code>，以快速定位不符合预期的地方，还可以结合日志模块<code>LOG_DEBUG</code>，打印日志排查问题；</p>
<p>要保证每个小功能的以及前一个实验的正确性，毕竟整个项目是自底向上构建的，会用到前一个实验的实现模块，当前实验出错可能是上一个实验的隐藏问题导致的，测试文件并非100%的完善；</p>
<p>全部完成Lab2后，感觉好像也没有那么难了，主要是考虑的细节比较多，关键要思路清晰；</p>
<h2 id="Project3-Query-Execution"><a href="#Project3-Query-Execution" class="headerlink" title="Project3 Query Execution"></a>Project3 Query Execution</h2><h3 id="说明-3"><a href="#说明-3" class="headerlink" title="说明"></a>说明</h3><p>第三个项目中，您将实现负责获取查询计划节点并执行他们的执行器。DBMS还不支持SQL，所以您的实现将直接在手工编写的查询计划上运行。</p>
<p>使用迭代器模型（又称火山模型）。每个查询计划执行器中，Init方法初始化操作符的内部状态，Next方法提供迭代器的接口，该接口在每次调用时返回一个记录和一个记录标识符（Record Identifier）（也可能是执行器已经结束的标志）。记录标识符是该记录相对于其所属表的唯一标识符。</p>
<p>每个执行器实现一个循环，该循环继续调用其子对象的Next函数来检索记录并逐个处理他们。</p>
<p>9个操作分别是<code>Sequential Scan、Insert、Update、Delete、Nested Loop Join、Hash Join、Aggregation、Limit、Distinct</code>。</p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>该Lab感觉是让我们了解了一下常见SQL语句的执行逻辑，关键是要理解代码中各个类接口的作用；</p>
<ul>
<li>常用代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 头文件定义辅助成员变量</span><br>TableInfo *table_info_;<br><span class="hljs-comment">// Init函数初始化</span><br>table_info_ = exec_ctx_-&gt;<span class="hljs-built_in">GetCatalog</span>()-&gt;<span class="hljs-built_in">GetTable</span>(plan_-&gt;<span class="hljs-built_in">GetTableOid</span>());<br><br><span class="hljs-comment">// Predicate条件判断</span><br><span class="hljs-type">bool</span> is_valid = plan_-&gt;<span class="hljs-built_in">GetPredicate</span>()-&gt;<span class="hljs-built_in">Evaluate</span>(&amp;(*iter_), &amp;(table_info_-&gt;schema_)).<span class="hljs-built_in">GetAs</span>&lt;<span class="hljs-type">bool</span>&gt;();<br><br><span class="hljs-comment">// 取出当前符合条件行的每一列数据</span><br>std::vector&lt;Value&gt; values;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">GetOutputSchema</span>()-&gt;<span class="hljs-built_in">GetColumnCount</span>(); ++i) &#123;<br>    values.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">GetOutputSchema</span>()-&gt;<span class="hljs-built_in">GetColumn</span>(i).<span class="hljs-built_in">GetExpr</span>()-&gt;<span class="hljs-built_in">Evaluate</span>(&amp;(*iter_), &amp;(table_info_-&gt;schema_)));<br>&#125;<br>*tuple = <span class="hljs-built_in">Tuple</span>(values, <span class="hljs-built_in">GetOutputSchema</span>());<br><br><span class="hljs-comment">// 索引变更，示例是增加索引</span><br>indexinfo-&gt;index_-&gt;<span class="hljs-built_in">InsertEntry</span>(tuple-&gt;<span class="hljs-built_in">KeyFromTuple</span>(table_info_-&gt;schema_, *(indexinfo-&gt;index_-&gt;<span class="hljs-built_in">GetKeySchema</span>()), indexinfo-&gt;index_-&gt;<span class="hljs-built_in">GetKeyAttrs</span>()), new_rid, exec_ctx_-&gt;<span class="hljs-built_in">GetTransaction</span>());<br></code></pre></td></tr></table></figure>

<ul>
<li>Hash Join、Distinct需要仿造头文件中 <code>SimpleAggregationHashTable</code>实现哈希方法，这是我参考的<a target="_blank" rel="noopener" href="https://www.epis2048.net/2021/15445-lab3/">博客</a>。</li>
</ul>
<h2 id="Project4-Concurency-Control"><a href="#Project4-Concurency-Control" class="headerlink" title="Project4 Concurency Control"></a>Project4 Concurency Control</h2><h3 id="说明-4"><a href="#说明-4" class="headerlink" title="说明"></a>说明</h3><p>第四个项目是在DBMS中实现一个Lock Manager，然后使用他来支持并发执行。锁管理器负责跟踪向事务发出的<strong>行级锁</strong>，并支持根据隔离级别适当的上或释放共享锁和排他锁。LM（锁管理器）的基本思想是，它维护一个关于活动事务当前持有的锁的内部数据结构（请求队列），然后事务在访问数据项之前向LM发出锁请求，LM将根据情况决定锁授予该事务、阻止该事务还是终止该事务。使用Wound-Wait策略避免死锁。</p>
<p>需要LM支持三个常见的隔离级别：READ_UNCOMMITED，READ_COMMITTED和REPEATABLE_READ。</p>
<p>任何失败的锁操作都应该导致事务终止（隐式Aborted）并抛出异常。事务管理器将进一步捕获该异常并回滚事务执行的写操作。</p>
<p>我把共享锁也称作读锁，排他锁也称作写锁；</p>
<p>二段封锁协议（2PL）：事务分为两个阶段（不考虑commit&#x2F;abort），上锁阶段（<code>GROWING</code>）只获取锁或升级锁，不能释放锁；解锁阶段（<code>SHINKING</code>）只解锁，不能获取和升级锁。这样，第二次读取时，前一次读取的读锁一定还在，避免了中途被修改。</p>
<p>严格二段封锁协议：增加在<code>SHRINKING</code>阶段也不能释放锁，只有在事务 commit 或 abort 时统一释放锁的限制；</p>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><h4 id="Task-1-锁管理器"><a href="#Task-1-锁管理器" class="headerlink" title="Task #1 锁管理器"></a>Task #1 锁管理器</h4><p>脏读的产生：事务1修改数据，被事务2读到，之后事务1 abort，事务2读到的是脏数据。</p>
<p>不可重复读的产生：事务1读数据，事务2修改数据，事务1再读数据，事务1两次读到的数据不一致。</p>
<p>幻读的产生：事务1统计行数，事务2插入数据，事务1再统计行数，事务1两次统计的行数不一致。</p>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">实现方式</th>
<th align="center">可能问题</th>
</tr>
</thead>
<tbody><tr>
<td align="center">READ_UNCOMMITED</td>
<td align="center">只在写操作时上写锁</td>
<td align="center">脏读、不可重复读、幻读</td>
</tr>
<tr>
<td align="center">READ_COMMITTED</td>
<td align="center">读时上读锁，读完解读锁；写时上写锁，写完解写锁</td>
<td align="center">不可重复读、幻读</td>
</tr>
<tr>
<td align="center">REPEATABLE_READ</td>
<td align="center">读写均需要加锁，遵守严格2PL</td>
<td align="center">幻读</td>
</tr>
</tbody></table>
<blockquote>
<p>其它的和死锁预防预防一起写了；</p>
</blockquote>
<h4 id="Task-2-死锁预防"><a href="#Task-2-死锁预防" class="headerlink" title="Task #2 死锁预防"></a>Task #2 死锁预防</h4><ul>
<li>事务txd_id大的就是新事务，小的是老事务；</li>
<li>加共享锁步骤：<ul>
<li>状态已经是<code>ABORTED</code>的事务，直接返回false；</li>
<li>隔离级别是读未提交，无需共享锁，设置事务abort，然后返回false；</li>
<li>隔离级别是可重复读，但不处于<code>GROWING</code>阶段，设置事务abort，然后返回false；</li>
<li>已经获得共享锁或排他锁，直接返回true；</li>
<li>遍历rid（元组）对应的请求队列，根据wound-wait原则；</li>
<li>若遇到新事务，如果新事物申请持有写锁就需要Abort这个新事务，新事务申请持有读锁则可以共存，跳过继续遍历；</li>
<li>若遇到老事务，如果老事务申请持有写锁，事务就条件变量等待获取锁<code>cv_.wait(locker)</code>，如果老事务申请持有读锁，可以共存，跳过继续遍历；</li>
<li>当成功获取锁后，还要循环判断事务自己在等待获取锁期间是不是被abort了；</li>
<li>构造<code>SHARED</code>模式的请求节点，将请求节点加入请求队列尾部，并将rid加入事务的共享锁集，设置事务状态为<code>GROWING</code>，返回true；</li>
</ul>
</li>
<li>加排他锁步骤：<ul>
<li>类似获取共享锁，不过排他锁和所有锁互斥；</li>
<li>遇到新事务，可以abort掉任何新事务；</li>
<li>遇到老事务，事务自己被abort，返回false；</li>
</ul>
</li>
<li>升级锁步骤：<ul>
<li>也类似获取共享锁；</li>
<li>只有共享锁才能升级成排他锁；</li>
<li>遇到新事务，可以abort掉任何新事务；</li>
<li>遇到老事务，不论老事务申请锁的类型，事务自己就条件变量等待获取锁<code>cv_.wait(locker)</code>；</li>
<li>成功后还要调整请求节点的模式和事务对应的锁集；</li>
</ul>
</li>
<li>解锁步骤：<ul>
<li>先判断是不是真的加有锁，不是就返回false;</li>
<li>若待解锁事务隔离级别是 REPETABLE_READ，且处于 2PL 的 GROWING 阶段，将 2PL 设置为 SHRINKING 阶段；</li>
<li>从事务对应的锁集（共享锁集或排他锁集）中移除rid；</li>
</ul>
</li>
</ul>
<h4 id="Task-3-执行并发查询"><a href="#Task-3-执行并发查询" class="headerlink" title="Task #3 执行并发查询"></a>Task #3 执行并发查询</h4><p>需要我们修改部分执行器的代码，加入刚刚实现好的共享或排他锁，并且还要求支持事务的回滚。只需要修改<code>Sequential Scan、Insert、Update、Delete</code>这4个执行器。</p>
<p>顺序扫描时，如果不是<code>READ_UNCOMMITTED</code>，读取均需要获取共享锁。如果是 READ_COMMITTED，读完后需要立刻释放 shared lock。</p>
<p>增删改操作不管什么级别都需要获取排他锁（如果已经有共享锁，升级为排他锁），READ_UNCOMMITTED和READ_COMMITTED写入完成后立刻释放排他锁。<code>REPEATABLE_READ</code>会在整个事务commit时统一 unlock，因为READ_COMMITTED 需要等待提交后才可以被其他事务读取，不释放锁，不需要我们自己编写代码。</p>
<p>如下是需增加的示例代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 获取锁</span><br>LockManager *locker = <span class="hljs-built_in">GetExecutorContext</span>()-&gt;<span class="hljs-built_in">GetLockManager</span>();<br>Transaction *txn = <span class="hljs-built_in">GetExecutorContext</span>()-&gt;<span class="hljs-built_in">GetTransaction</span>();<br><br><span class="hljs-comment">// 加解读锁</span><br>locker-&gt;<span class="hljs-built_in">LockShared</span>(txn, rid);<br>locker-&gt;<span class="hljs-built_in">Unlock</span>(txn, rid);<br><br><span class="hljs-comment">// 加写锁</span><br><span class="hljs-keyword">if</span> (txn-&gt;<span class="hljs-built_in">IsSharedLocked</span>(new_rid)) &#123;<br>    locker-&gt;<span class="hljs-built_in">LockUpgrade</span>(txn, new_rid);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!txn-&gt;<span class="hljs-built_in">IsExclusiveLocked</span>(new_rid)) &#123;<br>    locker-&gt;<span class="hljs-built_in">LockExclusive</span>(txn, new_rid);<br>&#125;<br><span class="hljs-comment">// 解写锁</span><br><span class="hljs-keyword">if</span> (txn-&gt;<span class="hljs-built_in">GetIsolationLevel</span>() != IsolationLevel::REPEATABLE_READ) &#123;<br>    locker-&gt;<span class="hljs-built_in">Unlock</span>(txn, new_rid);<br>&#125;<br><br><span class="hljs-comment">// 记录事务变更，为了回滚</span><br>txn-&gt;<span class="hljs-built_in">GetIndexWriteSet</span>()-&gt;<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">IndexWriteRecord</span>(new_rid, table_info_-&gt;oid_, WType::INSERT, *tuple,indexinfo-&gt;index_oid_, exec_ctx_-&gt;<span class="hljs-built_in">GetCatalog</span>()));<br></code></pre></td></tr></table></figure>

<h2 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h2><p>公开课<a target="_blank" rel="noopener" href="https://15445.courses.cs.cmu.edu/fall2021/">CMU15-445</a>算是一门网红数据库课程，很早就想做一做对应的Lab，遂在两个月前开始刷起课程视频。不过课程视频陆陆续续地只看了一半左右，后面有空时就直接开始做Lab了。因为之前学过数据库，所以课程视频讲的知识有些也大概了解，索性就直接上手实验，想着遇到不懂的再翻书或PPT。</p>
<p>尽管学习过数据库，但不复习也没有再用到，好多知识都模糊甚至忘记了，所以也想借此做Lab的过程加强对数据库底层原理的理解，完成全部实验后确实大有收获，感谢课程组老师们提供这门课程。</p>
<p>本文对应的实验是<a target="_blank" rel="noopener" href="https://15445.courses.cs.cmu.edu/fall2021/assignments.html">2021 FALL</a>版本的，总耗时12天左右，借助于其它博客，不然肯定需要多好多的时间来完成，感谢大佬们分享的思路。</p>
<p>做完后还是对某些部分的概念模模糊糊的，后续还需要结合教材才能理解得更好。</p>
<hr>
<p>【参考资料】</p>
<p><a target="_blank" rel="noopener" href="https://www.qtmuniao.com/2021/02/10/cmu15445-project1-buffer-pool/">Cmu15445 数据库系统实验一：Buffer Pool Manager</a></p>
<p><a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/extendible-hashing-dynamic-approach-to-dbms/">可扩展哈希索引</a></p>
<p><a target="_blank" rel="noopener" href="https://www.epis2048.net/categories/Code/CMU-15445/">CMU-15445-BusTub 笔记</a></p>
<p><a target="_blank" rel="noopener" href="https://www.inlighting.org/archives/cmu-15-445-notes">2021 CMU 15-445 实验笔记</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/twentyonepilots/article/details/120868216">CMU15-445 数据库实验全满分通过笔记 2021 Fall bustub-cmudb lab</a></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E9%A1%B9%E7%9B%AE/" class="category-chain-item">项目</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E9%A1%B9%E7%9B%AE/">#项目</a>
      
        <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">#数据库</a>
      
        <a href="/tags/%E5%8F%AF%E6%89%A9%E5%B1%95%E5%93%88%E5%B8%8C/">#可扩展哈希</a>
      
        <a href="/tags/%E7%BC%93%E5%AD%98%E6%B1%A0/">#缓存池</a>
      
        <a href="/tags/LRU/">#LRU</a>
      
        <a href="/tags/%E7%81%AB%E5%B1%B1%E6%A8%A1%E5%9E%8B/">#火山模型</a>
      
        <a href="/tags/%E8%AF%BB%E9%94%81/">#读锁</a>
      
        <a href="/tags/%E5%86%99%E9%94%81/">#写锁</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>CMU15-445数据库实验总结</div>
      <div>http://example.com/2022/08/13/CMU15-445数据库实验总结/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>ZYUE</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年8月13日</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>更新于</div>
          <div>2022年8月15日</div>
        </div>
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/08/20/Shell%E8%84%9A%E6%9C%AC%E7%AC%94%E8%AE%B0/" title="Shell脚本笔记">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Shell脚本笔记</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/08/06/%E5%AE%9E%E7%8E%B0%E8%AE%A1%E7%AE%97%E5%99%A8%E4%BB%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/" title="实现计算器从表达式求值">
                        <span class="hidden-mobile">实现计算器从表达式求值</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a>
<a target="_blank" rel="noopener" href="https://developer.hitokoto.cn/" id="hitokoto_text"><span style="color:#134769;"  id="hitokoto"></span></a> <script src="https://v1.hitokoto.cn/?encode=js&select=%23hitokoto" defer></script> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
