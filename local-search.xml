<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>CMU15-445数据库实验总结</title>
    <link href="/2022/08/13/CMU15-445%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    <url>/2022/08/13/CMU15-445%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="简要介绍"><a href="#简要介绍" class="headerlink" title="简要介绍"></a>简要介绍</h2><p>这门课程共五个配套实验，不过关于数据库的是后面4个实验，第一个实验是检验基本C++语言能力的前菜。</p><p>实验全部都是完形填空的形式，需要我们实现声明好的函数，自己也可以增加其它成员变量或成员函数来辅助完成实验要求。</p><p>实验配套的开源项目是<code>bustub</code>，需要我们从github上clone下来，按照README配置环境就好。我是在VMWARE中装Ubuntu18.04虚拟机来完成实验的，一定要仔细看环境要求，免得工具链不支持折腾时间。我最开始是用Ubuntu22.04，结果回退代码版本到2021fall的实验位置后似乎编译不了，又不得不再配环境（因为我菜，不知道怎么修改）。</p><p>另外，这门课还开放了<code>Gradescope</code>在线测试平台，非CMU的学生也可以使用，非常不错。因为本地的测试代码都比较简单，Gradescope上面才是严格的测试，注册时要选卡内梅隆基大学和填入口代码，每次上传代码文件时最好运行如下命令检查一下代码格式，因为代码格式检查非常严格，不合规直接0分。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ make format<br>$ make check-lint<br>$ make check-clang-tidy<br></code></pre></td></tr></table></figure><p>还有一个上传代码的坑点是提交时要另外多加一个文件<code>tmp_tuple_page.h</code>，具体修改见github issue #225。</p><p>于自己而言，实验难度大概是 <code>proj0 &lt; proj1 &lt; proj3 &lt;= proj4 &lt;&lt; proj2</code>。其中project2难度最大，是实现可扩展哈希索引，虽然不是2020年听着就非常难的B+树索引，但感觉也不相上下（project2前前后后提交了差不多100次，每次改bug后再提交都得需要运行十几分钟才出结果，难顶…，还好没放弃最终通过全部测试）。project0感觉做不做都没关系，简单的矩阵运算。project1是实现缓存池，其中用到LRU缓存替换策略，管理数据库页面，相对简单。project3是执行查询语句相关的，主要是调用函数，看懂代码中各个类的关联就好。project4是并发控制，实现一个锁管理器（读写锁）和事务回滚的控制。所有实验项目中注意线程安全。在每个Lab前我们需要好好理解实验要求，看懂代码中接口之前的关系，然后理解原理，想好实现思路。</p><p>下文主要记录一下各个Lab中的实现思路和遇到问题的解决方法。</p><h2 id="Project0-C-Primer"><a href="#Project0-C-Primer" class="headerlink" title="Project0 C++ Primer"></a>Project0 C++ Primer</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>在这个项目中，您将实现三个类：Matrix、RowMatrix、RowMatrixOperations。这些矩阵是简单的二维矩阵，必须支持加法、矩阵乘法和简化的通用矩阵乘法(GEMM) 运算。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>直接写就行，不过注意：</p><ul><li><p>模板子类在实例化之前不知道他的模板父类是谁，所以在模板子类中调用父类成员需要加：（都可以）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">this</span>-&gt;var_name<br>Parent::var_name<br><span class="hljs-keyword">using</span> Parent::var_name;<br></code></pre></td></tr></table></figure></li><li><p>const对象只能调用const成员函数；</p></li><li><p>构造函数中new了对象后，记得在析构函数delete释放掉；</p></li><li><p>抛出异常：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">throw</span> <span class="hljs-built_in">Exception</span>(ExceptionType::OUT_OF_RANGE, <span class="hljs-string">&quot;index out of range&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p>智能指针uni_ptr转换为普通指针使用<code>ptr = uni_ptr.get()</code>；</p></li></ul><h2 id="Project1-Buffer-Pool-Manager"><a href="#Project1-Buffer-Pool-Manager" class="headerlink" title="Project1 Buffer Pool Manager"></a>Project1 Buffer Pool Manager</h2><h3 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h3><p>第一个编程项目是在存储管理器中实现缓冲池。缓冲池负责将物理页面从主内存来回移动到磁盘。它允许 DBMS 支持大于系统可用内存量的数据库。</p><p>因为在BusTub中，数据库中的数据以页为单位存储在磁盘中，使用时要把页面从磁盘加载到内存，此后再使用如果命中缓存也会提高效率。但内存的容量有限，当容量不足时就需要利用合理的规则淘汰掉某些页面，把位置留给有需要的；</p><p>在缓存池中，有些页面是空闲的，存在于空闲链表中，即没有数据库页面与它对应；有些数据库页面处于PIN后的状态，它们正在被使用，不能被淘汰；还有些数据库页面处于Unpin状态，在内存容量不足时被淘汰掉；</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><h4 id="Task-1-LRU替换策略"><a href="#Task-1-LRU替换策略" class="headerlink" title="Task #1 LRU替换策略"></a>Task #1 LRU替换策略</h4><p>使用LRU缓存替换策略，lru_replacer相当于一个回收站，管理frame_id。</p><ul><li>一个frame_id_t类型的frame_id代表一个内存帧位置，内存帧位置可以存放页面page，LRU管理的对象就是内存帧位置frame_id；</li><li>我们用unordered_map哈希表和list双向链表实现LRU算法，链表节点是一个frame_id帧位置，哈希表存每个链表节点的迭代器位置。这里链表尾部代表最近最久未使用的页面对应的 frame_id；</li><li>Pin函数：代表该帧位置对应的页面被某个线程正在使用，不能被替换出去，所以从lru_replacer（umap和list）中移除参数frame_id。从上层的视角而言就是固定某个页面，不被LRU管理；</li><li>Unpin函数：与Pin相反，表示没有线程在使用参数frame_id对应的页面，该页面可以被淘汰。所以要把frame_id加入到lru_replacer（umap和list）中，加到链表头部；</li><li>Victim函数：查看 lru_replacer 是否有可以牺牲的页面，有的话则取出帧位置 frame_id；</li></ul><h4 id="Task-2-缓冲池管理器实例"><a href="#Task-2-缓冲池管理器实例" class="headerlink" title="Task #2 缓冲池管理器实例"></a>Task #2 缓冲池管理器实例</h4><p>缓冲池管理器的作用其实就是获取在磁盘的数据库页面、创建新页面、删除页面、写回脏页。这里的一个page_id就唯一标识了一个页面，哈希表page_table_ 管理所有页面，lru_replacer管理的页面是page_table_ 中页面的子集，空闲链表free_list_中是未被使用的页面，和前两个独立。每个函数按注释的要求写就行。</p><ul><li>每次获取新内存页位置时，优先从空闲链表free_list_中取出，没有再从lru_replacer获取牺牲页；</li><li>脏页记得写入磁盘，创建新页时不能从磁盘读，因为此时还没有该页；</li><li>NewPgImp()时，成功取得要被替换的页面后再AllocatePage()；</li><li>记得将被替换的旧页ResetMemory()，必须要清空原数据；</li><li>每次操作记得设置好pin_count_引用计数；</li><li>UnpinPgImp后，只有页面的pin_count_为0时，表示没有线程使用，才能被加到空闲链表；</li></ul><h4 id="Task-3-并行缓冲池管理器"><a href="#Task-3-并行缓冲池管理器" class="headerlink" title="Task #3 并行缓冲池管理器"></a>Task #3 并行缓冲池管理器</h4><p>ParallelBufferPoolManager是一个拥有多个缓冲池管理器实例的类。对于每个操作，ParallelBufferPoolManager选择一个BufferPoolManagerInstance并委托给该实例。</p><p>也就是系统中拥有多个缓冲池，每个缓冲池都有自己的锁，减少了一个缓存池时抢占锁的开销，负载均衡的样子。</p><p>这里维护一个 next_instance_ 变量，轮询来判断下一次page的操作分配给那个Buffer Pool Manager。该类中只需在NewPgImp()函数加锁。</p><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><p>加锁建议利用RAII机制，如使用lock_guard、unique_lock、scoped_lock等，不然手动lock再unlock麻烦，还可能忘记加解锁而出现问题。我就忘记解锁造成死锁了，后面全部改用unique_lock；</p><p>有两种脏页的刷盘时机的策略，一种是每次 Unpin 的时候都刷，这样会刷比较频繁，但能保证异常掉电重启后内容不丢；一种是在 replacer victimized 的时候 lazily 的刷，这样能保证刷的次数最少；这是性能和可靠性的取舍。</p><h2 id="Project2-Hash-Index"><a href="#Project2-Hash-Index" class="headerlink" title="Project2 Hash Index"></a>Project2 Hash Index</h2><h3 id="说明-2"><a href="#说明-2" class="headerlink" title="说明"></a>说明</h3><p>第二个项目是为ButsTub DBMS实现一个磁盘支持的可扩展哈希表。哈希索引包含一个directory page，该目录页包含指向bucket page的指针。哈希表将通过第一个实现中的缓冲池访问页面。目录页存储了table和bucket的所有元数据。哈希表需要支持对满&#x2F;空bucket的拆分和合并，以及在全局深度必须更改时支持directory的扩展和收缩。</p><p>这里的桶页就是数据库中存储键值对数据的页面。在目录页中桶只是逻辑上的概念，就是一个索引位置，目录页中数组的索引i对应第i个桶，实际上可能有多个桶指向同一个物理桶页面（page）。</p><p>我把目录页中一个索引位置称作一个逻辑桶，一个物理桶页面称为桶页，满桶分裂时（空桶合并时）对应调整数据的桶称作镜像桶，它们互为兄弟桶。</p><p>每个哈希表的Directory或Bucket页对应于从缓冲池中获取的内存内的内容。每次尝试读写页面的时候，需要使用唯一的page_id从缓冲池中获取页面，然后将他们重新转换为Directory或Bucket页，并且要在任何读写操作之后Unpin这个页面。</p><p>建议先理解可扩展哈希索引的原理到位后再开始做此lab。</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><h4 id="目录页"><a href="#目录页" class="headerlink" title="目录页"></a>目录页</h4><table><thead><tr><th align="center">一些成员变量</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">global_depth_</td><td align="center">目录的全局深度</td></tr><tr><td align="center">local_depths_</td><td align="center">桶的局部深度的数组（uint8_t）</td></tr><tr><td align="center">bucket_page_ids_</td><td align="center">桶页的page_id的数组</td></tr></tbody></table><ul><li><p>目录页的全局高度global_depth_ 初始值是0，目录页中逻辑桶的索引范围是[0, Size())，也就是存在Size()个有效的逻辑桶，Size()由全局高度计算得到，就是2^global_depth_为有效逻辑桶的个数；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">HashTableDirectoryPage::Size</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> (<span class="hljs-number">1</span> &lt;&lt; global_depth_); &#125;<br></code></pre></td></tr></table></figure></li><li><p>根据目录页中数组大小是512，可知最多有512&#x3D;2^9个桶，所以在头文件定义一个最大全局高度；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_GLOBAL_DEPTH 9</span><br></code></pre></td></tr></table></figure></li><li><p>关于全局高度或局部高度掩码，是使用最低有效位，掩码与键的hash值&amp;运算得到该键对应的逻辑桶索引；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">HashTableDirectoryPage::GetGlobalDepthMask</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> (<span class="hljs-number">1</span> &lt;&lt; global_depth_) - <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">// 局部高度掩码类似</span><br></code></pre></td></tr></table></figure></li><li><p>只有当每个桶的局部高度严格小于目录的全局高度时，才执行目录收缩；</p></li><li><p>增加全局深度要将桶数量翻倍，只是逻辑上翻倍了原来的bucket，两个兄弟桶仍然指向同一个物理桶页面；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HashTableDirectoryPage::IncrGlobalDepth</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">uint32_t</span> old_size = <span class="hljs-built_in">Size</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> i = <span class="hljs-number">0</span>; i &lt; old_size; ++i) &#123;<br>    bucket_page_ids_[i + old_size] = bucket_page_ids_[i];<br>    local_depths_[i + old_size] = local_depths_[i];<br>  &#125;<br>  ++global_depth_;<br>  <span class="hljs-built_in">assert</span>(global_depth_ &lt;= MAX_GLOBAL_DEPTH);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>获取镜像桶（兄弟桶）的索引，其实就是将原桶索引的最高位取反；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">HashTableDirectoryPage::GetSplitImageIndex</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> bucket_idx)</span> </span>&#123;<br>  <span class="hljs-built_in">assert</span>(bucket_idx &lt; <span class="hljs-built_in">Size</span>());<br>  <span class="hljs-comment">// 用异或，给待分裂桶的下标的最高位取反，得到兄弟桶下标</span><br>  <span class="hljs-type">uint32_t</span> local_deep = local_depths_[bucket_idx];<br>  <span class="hljs-keyword">return</span> bucket_idx ^ (<span class="hljs-number">1</span> &lt;&lt; (local_deep - <span class="hljs-number">1</span>));<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="桶页"><a href="#桶页" class="headerlink" title="桶页"></a>桶页</h4><table><thead><tr><th align="center">成员变量</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">occupied_</td><td align="center">若数组array_ 的第i个索引曾经被占用过，则occued_的第i位为1</td></tr><tr><td align="center">readable_</td><td align="center">若数组array_ 的第i个索引包含一个可读值，则readable_的第i位为1</td></tr><tr><td align="center">array_</td><td align="center">保存key-value键值对的数组</td></tr></tbody></table><ul><li><p>array_是一个0长度数组，一个桶页面类对象后面的空间都用来存储键值对数据；</p></li><li><p>插入数据时满了返回false，也不能插入重复的键值对，如下是相等判断，cmp函数等于0就是相等的键，值可以直接比较；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">cmp</span>(key, <span class="hljs-built_in">KeyAt</span>(i)) == <span class="hljs-number">0</span> &amp;&amp; (value == <span class="hljs-built_in">ValueAt</span>(i)<br></code></pre></td></tr></table></figure></li><li><p>occupied_ 与readable_ 数组类型是char，一个char是8bit，可以表示8个位置，节约空间，对应的函数操作也就需要位运算了。插入数据需要将occupied_ 与readable_ 数组上对应的位置1，删除只需要将occupied_ 数组上对应的位置0。寻找对应位时，先找到所在char，再找到具体第几位。比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">uint8_t</span> ch = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint8_t</span>&gt;(readable_[bucket_idx / <span class="hljs-number">8</span>])<br>找到第几位: (<span class="hljs-number">1</span> &lt;&lt; (bucket_idx % <span class="hljs-number">8</span>))，再进行&amp;或|或~运算等等<br></code></pre></td></tr></table></figure></li><li><p>求NumReadable()，一个桶页面上可读（该位是1）的键值对数量，可以使用<code>ch &amp;= (ch - 1)</code>；</p></li><li><p>遍历全数组时，也就是处理每个char时，有向上取整；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> sz = (BUCKET_ARRAY_SIZE + <span class="hljs-number">8</span> - <span class="hljs-number">1</span>) / <span class="hljs-number">8</span>;  <span class="hljs-comment">// 向上取整</span><br></code></pre></td></tr></table></figure></li><li><p>空或满判断可以直接调用NumReadable()，看是不是等于0或BUCKET_ARRAY_SIZE；</p></li><li><p>还自定义了两个辅助函数配合桶分裂，取出桶中全部可读数据，重置桶页面（将可读位全部置0）；</p></li></ul><h4 id="可扩展哈希表"><a href="#可扩展哈希表" class="headerlink" title="可扩展哈希表"></a>可扩展哈希表</h4><ul><li><p>构造函数中创建目录页和第一个桶页，并设置第一个桶索引为0，局部高度为0；</p></li><li><p>普通的取出、插入、删除操作基本就是先取出目录页和对应桶页，然后调用我们在桶页实现的相应函数即可；</p></li><li><p>插入前判断到桶满了就分裂桶，删除元素后判断桶为空就合并，目录页也相应调整；</p></li><li><p>分裂满桶的步骤：</p><ul><li>先获取目录页和对应桶索引；</li><li>如果桶的局部高度已经等于MAX_GLOBAL_DEPTH，就不能再扩容；</li><li>因为并发问题，再取出桶页面，并再次检查是不是满了；</li><li>当桶页的局部高度等于目录的全局高度时，还需要增加全局高度；</li><li>将桶局部高度增加一个单位；</li><li>取出原桶的所有元素，清空原桶；</li><li>创建新的镜像桶页面，设置好镜像桶局部高度和对应索引；</li><li>将原桶中的元素重新散列到原桶和镜像桶中；</li><li>可能之前存在逻辑桶映射到原桶对应的桶页面，这些信息也要相应的调整；</li><li>最后再次尝试插入数据；</li></ul></li><li><p>合并空桶的步骤：</p><ul><li>先获取目录页和空桶和其镜像桶的索引；</li><li>判断桶索引是否有效，即索引（下标）小于Size()；</li><li>如果空桶的局部高度已经等于0，就不能再合并；</li><li>如果两兄弟桶的局部高度不相等，也不能再合并；</li><li>如果两兄弟桶指向的桶页面相同，也不合并；</li><li>因为并发问题，再取出桶页面，并再次检查是不是空桶；</li><li>删除空桶对应的桶页面；</li><li>进行合并，就是改变空桶指向，将空桶（逻辑桶）指向其镜像桶对应的桶页面；</li><li>将这两兄弟桶局部高度减一个单位；</li><li>遍历所有桶，将指向原空桶或镜像桶的其它桶都指向镜像桶，同时设置减小后的局部高度；</li><li>判断全局高度是否需要减少；</li><li>递归合并其它可能存在的空桶；</li></ul></li><li><p>每次取出目录页或桶页操作后一定要Unpin，不然内存承受不了；</p></li><li><p>取出目录页代码，用到了reinterpret_cast，取出桶页类似，都是将Page页面解释成相应类型；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> KeyType, <span class="hljs-keyword">typename</span> ValueType, <span class="hljs-keyword">typename</span> KeyComparator&gt;<br><span class="hljs-function">HashTableDirectoryPage *<span class="hljs-title">HASH_TABLE_TYPE::FetchDirectoryPage</span><span class="hljs-params">()</span> </span>&#123;<br>  Page *dir_page_raw = buffer_pool_manager_-&gt;<span class="hljs-built_in">FetchPage</span>(directory_page_id_);<br>  <span class="hljs-built_in">assert</span>(dir_page_raw != <span class="hljs-literal">nullptr</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;HashTableDirectoryPage *&gt;(dir_page_raw-&gt;<span class="hljs-built_in">GetData</span>());<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>一些基本代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 创建新页</span><br>Page *buc0_page_raw = buffer_pool_manager_-&gt;<span class="hljs-built_in">NewPage</span>(&amp;buc0_page_id);<br><span class="hljs-comment">// 获取目录页、桶页</span><br>HashTableDirectoryPage *dir_page = <span class="hljs-built_in">FetchDirectoryPage</span>();<br><span class="hljs-type">page_id_t</span> buc_page_id = <span class="hljs-built_in">KeyToPageId</span>(key, dir_page);<br>HASH_TABLE_BUCKET_TYPE *buc_page = <span class="hljs-built_in">FetchBucketPage</span>(buc_page_id);<br><span class="hljs-comment">// unpin页面</span><br>buffer_pool_manager_-&gt;<span class="hljs-built_in">UnpinPage</span>(directory_page_id_, <span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure></li></ul><h4 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h4><p>需要时就加锁，哈希表（目录页）有table_latch_，桶页用page对象原始的锁，两者都有读锁和写锁；</p><p>桶页加锁用到reinterpret_cast，将桶页类型的对象重解释成page对象；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">Page *buc_page_raw = <span class="hljs-built_in">reinterpret_cast</span>&lt;Page *&gt;(buc_page);<br>buc_page_raw-&gt;<span class="hljs-built_in">RLatch</span>();  <span class="hljs-comment">// 加读锁</span><br>buc_page_raw-&gt;<span class="hljs-built_in">RUnlatch</span>();  <span class="hljs-comment">// 解读锁</span><br></code></pre></td></tr></table></figure><p>哈希表加锁使用table_latch_；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">table_latch_.<span class="hljs-built_in">WLock</span>();  <span class="hljs-comment">// 写锁</span><br>table_latch_.<span class="hljs-built_in">WUnlock</span>();<br></code></pre></td></tr></table></figure><p>加锁思路：</p><ul><li>GetValue对哈希表和桶页面上读锁；</li><li>Insert对哈希表上读锁，对桶页面上写锁，因为这里只对一个Bucket操作；</li><li>SplitInsert需要对哈希表和桶页面都上写锁，因为这里涉及到了Directory的操作；</li><li>Remove需要对哈希表上读锁，对桶页面上写锁；</li><li>Merge需要对哈希表上写锁，因为只是修改Directory，也并没有取出镜像桶页面；</li></ul><h4 id="其它-1"><a href="#其它-1" class="headerlink" title="其它"></a>其它</h4><p>我一开始对可扩展哈希索引的概念理解得并不是很清楚，就直接做实验了，后面在桶分裂和桶合并的代码一直存在BUG，一会改这一会改那，提交始终过不了，不是这出问题就是那儿出问题，也连着折腾了好几个晚上。</p><p>后面看了些其它博客分析的思路，看了好几遍可扩展哈希索引的概念，理清了思路。也重新从实验一缓存池开始检查代码，发现BPM（缓存池）完成得有瑕疵（lru_replacer容量满了后多删了页面，以及对页面pin_count的检查），所以存在内存泄漏。也在lab2中完善了处理哈希表扩展、收缩的小细节（如忘了uppin页面，没有处理其它被分裂或合并影响的桶等等），再后面改着改着BUG就通关全部测试了；</p><p>可以使用断言<code>assert</code>，以快速定位不符合预期的地方，还可以结合日志模块<code>LOG_DEBUG</code>，打印日志排查问题；</p><p>要保证每个小功能的以及前一个实验的正确性，毕竟整个项目是自底向上构建的，会用到前一个实验的实现模块，当前实验出错可能是上一个实验的隐藏问题导致的，测试文件并非100%的完善；</p><p>全部完成Lab2后，感觉好像也没有那么难了，主要是考虑的细节比较多，关键要思路清晰；</p><h2 id="Project3-Query-Execution"><a href="#Project3-Query-Execution" class="headerlink" title="Project3 Query Execution"></a>Project3 Query Execution</h2><h3 id="说明-3"><a href="#说明-3" class="headerlink" title="说明"></a>说明</h3><p>第三个项目中，您将实现负责获取查询计划节点并执行他们的执行器。DBMS还不支持SQL，所以您的实现将直接在手工编写的查询计划上运行。</p><p>使用迭代器模型（又称火山模型）。每个查询计划执行器中，Init方法初始化操作符的内部状态，Next方法提供迭代器的接口，该接口在每次调用时返回一个记录和一个记录标识符（Record Identifier）（也可能是执行器已经结束的标志）。记录标识符是该记录相对于其所属表的唯一标识符。</p><p>每个执行器实现一个循环，该循环继续调用其子对象的Next函数来检索记录并逐个处理他们。</p><p>9个操作分别是<code>Sequential Scan、Insert、Update、Delete、Nested Loop Join、Hash Join、Aggregation、Limit、Distinct</code>。</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>该Lab感觉是让我们了解了一下常见SQL语句的执行逻辑，关键是要理解代码中各个类接口的作用；</p><ul><li>常用代码</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 头文件定义辅助成员变量</span><br>TableInfo *table_info_;<br><span class="hljs-comment">// Init函数初始化</span><br>table_info_ = exec_ctx_-&gt;<span class="hljs-built_in">GetCatalog</span>()-&gt;<span class="hljs-built_in">GetTable</span>(plan_-&gt;<span class="hljs-built_in">GetTableOid</span>());<br><br><span class="hljs-comment">// Predicate条件判断</span><br><span class="hljs-type">bool</span> is_valid = plan_-&gt;<span class="hljs-built_in">GetPredicate</span>()-&gt;<span class="hljs-built_in">Evaluate</span>(&amp;(*iter_), &amp;(table_info_-&gt;schema_)).<span class="hljs-built_in">GetAs</span>&lt;<span class="hljs-type">bool</span>&gt;();<br><br><span class="hljs-comment">// 取出当前符合条件行的每一列数据</span><br>std::vector&lt;Value&gt; values;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">GetOutputSchema</span>()-&gt;<span class="hljs-built_in">GetColumnCount</span>(); ++i) &#123;<br>    values.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">GetOutputSchema</span>()-&gt;<span class="hljs-built_in">GetColumn</span>(i).<span class="hljs-built_in">GetExpr</span>()-&gt;<span class="hljs-built_in">Evaluate</span>(&amp;(*iter_), &amp;(table_info_-&gt;schema_)));<br>&#125;<br>*tuple = <span class="hljs-built_in">Tuple</span>(values, <span class="hljs-built_in">GetOutputSchema</span>());<br><br><span class="hljs-comment">// 索引变更，示例是增加索引</span><br>indexinfo-&gt;index_-&gt;<span class="hljs-built_in">InsertEntry</span>(tuple-&gt;<span class="hljs-built_in">KeyFromTuple</span>(table_info_-&gt;schema_, *(indexinfo-&gt;index_-&gt;<span class="hljs-built_in">GetKeySchema</span>()), indexinfo-&gt;index_-&gt;<span class="hljs-built_in">GetKeyAttrs</span>()), new_rid, exec_ctx_-&gt;<span class="hljs-built_in">GetTransaction</span>());<br></code></pre></td></tr></table></figure><ul><li>Hash Join、Distinct需要仿造头文件中 <code>SimpleAggregationHashTable</code>实现哈希方法，这是我参考的<a href="https://www.epis2048.net/2021/15445-lab3/">博客</a>。</li></ul><h2 id="Project4-Concurency-Control"><a href="#Project4-Concurency-Control" class="headerlink" title="Project4 Concurency Control"></a>Project4 Concurency Control</h2><h3 id="说明-4"><a href="#说明-4" class="headerlink" title="说明"></a>说明</h3><p>第四个项目是在DBMS中实现一个Lock Manager，然后使用他来支持并发执行。锁管理器负责跟踪向事务发出的<strong>行级锁</strong>，并支持根据隔离级别适当的上或释放共享锁和排他锁。LM（锁管理器）的基本思想是，它维护一个关于活动事务当前持有的锁的内部数据结构（请求队列），然后事务在访问数据项之前向LM发出锁请求，LM将根据情况决定锁授予该事务、阻止该事务还是终止该事务。使用Wound-Wait策略避免死锁。</p><p>需要LM支持三个常见的隔离级别：READ_UNCOMMITED，READ_COMMITTED和REPEATABLE_READ。</p><p>任何失败的锁操作都应该导致事务终止（隐式Aborted）并抛出异常。事务管理器将进一步捕获该异常并回滚事务执行的写操作。</p><p>我把共享锁也称作读锁，排他锁也称作写锁；</p><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><h4 id="锁管理器-amp-死锁预防"><a href="#锁管理器-amp-死锁预防" class="headerlink" title="锁管理器&amp;死锁预防"></a>锁管理器&amp;死锁预防</h4><table><thead><tr><th align="center">隔离级别</th><th align="left">实现方式</th><th align="center">可能问题</th></tr></thead><tbody><tr><td align="center">READ_UNCOMMITED</td><td align="left">只在写操作时上写锁</td><td align="center"></td></tr><tr><td align="center">READ_COMMITTED</td><td align="left">读时上读锁，读完解读锁；写时上写锁，写完解写锁</td><td align="center"></td></tr><tr><td align="center">REPEATABLE_READ</td><td align="left">读写均需要加锁，严格遵守二段封锁协议（2PL）：事务分为两个阶段（不考虑commit&#x2F;abort），上锁阶段(GROWING)只上锁，解锁阶段(SHINKING)只解锁。这样，第二次读取时，前一次读取的读锁一定还在，避免了中途被修改。只有在事务 commit 或 abort 时统一放锁。</td><td align="center"></td></tr></tbody></table><ul><li>事务txd_id大的就是新事务，小的是老事务；</li><li>加共享锁步骤：<ul><li>状态已经是<code>ABORTED</code>的事务，直接返回false；</li><li>隔离级别是读未提交，无需共享锁，设置事务abort，然后返回false；</li><li>隔离级别是可重复读，但不处于<code>GROWING</code>阶段，设置事务abort，然后返回false；</li><li>已经获得共享锁或排他锁，直接返回true；</li><li>遍历rid（元组）对应的请求队列，根据wound-wait原则；</li><li>若遇到新事务，如果新事物申请持有写锁就需要Abort这个新事务，新事务申请持有读锁则可以共存，跳过继续遍历；</li><li>若遇到老事务，如果老事务申请持有写锁，事务就条件变量等待获取锁<code>cv_.wait(locker)</code>，如果老事务申请持有读锁，可以共存，跳过继续遍历；</li><li>当成功获取锁后，还要循环判断事务自己是不是被abort了；</li><li>构造<code>SHARED</code>模式的请求节点，将请求节点加入请求队列尾部，并将rid加入事务的共享锁集，设置事务状态为<code>GROWING</code>，返回true；</li></ul></li><li>加排他锁步骤：<ul><li>类似获取共享锁，不过排他锁和所有锁互斥；</li><li>遇到新事务，可以abort掉任何新事务；</li><li>遇到老事务，事务自己被abort，返回false；</li></ul></li><li>升级锁步骤：<ul><li>也类似获取共享锁；</li><li>只有共享锁才能升级成排他锁；</li><li>遇到新事务，可以abort掉任何新事务；</li><li>遇到老事务，不论老事务申请锁的类型，事务自己就条件变量等待获取锁<code>cv_.wait(locker)</code>；</li><li>成功后还要调整请求节点的模式和事务对应的锁集；</li></ul></li><li>解锁步骤：<ul><li>先判断是不是真的加有锁，不是就返回false;</li><li>若待解锁事务隔离级别是 REPETABLE_READ，且处于 2PL 的 GROWING 阶段，将 2PL 设置为 SHRINKING 阶段；</li><li>从事务对应的锁集（共享锁集或排他锁集）中移除rid；</li></ul></li></ul><h4 id="事务并发控制"><a href="#事务并发控制" class="headerlink" title="事务并发控制"></a>事务并发控制</h4><p>需要我们修改部分执行器的代码，加入刚刚实现好的共享或排他锁，并且还要求支持事务的回滚。只需要修改<code>Sequential Scan、Insert、Update、Delete</code>这4个执行器。</p><p>顺序扫描时，如果不是<code>READ_UNCOMMITTED</code>，读取均需要获取共享锁。如果是 READ_COMMITTED，读完后需要立刻释放 shared lock。</p><p>增删改操作不管什么级别都需要获取排他锁（如果已经有共享锁，升级为排他锁），READ_UNCOMMITTED和READ_COMMITTED写入完成后立刻释放排他锁。<code>REPEATABLE_READ</code>会在整个事务commit时统一 unlock，不需要我们自己编写代码。</p><p>如下是需增加的示例代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 获取锁</span><br>LockManager *locker = <span class="hljs-built_in">GetExecutorContext</span>()-&gt;<span class="hljs-built_in">GetLockManager</span>();<br>Transaction *txn = <span class="hljs-built_in">GetExecutorContext</span>()-&gt;<span class="hljs-built_in">GetTransaction</span>();<br><br><span class="hljs-comment">// 加解读锁</span><br>locker-&gt;<span class="hljs-built_in">LockShared</span>(txn, rid);<br>locker-&gt;<span class="hljs-built_in">Unlock</span>(txn, rid);<br><br><span class="hljs-comment">// 加写锁</span><br><span class="hljs-keyword">if</span> (txn-&gt;<span class="hljs-built_in">IsSharedLocked</span>(new_rid)) &#123;<br>    locker-&gt;<span class="hljs-built_in">LockUpgrade</span>(txn, new_rid);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!txn-&gt;<span class="hljs-built_in">IsExclusiveLocked</span>(new_rid)) &#123;<br>    locker-&gt;<span class="hljs-built_in">LockExclusive</span>(txn, new_rid);<br>&#125;<br><span class="hljs-comment">// 解写锁</span><br><span class="hljs-keyword">if</span> (txn-&gt;<span class="hljs-built_in">GetIsolationLevel</span>() != IsolationLevel::REPEATABLE_READ) &#123;<br>    locker-&gt;<span class="hljs-built_in">Unlock</span>(txn, new_rid);<br>&#125;<br><br><span class="hljs-comment">// 记录事务变更，为了回滚</span><br>txn-&gt;<span class="hljs-built_in">GetIndexWriteSet</span>()-&gt;<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">IndexWriteRecord</span>(new_rid, table_info_-&gt;oid_, WType::INSERT, *tuple,indexinfo-&gt;index_oid_, exec_ctx_-&gt;<span class="hljs-built_in">GetCatalog</span>()));<br></code></pre></td></tr></table></figure><h2 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h2><p>公开课<a href="https://15445.courses.cs.cmu.edu/fall2021/">CMU15-445</a>算是一门网红数据库课程，很早就想做一做对应的Lab，遂在两个月前开始刷起课程视频。不过课程视频陆陆续续地只看了一半左右，后面有空时就直接开始做Lab了。因为之前学过数据库，所以课程视频讲的知识有些也大概了解，索性就直接上手实验，想着遇到不懂的再翻书或PPT。</p><p>尽管学习过数据库，但不复习也没有再用到，好多知识都模糊甚至忘记了，所以也想借此做Lab的过程加强对数据库底层原理的理解，完成全部实验后确实大有收获，感谢课程组老师们提供这门课程。</p><p>本文对应的实验是<a href="https://15445.courses.cs.cmu.edu/fall2021/assignments.html">2021 FALL</a>版本的，总耗时12天左右，借助于其它博客，不然肯定需要多好多的时间来完成，感谢大佬们分享的思路。</p><p>做完后还是对某些部分的概念模模糊糊的，后续还需要结合教材才能理解得更好。</p><hr><p>【参考资料】</p><p><a href="https://www.qtmuniao.com/2021/02/10/cmu15445-project1-buffer-pool/">Cmu15445 数据库系统实验一：Buffer Pool Manager</a></p><p><a href="https://www.geeksforgeeks.org/extendible-hashing-dynamic-approach-to-dbms/">可扩展哈希索引</a></p><p><a href="https://www.epis2048.net/categories/Code/CMU-15445/">CMU-15445-BusTub 笔记</a></p><p><a href="https://www.inlighting.org/archives/cmu-15-445-notes">2021 CMU 15-445 实验笔记</a></p><p><a href="https://blog.csdn.net/twentyonepilots/article/details/120868216">CMU15-445 数据库实验全满分通过笔记 2021 Fall bustub-cmudb lab</a></p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目</tag>
      
      <tag>数据库</tag>
      
      <tag>可扩展哈希</tag>
      
      <tag>缓存池</tag>
      
      <tag>LRU</tag>
      
      <tag>火山模型</tag>
      
      <tag>读锁</tag>
      
      <tag>写锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实现计算器从表达式求值</title>
    <link href="/2022/08/06/%E5%AE%9E%E7%8E%B0%E8%AE%A1%E7%AE%97%E5%99%A8%E4%BB%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/"/>
    <url>/2022/08/06/%E5%AE%9E%E7%8E%B0%E8%AE%A1%E7%AE%97%E5%99%A8%E4%BB%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h2 id="双栈解法"><a href="#双栈解法" class="headerlink" title="双栈解法"></a>双栈解法</h2><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>一个栈<code>nums</code>存放数值，一个栈<code>ops</code>存放符合（运算符和括号）；</li><li>遍历字符串有四种情况：<ul><li>左括号：直接入ops栈；</li><li>右括号：从现有的两个栈里面计算，直到遇到左括号；</li><li>数字：取出整数放入nums栈；</li><li>运算符：先把两个栈里面可以计算的都计算，然后将新运算符加入ops栈；</li></ul></li><li>注意事项：<ul><li>处理字符串前先将空格去除；</li><li>每次计算得到的结果同样存放在nums栈中；</li><li>只有「栈内运算符」比「当前运算符」优先级高&#x2F;同等，才进行栈里面的运算；</li><li>由于第一个数可能是负数，可以先在nums栈中加入一个0占位；</li><li>左括号后面也可能有负数，遇到时也往nums栈中加入一个0占位；</li></ul></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Caculater</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    string s;  <span class="hljs-comment">// 待计算字符串</span><br><br>    <span class="hljs-type">int</span> ans;  <span class="hljs-comment">// 计算结果</span><br><br>    stack&lt;<span class="hljs-type">int</span>&gt;  nums;  <span class="hljs-comment">// 存数值</span><br>    stack&lt;<span class="hljs-type">char</span>&gt; ops;   <span class="hljs-comment">// 存操作符和括号</span><br><br>    <span class="hljs-comment">// 返回操作符优先级</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">priority</span><span class="hljs-params">(<span class="hljs-type">char</span> op)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;+&#x27;</span> || op == <span class="hljs-string">&#x27;-&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;*&#x27;</span> || op == <span class="hljs-string">&#x27;/&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 去除空格</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeSpace</span><span class="hljs-params">()</span> </span>&#123;<br>        string tmp;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : s) &#123;<br>            <span class="hljs-keyword">if</span> (ch != <span class="hljs-string">&#x27; &#x27;</span>) tmp += ch;<br>        &#125;<br>        s = tmp;<br>    &#125;<br><br>    <span class="hljs-comment">// 从 nums 中取出两个操作数，从 ops 中取出运算符，然后计算</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">compute</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">2</span> || ops.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// x op y</span><br>        <span class="hljs-type">int</span> y = nums.<span class="hljs-built_in">top</span>(); nums.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-type">int</span> x = nums.<span class="hljs-built_in">top</span>(); nums.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-type">char</span> op = ops.<span class="hljs-built_in">top</span>(); ops.<span class="hljs-built_in">pop</span>();<br>        <br>        <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;+&#x27;</span>) ret = x + y;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;-&#x27;</span>) ret = x - y;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;*&#x27;</span>) ret = x * y;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;/&#x27;</span>) ret = x / y;<br>        <br>        nums.<span class="hljs-built_in">push</span>(ret);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 为了防止第一个数为负数，先往 nums 加个 0</span><br>        nums.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br><br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">char</span> ch = s[i];<br>            <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                <span class="hljs-comment">// 遇到左括号就入栈</span><br>                ops.<span class="hljs-built_in">push</span>(ch);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>                <span class="hljs-comment">// 遇到右括号就计算，直到栈里面的左括号</span><br>                <span class="hljs-keyword">while</span> (!ops.<span class="hljs-built_in">empty</span>() &amp;&amp; ops.<span class="hljs-built_in">top</span>() != <span class="hljs-string">&#x27;(&#x27;</span>) <span class="hljs-built_in">compute</span>();<br>                <span class="hljs-comment">//if (ops.top() == &#x27;(&#x27;) </span><br>                ops.<span class="hljs-built_in">pop</span>();  <span class="hljs-comment">// 弹出&#x27;(&#x27;,其实不用判断，因为有右括号必定有左括号</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isdigit</span>(ch)) &#123;<br>                <span class="hljs-comment">// 遇到数字，就取出入数值栈</span><br>                <span class="hljs-type">int</span> j      = i;<br>                <span class="hljs-type">int</span> number = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">while</span> (j &lt; n &amp;&amp; <span class="hljs-built_in">isdigit</span>(s[j])) &#123;<br>                    number = <span class="hljs-number">10</span> * number + (s[j] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>                    ++j;<br>                &#125;<br>                nums.<span class="hljs-built_in">push</span>(number);<br>                i = j - <span class="hljs-number">1</span>; <span class="hljs-comment">// 不能是i = j，因为for循环里面有++i；</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 遇到运算符</span><br>                <span class="hljs-comment">// 为防止括号内出现的首个字符为运算符</span><br>                <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; s[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                    nums.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>                &#125;<br>                <span class="hljs-comment">// 有一个新操作要入栈时，先把栈内可以算的都算了</span><br>                <span class="hljs-comment">// 只有满足「栈内运算符」比「当前运算符」优先级高/同等，才进行运算</span><br>                <span class="hljs-keyword">while</span> (!ops.<span class="hljs-built_in">empty</span>() &amp;&amp; ops.<span class="hljs-built_in">top</span>() != <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                    <span class="hljs-type">char</span> op = ops.<span class="hljs-built_in">top</span>();<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">priority</span>(op) &gt;= <span class="hljs-built_in">priority</span>(ch)) &#123;<br>                        <span class="hljs-built_in">compute</span>();<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>                ops.<span class="hljs-built_in">push</span>(ch);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 计算剩余的</span><br>        <span class="hljs-keyword">while</span> (!ops.<span class="hljs-built_in">empty</span>() &amp;&amp; ops.<span class="hljs-built_in">top</span>() != <span class="hljs-string">&#x27;(&#x27;</span>) <span class="hljs-built_in">compute</span>();<br>        <br>        ans = nums.<span class="hljs-built_in">top</span>();<br>        <span class="hljs-keyword">while</span> (!nums.<span class="hljs-built_in">empty</span>()) nums.<span class="hljs-built_in">pop</span>();  <span class="hljs-comment">// 清理计算结果</span><br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">input</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;please typeing correct caculate str here...\n&quot;</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">getline</span>(cin, s)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">output</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;caculate result is: &quot;</span> &lt;&lt; ans &lt;&lt; endl; &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-built_in">input</span>()) &#123;<br>            <span class="hljs-built_in">removeSpace</span>();<br>            <span class="hljs-built_in">process</span>();<br>            <span class="hljs-built_in">output</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> ptr = <span class="hljs-built_in">make_unique</span>&lt;Caculater&gt;();<br>    ptr-&gt;<span class="hljs-built_in">run</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>【参考文章】<a href="https://blog.nowcoder.net/n/c8c1ff4ecfb44ca4958b1ecbdcbf2021">宫水三叶的刷题日记</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>循环队列</title>
    <link href="/2022/08/02/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/"/>
    <url>/2022/08/02/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="循环队列定义"><a href="#循环队列定义" class="headerlink" title="循环队列定义"></a>循环队列定义</h2><ul><li><p>为充分利用向量空间，将向量空间想象为一个首尾相接的圆环，并称这种向量为循环向量。存储在其中的队列称为循环队列（Circular Queue）。循环队列是把顺序队列首尾相连，把存储队列元素的表从逻辑上看成一个环，成为循环队列。</p></li><li><p>在循环队列结构中，当存储空间的最后一个位置已被使用而再要进入队运算时，只需要存储空间的第一个位置空闲，便可将元素加入到第一个位置，即将存储空间的第一个位置作为队尾。 循环队列可以更简单防止伪溢出的发生，但队列大小是固定的。</p></li><li><p>可以使用<strong>数组</strong>或<strong>链表</strong>模拟循环队列；</p></li></ul><h2 id="使用数组模拟"><a href="#使用数组模拟" class="headerlink" title="使用数组模拟"></a>使用数组模拟</h2><p>在循环队列中，当队列为空时，有front&#x3D;rear，而当所有队列空间全占满时，也有front&#x3D;rear。为了区别这两种情况，规定循环队列最多只能有MaxSize-1个队列元素，<strong>当循环队列中只剩下一个空存储单元时，队列就已经满了</strong>。因此，队列判空的条件是<code>front=rear</code>，而队列判满的条件是<code>front = (rear+1)%MaxSize</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCircularQueue</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> front;  <span class="hljs-comment">// 队头元素下标</span><br>    <span class="hljs-type">int</span> back;   <span class="hljs-comment">// 队尾元素的后面一个的下标</span><br>    <span class="hljs-type">int</span> capcity;<br>    vector&lt;<span class="hljs-type">int</span>&gt; vec;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyCircularQueue</span>(<span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-comment">// 当循环队列中只剩下一个空存储单元时，则表示队列已满，所以数组容量为k+1</span><br>        capcity = k + <span class="hljs-number">1</span>;<br>        front = back = <span class="hljs-number">0</span>;<br>        vec.<span class="hljs-built_in">resize</span>(capcity);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">enQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isFull</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        vec[back] = value;<br>        back = (back + <span class="hljs-number">1</span>) % capcity;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">deQueue</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isEmpty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        front = (front + <span class="hljs-number">1</span>) % capcity;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Front</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isEmpty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> vec[front];<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Rear</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isEmpty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> rear = (back - <span class="hljs-number">1</span> + capcity) % capcity;<br>        <span class="hljs-keyword">return</span> vec[rear];<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> front == back;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isFull</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> front == (back + <span class="hljs-number">1</span>) % capcity;<br>    &#125;<br><br>    <span class="hljs-comment">// size = (back - front + capacity) % capacity;</span><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="使用链表模拟"><a href="#使用链表模拟" class="headerlink" title="使用链表模拟"></a>使用链表模拟</h2><p>用链表实现队列则较为简单，因为链表可以在 O(1)时间复杂度完成插入与删除。入队列时，将新的元素插入到链表的尾部；出队列时，将链表的头节点返回，并将头节点指向下一个节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCircularQueue</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    ListNode *head;<br>    ListNode *tail;<br>    <span class="hljs-type">int</span> capacity;<br>    <span class="hljs-type">int</span> size;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyCircularQueue</span>(<span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;capacity = k;<br>        <span class="hljs-keyword">this</span>-&gt;size = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">this</span>-&gt;head = <span class="hljs-keyword">this</span>-&gt;tail = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">enQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isFull</span>()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        ListNode *node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(value);<br>        <span class="hljs-keyword">if</span> (!head) &#123;<br>            head = tail = node;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            tail-&gt;next = node;<br>            tail = node;<br>        &#125;<br>        size++;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">deQueue</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isEmpty</span>()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        ListNode *node = head;<br>        head = head-&gt;next;  <br>        size--;<br>        <span class="hljs-keyword">delete</span> node;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Front</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isEmpty</span>()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head-&gt;val;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Rear</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isEmpty</span>()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> tail-&gt;val;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> size == <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isFull</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> size == capacity;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>笔者最开始使用链表是一次性在构造函数中申请k个节点的空间，结束时再析构函数释放资源，这样就不用动态申请了，但发现速度要慢一些，并且代码更复杂，如下：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    Node* next;<br>    <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> _val) : <span class="hljs-built_in">val</span>(_val), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>    <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> _val, Node* _next) : <span class="hljs-built_in">val</span>(_val), <span class="hljs-built_in">next</span>(_next) &#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCircularQueue</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    Node* dummyHead;<br>    <span class="hljs-type">int</span> size;<br>    <span class="hljs-type">int</span> capcity;<br>    Node* lastNode;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyCircularQueue</span>(<span class="hljs-type">int</span> k) &#123;<br>        capcity = k;<br>        size = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 虚拟头节点</span><br>        dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-number">-1</span>);<br>        <span class="hljs-comment">// 一次性申请k个节点的空间</span><br>        Node* cur = dummyHead;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; capcity; ++i) &#123;<br>            Node* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-number">-1</span>);<br>            cur-&gt;next = node;<br>            cur = node;<br>        &#125;<br>        <span class="hljs-comment">// 最后一个有效数据的节点，相当于队尾元素</span><br>        lastNode = dummyHead;<br>    &#125;<br><br>    ~<span class="hljs-built_in">MyCircularQueue</span>() &#123;<br>        Node* cur = dummyHead;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; capcity + <span class="hljs-number">1</span>; ++i) &#123;<br>            Node* tmp = cur;<br>            cur = cur-&gt;next;<br>            <span class="hljs-keyword">delete</span> tmp;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">enQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isFull</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <br>        <span class="hljs-comment">// 保证尾节点不为空且空闲；</span><br>        <span class="hljs-comment">// 队尾后移，然后辅助队尾元素，相当于从队尾插入</span><br>        lastNode = lastNode-&gt;next;<br>        lastNode-&gt;val = value;<br>        <br>        ++size;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">deQueue</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isEmpty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 只有一个有效元素时要单独处理</span><br>        <span class="hljs-keyword">if</span> (size == <span class="hljs-number">1</span>) &#123;<br>            lastNode-&gt;val = <span class="hljs-number">-1</span>;<br>            lastNode = dummyHead;<br>            --size;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-comment">// 队头元素就是要删除的元素</span><br>        Node* toBeDel = dummyHead-&gt;next;<br>        toBeDel-&gt;val = <span class="hljs-number">-1</span>;<br>        <span class="hljs-comment">// 更新队头元素</span><br>        dummyHead-&gt;next = toBeDel-&gt;next;<br>        <span class="hljs-comment">// 空闲节点的开头处</span><br>        Node* freeBegin = lastNode-&gt;next;<br>        <span class="hljs-comment">// 将队头元素移动到队尾后面，就是改变指针指向</span><br>        lastNode-&gt;next = toBeDel;<br>        toBeDel-&gt;next = freeBegin;<br>        <br>        --size;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Front</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isEmpty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> dummyHead-&gt;next-&gt;val;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Rear</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isEmpty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> lastNode-&gt;val;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> size == <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isFull</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> size == capcity;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>【参考资料】<a href="https://leetcode.cn/problems/design-circular-queue/">力扣题解</a>、百度百科</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
      <tag>循环队列</tag>
      
      <tag>数组</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ACM输入模式</title>
    <link href="/2022/08/02/ACM%E8%BE%93%E5%85%A5%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/08/02/ACM%E8%BE%93%E5%85%A5%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><ul><li>包含所有C++头文件的方式；</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br></code></pre></td></tr></table></figure><ul><li>cin读取的每个数据以空格和回车分隔；</li><li>cin &gt;&gt; var会自动将输入流中数据转换为var类型；</li><li>cin&gt;&gt;输入的数据不包含空格和回车，空格和回车会存入到cin的缓冲区中；</li><li><strong>cin是丢弃回车的，</strong>如果想拿到输入的空格和回车，通过cin.get()获得；</li><li>cin.get()不是当前cin的内容，而是<strong>下一个</strong>内容；</li><li>cin.get()是保留回车在输入流队列中的，可以读取每个字符，包括空格和回车；</li><li>使用while(cin &gt;&gt; var)读取时，在while循环中，cin只有在遇到文件结束符EOF，或无效输入时退出；</li></ul><h2 id="模板一"><a href="#模板一" class="headerlink" title="模板一"></a>模板一</h2><p><strong>不提示输入组数，根据回车符判断一组数据</strong>；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">long</span> sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">input</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">long</span> a = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (cin &gt;&gt; a) &#123;<br>            sum += a;<br>            <span class="hljs-keyword">if</span> (cin.<span class="hljs-built_in">get</span>() == <span class="hljs-string">&#x27;\n&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">output</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; sum &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-built_in">input</span>()) &#123;<br>            <span class="hljs-built_in">output</span>();<br>            sum = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> ptr = <span class="hljs-built_in">make_unique</span>&lt;Solution&gt;();<br>    ptr-&gt;<span class="hljs-built_in">run</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="模板二"><a href="#模板二" class="headerlink" title="模板二"></a>模板二</h2><p><strong>读取单个字符要用cin.get();</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;string&gt; vs;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">input</span><span class="hljs-params">()</span> </span>&#123;<br>        string s;<br>        <span class="hljs-type">char</span> ch;<br>        <span class="hljs-comment">// 读取字符用cin.get(ch), 不能是cin &gt;&gt; ch</span><br>        <span class="hljs-keyword">while</span> (cin.<span class="hljs-built_in">get</span>(ch)) &#123;<br>            <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;,&#x27;</span> || ch == <span class="hljs-string">&#x27;\n&#x27;</span>) &#123;<br>                vs.<span class="hljs-built_in">push_back</span>(s);<br>                s.<span class="hljs-built_in">clear</span>();<br>                <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;\n&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                s += ch;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">output</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; vs[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; vs.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; vs[i];<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-built_in">input</span>()) &#123;<br>            <span class="hljs-built_in">sort</span>(vs.<span class="hljs-built_in">begin</span>(), vs.<span class="hljs-built_in">end</span>());<br>            <span class="hljs-built_in">output</span>();<br>            vs.<span class="hljs-built_in">clear</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> ptr = <span class="hljs-built_in">make_unique</span>&lt;Solution&gt;();<br>    ptr-&gt;<span class="hljs-built_in">run</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="模板三"><a href="#模板三" class="headerlink" title="模板三"></a>模板三</h2><p><strong>借助stringstream；</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">input</span><span class="hljs-params">()</span> </span>&#123;<br>    string line;<br>    <span class="hljs-comment">// 直接读取一行，包括换行符</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">getline</span>(cin, line)) &#123;<br>        <span class="hljs-function">stringstream <span class="hljs-title">ss</span><span class="hljs-params">(line)</span></span>;<br>        string str;<br>        <span class="hljs-keyword">while</span> (ss &gt;&gt; str) vs.<span class="hljs-built_in">push_back</span>(str);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="模板四"><a href="#模板四" class="headerlink" title="模板四"></a>模板四</h2><p><strong>借助getline分割</strong>；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">input</span><span class="hljs-params">()</span> </span>&#123;<br>    string line;<br>    <span class="hljs-comment">// 直接读取一行，包括换行符</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">getline</span>(cin, line)) &#123;<br>        <span class="hljs-function">stringstream <span class="hljs-title">ss</span><span class="hljs-params">(line)</span></span>;<br>        string str;<br>        <span class="hljs-comment">// 从逗号分割</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-built_in">getline</span>(ss, str, <span class="hljs-string">&#x27;,&#x27;</span>)) vs.<span class="hljs-built_in">push_back</span>(str);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
      <tag>总结</tag>
      
      <tag>ACM输入模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法总结</title>
    <link href="/2022/07/31/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <url>/2022/07/31/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="一些知识"><a href="#一些知识" class="headerlink" title="一些知识"></a>一些知识</h2><ul><li>稳定排序：如果 a 原本在 b 的前面，且 a &#x3D;&#x3D; b，排序之后 a 仍然在 b 的前面，则为稳定排序。</li><li>非稳定排序：如果 a 原本在 b 的前面，且 a &#x3D;&#x3D; b，排序之后 a 可能不在 b 的前面，则为非稳定排序。</li><li>原地排序：指在排序过程中不申请多余的存储空间，只利用原来存储待排数据的存储空间进行比较和交换。</li><li>非原地排序：需要利用额外的数组来辅助排序。</li><li>使用计数、基数排序算法对负数排序时，可以先预处理让其变为正数，排序完毕后再复原，比如统一加减；</li></ul><blockquote><p>常见稳定排序有：<strong>冒泡排序、插入排序、归并排序</strong></p><p>常见非稳定排序有：<strong>选择排序、希尔排序、堆排序、快速排序</strong></p></blockquote><h2 id="十大排序"><a href="#十大排序" class="headerlink" title="十大排序"></a>十大排序</h2><h3 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h3><p>冒泡排序就是比较相邻的两个元素，把小的元素往前调(把大的元素往后调)，每次循环将最大的元素移动到后面；</p><p>步骤：对每一对相邻元素，如果第一个比第二个大，就交换他们两个；</p><blockquote><p>时间O(n^2)、空间O(1)、稳定</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-type">int</span> len = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-comment">// 只需len - 1次循环</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; ++i) &#123;<br>        <span class="hljs-comment">// 标记，避免无效循环</span><br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 界限是len - 1 - i</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; len - <span class="hljs-number">1</span> - i; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (nums[j] &gt; nums[j + <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-built_in">swap</span>(nums[j], nums[j + <span class="hljs-number">1</span>]);<br>                flag = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!flag) <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2.选择排序"></a>2.选择排序</h3><p>选择排序是给每个位置选择剩余未排序元素中最小的元素，然后交换；</p><p>步骤：</p><ul><li>在未排序序列中找到最小(大)元素，存放到排序序列的起始位置；</li><li>从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾；</li><li>以此类推，直到所有元素均排序完毕；</li></ul><blockquote><p>时间O(n^2)、空间O(1)、不稳定</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">selectSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br><span class="hljs-type">int</span> len = nums.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;<br><span class="hljs-type">int</span> minIndex = i;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; len; ++j) &#123;<br><span class="hljs-keyword">if</span> (nums[j] &lt; nums[minIndex]) minIndex = j;<br>&#125;<br><span class="hljs-built_in">swap</span>(nums[i], nums[minIndex]);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3.插入排序"></a>3.插入排序</h3><p>插入排序是在一个已经有序的小序列的基础上，每次寻找合适的插入位置来插入一个元素。刚开始这个有序的小序列就是第一个元素，每次从有序序列的末尾倒序开始寻找插入位置。</p><p>步骤：</p><ol><li><p>从第一个元素开始，该元素可以认为已经被排序</p></li><li><p>取出下一个元素，在已经排序的元素序列中从后向前扫描</p></li><li><p>如果该元素（已排序）大于新元素，将该元素移到前一位置</p></li><li><p>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</p></li><li><p>将新元素插入到该位置后</p></li><li><p>重复步骤2~5</p></li></ol><blockquote><p>时间O(n^2)、空间O(1)、稳定</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertionSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; a)</span> </span>&#123; <br>    <span class="hljs-type">int</span> n = a.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (a[i] &lt; a[i - <span class="hljs-number">1</span>]) &#123;<br>            <span class="hljs-type">int</span> j = i - <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// 待排序的新元素</span><br>            <span class="hljs-type">int</span> x = a[i];<br><br>            <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; a[j]) &#123;<br>                <span class="hljs-comment">// 把大于新元素的元素后移</span><br>                a[j + <span class="hljs-number">1</span>] = a[j];<br>                --j;<br>            &#125;<br><span class="hljs-comment">// 此处x &gt;= a[j]</span><br>            a[j + <span class="hljs-number">1</span>] = x;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-快速排序"><a href="#4-快速排序" class="headerlink" title="4.快速排序"></a>4.<code>快速排序</code></h3><p>每次处理完后基准位置是有序的，然后递归处理左右区间；</p><p>步骤：</p><ol><li><p>选取第一个数为基准</p></li><li><p>将比基准小的数交换到前面，比基准大的数交换到后面</p></li><li><p>对左右区间<strong>递归</strong>重复第二步，直到各区间只有一个数</p></li></ol><blockquote><p>时间O(nlogn)、空间O(logn)、不稳定</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 左闭右闭</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>    <span class="hljs-comment">// 递归结束标志</span><br>    <span class="hljs-keyword">if</span> (left &gt;= right) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-type">int</span> first = left;      <span class="hljs-comment">// 低位下标</span><br>    <span class="hljs-type">int</span> last  = right;     <span class="hljs-comment">// 高位下标</span><br>    <span class="hljs-type">int</span> key   = a[first];  <span class="hljs-comment">// 设第一个为基准</span><br><br>    <span class="hljs-keyword">while</span> (first &lt; last) &#123;<br>        <span class="hljs-comment">// 从后往前走，将比第一个小的移到前面</span><br>        <span class="hljs-keyword">while</span> (first &lt; last &amp;&amp; a[last] &gt; key) --last;<br>        <span class="hljs-keyword">if</span> (first &lt; last) a[first++] = a[last];<br><br>        <span class="hljs-comment">//从前往后走， 将比第一个大的移到后面</span><br>        <span class="hljs-keyword">while</span> (first &lt; last &amp;&amp; a[first] &lt;= key) ++first;<br>        <span class="hljs-keyword">if</span> (first &lt; last) a[last--] = a[first];<br>    &#125;<br>    a[first] = key;<br>    <br>    <span class="hljs-comment">// 自顶向下</span><br>    <span class="hljs-built_in">quickSort</span>(a, left, first - <span class="hljs-number">1</span>);  <span class="hljs-comment">// 前半递归</span><br>    <span class="hljs-built_in">quickSort</span>(a, first + <span class="hljs-number">1</span>, right); <span class="hljs-comment">// 后半递归</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-希尔排序"><a href="#5-希尔排序" class="headerlink" title="5.希尔排序"></a>5.<code>希尔排序</code></h3><p>希尔排序是插入排序的一种变种。无论是插入排序还是冒泡排序，如果原数组的一个元素距离它正确的位置很远的话，则需要与相邻元素交换很多次才能到达正确的位置，这样是相对比较花时间了。希尔排序就是为了加快速度简单地改进了插入排序，<strong>交换不相邻的元素</strong>以对数组的局部进行排序。</p><p>希尔排序的思想是采用插入排序的方法，先让数组中任意<strong>间隔为 h</strong> 的元素有序，刚开始 h 的大小可以是 h &#x3D; n &#x2F; 2,接着让 h &#x3D; n &#x2F; 4，让 h 一直缩小，当 h &#x3D; 1 时，也就是此时数组中任意间隔为1的元素有序，此时的数组就是有序的了。间隔也称作增量。</p><blockquote><p>时间O(nlogn)、空间O(1)、不稳定</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shellSortCore</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> gap, <span class="hljs-type">int</span> i)</span> </span>&#123;<br>    <span class="hljs-type">int</span> inserted = nums[i];<br>    <span class="hljs-comment">//  插入的时候按间隔gap进行插入</span><br>    <span class="hljs-type">int</span> j = i - gap;<br>    <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; inserted &lt; nums[j]) &#123;<br>        nums[j + gap] = nums[j];<br>        j -= gap;<br>    &#125;<br>    nums[j + gap] = inserted;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shellSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-type">int</span> len = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-comment">//进行分组，最开始的时候，gap为数组长度一半</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> gap = len / <span class="hljs-number">2</span>; gap &gt; <span class="hljs-number">0</span>; gap /= <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-comment">//对各个分组进行插入分组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = gap; i &lt; len; ++i) &#123;<br>            <span class="hljs-comment">//将nums[i]插入到所在分组正确的位置上</span><br>            <span class="hljs-built_in">shellSortCore</span>(nums, gap, i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-归并排序"><a href="#6-归并排序" class="headerlink" title="6.归并排序"></a>6.<code>归并排序</code></h3><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。适用于处理较大规模的数据，但比较耗内存。</p><p>归并排序有自顶向下的递归方法，和自底向上的迭代方法；</p><p>即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为<strong>2-路归并</strong>。</p><ul><li><p>对于分治，只需不断地分，直到只有一个元素的时候（一个元素认为它有序）；</p></li><li><p>对于合并，只要不断地取出两个有序数组中比较小的那一个放在一个辅助数组中（通过比较），直到把两个有序数组中的元素取完；</p></li></ul><p>步骤：</p><ul><li>把长度为n的输入序列分成两个长度为n&#x2F;2的子序列；</li><li>对这两个子序列分别采用归并排序；</li><li>将两个排序好的子序列合并成一个最终的排序序列；</li></ul><blockquote><p>时间O(nlogn)、空间O(n)、稳定</p></blockquote><p>①递归，辅助数组传引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 左闭右闭</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergeSortCore</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, vector&lt;<span class="hljs-type">int</span>&gt;&amp; temp, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (left &gt;= right) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-type">int</span> mid    = left + (right - left) / <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> start1 = left, end1 = mid;<br>    <span class="hljs-type">int</span> start2 = mid + <span class="hljs-number">1</span>, end2 = right;<br>    <span class="hljs-comment">// 分治</span><br>    <span class="hljs-built_in">mergeSortCore</span>(nums, temp, start1, end1);<br>    <span class="hljs-built_in">mergeSortCore</span>(nums, temp, start2, end2);<br><br>    <span class="hljs-comment">// 合并到辅助数组中</span><br>    <span class="hljs-type">int</span> index = left;<br>    <span class="hljs-keyword">while</span> (start1 &lt;= end1 &amp;&amp; start2 &lt;= end2) &#123;<br>        temp[index++] = nums[start1] &lt; nums[start2] ? nums[start1++] : nums[start2++];<br>    &#125;<br>    <span class="hljs-keyword">while</span> (start1 &lt;= end1) temp[index++] = nums[start1++];<br>    <span class="hljs-keyword">while</span> (start2 &lt;= end2) temp[index++] = nums[start2++];<br><br>    <span class="hljs-comment">// 从辅助数组取回排序好的元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = left; i &lt;= right; ++i) nums[i] = temp[i];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-comment">// 辅助数组, 存储排序好的数据</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">temp</span><span class="hljs-params">(nums.size(), <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-built_in">mergeSortCore</span>(nums, temp, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>②递归，开销更大</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergeTwoVec</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>    <span class="hljs-type">int</span> start1 = left, end1 = mid;<br>    <span class="hljs-type">int</span> start2 = mid + <span class="hljs-number">1</span>, end2 = right;<br><br>    <span class="hljs-comment">// 辅助数组, 存储排序好的数据</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">temp</span><span class="hljs-params">(right - left + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br><br>    <span class="hljs-comment">// 合并到辅助数组中</span><br>    <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (start1 &lt;= end1 &amp;&amp; start2 &lt;= end2) &#123;<br>        temp[index++] = nums[start1] &lt; nums[start2] ? nums[start1++] : nums[start2++];<br>    &#125;<br>    <span class="hljs-keyword">while</span> (start1 &lt;= end1) temp[index++] = nums[start1++];<br>    <span class="hljs-keyword">while</span> (start2 &lt;= end2) temp[index++] = nums[start2++];<br><br>    <span class="hljs-comment">// 从辅助数组取回排序好的元素</span><br>    index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = left; i &lt;= right; ++i) nums[i] = temp[index++];<br>&#125;<br><br><span class="hljs-comment">// 左闭右闭</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (left &gt;= right) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">// 分治</span><br>    <span class="hljs-built_in">mergeSort</span>(nums, left, mid);<br>    <span class="hljs-built_in">mergeSort</span>(nums, mid + <span class="hljs-number">1</span>, right);<br>    <span class="hljs-comment">// 合并</span><br>    <span class="hljs-built_in">mergeTwoVec</span>(nums, left, mid, right);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-堆排序"><a href="#7-堆排序" class="headerlink" title="7.堆排序"></a>7.堆排序</h3><p>基于堆(大根堆、小根堆)的一种排序算法，每次从堆顶取出一个元素；</p><ul><li>堆是采用<code>vertor&lt;TimeNode&gt;</code>数组实现的，数组下标从0开始，对应堆顶节点；</li><li>对于数组中下标为<code>k</code>的某节点，其左子节点为<code>2*k + 1</code>，右子节点为<code>2*k + 2</code>，父节点为<code>(k - 1) / 2</code>；</li><li>插入节点时，插入到数组中的最后一个节点的后面，然后与该节点的父节点比较大小，如果插入的元素小于父节点元素，那么与父节点交换位置。重复上述步骤直到大于父节点元素或者到达堆顶。该过程叫做<strong>上浮</strong>，即插入时上浮；</li><li>移除节点时，将该节点与末尾节点交换，然后当前节点(之前的尾部节点)与子节点中的较小者比较，如果当前节点大于较小子节点，那么与较小子节点交换位置，重复上述步骤直到小于较小子节点或者到达倒数第二个节点为止。最后再删除末尾节点。该过程叫做<strong>下沉</strong>，即移除元素时下沉;</li><li>排序时无需插入节点上浮构建堆，而是将待排数组看着完全二叉树，不断下沉节点，从而变成大顶堆；</li></ul><p>步骤：</p><ul><li><p>从后往前遍历数据，让当前节点的父节点下沉来构建堆（大根堆）；</p></li><li><p>交换堆顶与堆最后一个元素；</p></li><li><p>堆大小(heapSize)减一；</p></li><li><p>调整堆，即新堆顶节点下沉；</p></li></ul><blockquote><p>时间O(nlogn)、空间O(1)、不稳定</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 维护大根堆，让值小的节点下沉</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heapSink</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> heapSize, <span class="hljs-type">int</span> i)</span> </span>&#123;<br>    <span class="hljs-type">int</span> maxIdx = i;<br>    <span class="hljs-type">int</span> left   = i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> right  = i * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>;<br><br>    <span class="hljs-keyword">if</span> (left &lt; heapSize &amp;&amp; nums[left] &gt; nums[maxIdx]) maxIdx = left;<br>    <span class="hljs-keyword">if</span> (right &lt; heapSize &amp;&amp; nums[right] &gt; nums[maxIdx]) maxIdx = right;<br><br>    <span class="hljs-keyword">if</span> (maxIdx != i) &#123;<br>        <span class="hljs-built_in">swap</span>(nums[maxIdx], nums[i]);<br>        <span class="hljs-built_in">heapSink</span>(nums, heapSize, maxIdx);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 建立大根堆，从树的倒数第二层的倒数第一个结点开始，让值小的节点下沉</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heapBuild</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-comment">// 最后一个节点的父节点的下标</span><br>    <span class="hljs-type">int</span> lastRoot = ((nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = lastRoot; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>        <span class="hljs-built_in">heapSink</span>(nums, nums.<span class="hljs-built_in">size</span>(), i);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 堆排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heapSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-built_in">heapBuild</span>(nums);<br><br>    <span class="hljs-type">int</span> heapSize = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">while</span> (heapSize &gt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 交换最后一个结点和根节点（最大值）</span><br>        <span class="hljs-built_in">swap</span>(nums[<span class="hljs-number">0</span>], nums[heapSize - <span class="hljs-number">1</span>]);<br>        <span class="hljs-comment">// 堆大小减一</span><br>        --heapSize;<br>        <span class="hljs-comment">// 对交换后的根节点继续进行调整</span><br>        <span class="hljs-built_in">heapSink</span>(nums, heapSize, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-计数排序"><a href="#8-计数排序" class="headerlink" title="8.计数排序"></a>8.计数排序</h3><p>统计小于等于某元素值的元素的个数count，然后将该元素就放在目标数组的索引i位(<code>i = count, i ≥ 0</code>)；</p><p>计数排序基于一个假设，待排序数列的所有数均为整数，且出现在[min, max]的大小区间中；max - min 过大则会引起较大的空间复杂度，一般是用来排序 0 到 100 之间的数字的最好的算法，但是它不适合按字母顺序排序人名。速度<strong>快于任何比较排序算法</strong>。</p><p>步骤：</p><ul><li>找出待排序的数组中最大和最小的元素；</li><li>统计数组中每个值为 i 的元素出现的次数，存入数组 Cnt 的第 i 项；</li><li>对所有的计数累加（从 Cnt 中的第一个元素开始，每一项和前一项相加）；</li><li>填充目标数组：将每个元素 i 放在新数组的第 Cnt[i] 项，每放一个元素就将 Cnt[i] 减去 1；</li></ul><blockquote><p>时间O(n+k)、空间O(k)、稳定 （k &#x3D; maxNum - minNum + 1）</p></blockquote><p><strong>①利用差值减小空间复杂度；</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 计数排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">countSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-comment">// 确保待排序容器非空</span><br>    <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-comment">// 找到数组中的最小和最大元素</span><br>    <span class="hljs-type">int</span> minNum = INT_MAX, maxNum = INT_MIN;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>        <span class="hljs-keyword">if</span> (num &lt; minNum) minNum = num;<br>        <span class="hljs-keyword">if</span> (num &gt; maxNum) maxNum = num;<br>    &#125;<br><br>    <span class="hljs-type">int</span> len = maxNum - minNum + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 计数容器 countVec</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vecCount</span><span class="hljs-params">(len, <span class="hljs-number">0</span>)</span></span>;<br><br>    <span class="hljs-comment">// 统计每个键值出现的次数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) ++vecCount[num - minNum];<br><br>    <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;<br>        <span class="hljs-keyword">while</span> (vecCount[i] != <span class="hljs-number">0</span>) &#123;<br>            nums[index++] = i + minNum;<br>            --vecCount[i];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>②普通计数排序</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 计数排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">countSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-comment">// 确保待排序容器非空</span><br>    <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-comment">// 辅助数组存储排序好的元素</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">temp</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br><br>    <span class="hljs-comment">// 使用 nums 的最大值 + 1 作为计数容器 countVec 的大小</span><br>    <span class="hljs-keyword">auto</span> it  = <span class="hljs-built_in">max_element</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-type">int</span>  len = *it + <span class="hljs-number">1</span>;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vecCount</span><span class="hljs-params">(len, <span class="hljs-number">0</span>)</span></span>;<br><br>    <span class="hljs-comment">// 统计每个键值出现的次数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) ++vecCount[num];<br><br>    <span class="hljs-comment">// 后面的键值出现的位置为前面所有键值出现的次数之和</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; len; ++i) vecCount[i] += vecCount[i - <span class="hljs-number">1</span>];<br><br>    <span class="hljs-comment">// 将键值放到目标位置,此处逆序是为了保持相同键值的稳定性</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>        <span class="hljs-type">int</span> num = nums[i];<br>        <span class="hljs-comment">// 表示小于等于num的元素有vecCount[num]个</span><br>        <span class="hljs-type">int</span> cnt = vecCount[num];<br>        <span class="hljs-comment">// 也就是包括num自己，所有需要减一</span><br>        <span class="hljs-type">int</span> idx   = cnt - <span class="hljs-number">1</span>;<br>        temp[idx] = num;<br>        --vecCount[num];<br>    &#125;<br>    <span class="hljs-built_in">swap</span>(nums, temp);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-桶排序"><a href="#9-桶排序" class="headerlink" title="9.桶排序"></a>9.桶排序</h3><p>将值为i的元素放入i号桶，最后依次把桶里的元素倒出来。大编号桶里的所有元素均大于小编号桶里的任意元素；</p><p>步骤：</p><ul><li>设置一个定量的数组当作桶；</li><li>寻访序列，并且把项目一个一个放到对应的桶中；</li><li>对每个不是空的桶子进行<strong>排序</strong>（使用其它排序算法）；</li><li>从非空桶里把取回排序好的元素；</li></ul><blockquote><p>时间O(n+k)、空间O(n+k)、稳定</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bucketSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-comment">// 获取数组的最小值和最大值</span><br>    <span class="hljs-type">int</span> minNum = INT_MAX, maxNum = INT_MIN;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>        <span class="hljs-keyword">if</span> (num &lt; minNum) minNum = num;<br>        <span class="hljs-keyword">if</span> (num &gt; maxNum) maxNum = num;<br>    &#125;<br><br>    <span class="hljs-type">int</span> bucketNum  = <span class="hljs-number">5</span>;                                  <span class="hljs-comment">// 桶数量</span><br>    <span class="hljs-type">int</span> bucketSize = (maxNum - minNum) / bucketNum + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 桶大小</span><br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">buckets</span>(bucketNum, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">0</span>));  <span class="hljs-comment">// 桶数组</span><br><br>    <span class="hljs-comment">// 从小至大分桶</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>        <span class="hljs-type">int</span> bucketIndex = (num - minNum) / bucketSize;<br>        buckets[bucketIndex].<span class="hljs-built_in">emplace_back</span>(num);<br>    &#125;<br>    <span class="hljs-comment">// 桶内排序</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; bucket : buckets) &#123;<br>        <span class="hljs-built_in">sort</span>(bucket.<span class="hljs-built_in">begin</span>(), bucket.<span class="hljs-built_in">end</span>());<br>    &#125;<br>    <span class="hljs-comment">// 从桶中依次取数</span><br>    <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; bucket : buckets) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : bucket) &#123;<br>            nums[index++] = num;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="10-基数排序"><a href="#10-基数排序" class="headerlink" title="10.基数排序"></a>10.基数排序</h3><p>一种多关键字的排序算法，对数组中所有数依次按由低到高的<strong>位数</strong>进行多次排序；</p><p>步骤：</p><ul><li>取得数组中的最大数，并取得位数；</li><li>arr为原始数组，从最低位开始取每个位组成radix数组；</li><li>对radix进行计数排序（利用计数排序适用于小范围数的特点）；</li></ul><blockquote><p>时间O(n x k)、空间O(n x k)、稳定</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 取出最大位数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getBitNum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-type">int</span> maxValue = INT_MIN;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>        <span class="hljs-keyword">if</span> (num &gt; maxValue) maxValue = num;<br>    &#125;<br><br>    <span class="hljs-type">int</span> bitCount = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (maxValue &gt;= <span class="hljs-number">10</span>) &#123;<br>        maxValue /= <span class="hljs-number">10</span>;<br>        ++bitCount;<br>    &#125;<br>    <span class="hljs-keyword">return</span> bitCount;<br>&#125;<br><br><span class="hljs-comment">// 计数排序的思想，不过记录的是数位上数字的出现次数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">radixSortCore</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> divisor)</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">countBit</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">0</span>)</span></span>;  <span class="hljs-comment">// 0~9 共10个</span><br>    <span class="hljs-comment">// 统计个、十、百、千...位上 0~9 数字的出现次数；</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>        <span class="hljs-comment">// 多余的位数算出来就是0</span><br>        <span class="hljs-type">int</span> x = (num / divisor) % <span class="hljs-number">10</span>;<br>        ++countBit[x];<br>    &#125;<br><br>    <span class="hljs-comment">// 这里不同于利用差值的计数排序，需要算前缀和</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">9</span>; ++i) countBit[i] += countBit[i - <span class="hljs-number">1</span>];<br><br>    <span class="hljs-comment">// 辅助数组存储排序好的元素</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">temp</span><span class="hljs-params">(nums.size(), <span class="hljs-number">0</span>)</span></span>;<br><br>    <span class="hljs-comment">// 需要倒叙保证稳定</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>        <span class="hljs-type">int</span> x = (nums[i] / divisor) % <span class="hljs-number">10</span>;<br>        <span class="hljs-comment">// 该元素前面有 cnt 个当前数位比它小的元素，包括其自己；</span><br>        <span class="hljs-type">int</span> cnt = countBit[x];<br>        temp[cnt - <span class="hljs-number">1</span>] = nums[i];<br>        --countBit[x];<br>    &#125;<br>    <span class="hljs-built_in">swap</span>(nums, temp);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">radixSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-type">int</span> maxBitLen = <span class="hljs-built_in">getBitNum</span>(nums);<br><br>    <span class="hljs-comment">// 基数排序，低位优先</span><br>    <span class="hljs-type">int</span> divisor = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; maxBitLen; ++i) &#123;<br>        <span class="hljs-built_in">radixSortCore</span>(nums, divisor);<br>        <span class="hljs-comment">// 不断提高位数</span><br>        divisor *= <span class="hljs-number">10</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>【参考资料】力扣题解、<a href="https://interviewguide.cn/notes/03-hunting_job/03-algorithm/01-basic-algorithm/02-%E5%BF%85%E5%A4%87%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80.html">阿秀笔记</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
      <tag>总结</tag>
      
      <tag>排序算法</tag>
      
      <tag>冒泡排序</tag>
      
      <tag>选择排序</tag>
      
      <tag>插入排序</tag>
      
      <tag>快速排序</tag>
      
      <tag>希尔排序</tag>
      
      <tag>归并排序</tag>
      
      <tag>堆排序</tag>
      
      <tag>计数排序</tag>
      
      <tag>桶排序</tag>
      
      <tag>基数排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组实现线段树</title>
    <link href="/2022/07/31/%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <url>/2022/07/31/%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<blockquote><p>常规线段树，数组实现！！！</p></blockquote><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><a href="https://leetcode.cn/problems/range-sum-query-mutable/">例题</a> 数组区间内最小值、最大值、总和等问题；</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26347529/1655712803057-59dbb709-632a-4c36-a6db-4189f15ed12f.png" alt="img"></p><ul><li>线段树 segmentTree 是一个二叉树，线段树可以用树也可以用数组（堆式存储）来实现。</li><li>线段树结构有点像堆，一般用<strong>数组</strong>来表示线段树的结构；</li><li>在<code>index = 0</code>的位置保存根节点，则左子节点是<code>2 * index + 1</code>,右子节点是<code>2 * index + 2</code>;</li><li>(若在<code>index = 1</code>的位置保存根节点，则左子节点是<code>2 * index</code>,右子节点是<code>2 * index + 1</code>)</li><li>线段树中每个节点都表示一个<strong>区间</strong>的信息，如数组 nums 在区间 [s, e] 的<strong>最小值</strong>、<strong>最大值</strong>或<strong>总和</strong>等信息。</li><li>以区间总和为例，根节点存储所有元素的和；</li><li><strong>原数组</strong>中的每一个元素都以<strong>叶子节点</strong>的形式存在于线段树中<strong>；</strong></li><li>主要有3个操作：<strong>建树、查询、更新</strong>；</li><li>线段树将此类问题的查询以及更新的时间复杂度都变成了O(logn)；</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>以区间总和为例！！！</p><ul><li>start、end、left、right表示nums中的下标；</li><li>[left, right]是检索区间；</li><li>[start, end]是当前区间；</li><li>node_idx表示线段树中的节点的下标；</li></ul><h3 id="建树"><a href="#建树" class="headerlink" title="建树"></a>建树</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumArray</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 原数组大小为n;</span><br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-comment">// 用数组表示线段树，规定根结点 0 保存区间 [0,n−1] 的总和</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; segmentTree;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//线段树大小不过4n，建树</span><br>    <span class="hljs-built_in">NumArray</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) : <span class="hljs-built_in">n</span>(nums.<span class="hljs-built_in">size</span>()), <span class="hljs-built_in">segmentTree</span>(<span class="hljs-number">4</span> * nums.<span class="hljs-built_in">size</span>()) &#123;<br>        <span class="hljs-built_in">build</span>(nums, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-comment">//更新</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-built_in">change</span>(index, val, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-comment">//查询</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumRange</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(left, right, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end, <span class="hljs-type">int</span> node_idx)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(start == end)&#123;<br>        segmentTree[node_idx] = nums[start];<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> mid = start + (end - start) / <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> left_node_idx = node_idx * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> right_node_idx = node_idx * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">build</span>(nums, start, mid, left_node_idx);<br>    <span class="hljs-built_in">build</span>(nums, mid + <span class="hljs-number">1</span>, end, right_node_idx);<br>    segmentTree[node_idx] = segmentTree[left_node_idx] + segmentTree[right_node_idx];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>根据区间范围从根节点递归地向树的两边查询；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end, <span class="hljs-type">int</span> node_idx)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(right &lt; start || left &gt; end)&#123;<span class="hljs-comment">//当 检索区间 在 当前区间 左边或右边时</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left &lt;= start &amp;&amp; end &lt;= right)&#123;<span class="hljs-comment">//当 检索区间 包括 当前区间 时</span><br>        <span class="hljs-keyword">return</span> segmentTree[node_idx];<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-type">int</span> mid = start + (end - start) / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> left_node_idx = node_idx * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> right_node_idx = node_idx * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">//mid在变，而检索区间不变，所以传参数时left、right不变，start、end在变</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(left, right, start, mid, left_node_idx) + <br>               <span class="hljs-built_in">query</span>(left, right, mid + <span class="hljs-number">1</span>, end, right_node_idx);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>从对应的叶子节点开始更新到根节点；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//index是给定数组的将改变元素的下标，val是对应值</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> val, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end, <span class="hljs-type">int</span> node_idx)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(start == end)&#123;<br>        segmentTree[node_idx] = val;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> mid = start + (end - start) / <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> left_node_idx = node_idx * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> right_node_idx = node_idx * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(index &lt;= mid)&#123;<br>        <span class="hljs-built_in">change</span>(index, val, start, mid, left_node_idx);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">change</span>(index, val, mid + <span class="hljs-number">1</span>, end, right_node_idx);<br>    &#125;<br>    segmentTree[node_idx] = segmentTree[left_node_idx] + segmentTree[right_node_idx];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
      <tag>线段树</tag>
      
      <tag>常规线段树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见字符串动规解法总结</title>
    <link href="/2022/07/31/%E5%B8%B8%E8%A7%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8A%A8%E8%A7%84%E8%A7%A3%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <url>/2022/07/31/%E5%B8%B8%E8%A7%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8A%A8%E8%A7%84%E8%A7%A3%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>根据<strong>连续</strong>还是<strong>非连续</strong>定义dp数组，也就是注意区分<strong>子序列</strong>或<strong>子串</strong>；</p></li><li><p>dp[i]含义有<strong>以nums[i]结尾的</strong>【j，i】区间，或【0，i】区间范围内；</p></li><li><p>遍历顺序根据递推公式确定，可能有：</p></li><li><ul><li>一维dp[i]一般是从前往后遍历；</li><li>二维dp[i][j]分情况：</li></ul></li><li><ul><li><ul><li>如果是一个字符串，例如回文串，从下往上遍历；</li><li>如果是两个字符串，一般是从上往下、从左往右遍历；</li></ul></li></ul></li><li><p>注意初始化；</p></li></ul><h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(string s1, string s2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = s1.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = s2.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        <span class="hljs-comment">// dp[i][j]表示 s1中0~i-1 与 s2中0~j-1 最长相同子序列的长度</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (s1[i - <span class="hljs-number">1</span>] == s2[j - <span class="hljs-number">1</span>]) &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][j]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="最长相同连续子数组"><a href="#最长相同连续子数组" class="headerlink" title="最长相同连续子数组"></a>最长相同连续子数组</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findLength</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = nums1.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = nums2.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        <span class="hljs-comment">// dp[i][j]表示 nums1中以i-1结尾的 与 nums2中以j-1结尾的 最长相同子数组的长度</span><br><br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (nums1[i - <span class="hljs-number">1</span>] == nums2[j - <span class="hljs-number">1</span>]) &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                &#125; <br>                ans = <span class="hljs-built_in">max</span>(ans, dp[i][j]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="不同子序列个数"><a href="#不同子序列个数" class="headerlink" title="不同子序列个数"></a>不同子序列个数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numDistinct</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = t.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (m &lt; n) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// 令A为s中以i-1为结尾的子串，B为t中以j-1为结尾的子串；</span><br>        <span class="hljs-comment">// dp[i][j] 表示A的子序列中B的个数</span><br>        vector&lt;vector&lt;<span class="hljs-type">uint64_t</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">uint64_t</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++j) dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= m; ++i) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// 递推公式中[j]其实对应t这个不变的串，只有某字符相等时用到[j-1]</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++j) &#123;<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>                <span class="hljs-keyword">if</span> (s[i - <span class="hljs-number">1</span>] == t[j - <span class="hljs-number">1</span>]) &#123;<br>                    dp[i][j] += dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(string word1, string word2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = word1.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = word2.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-comment">// 令A为s中以i-1为结尾的子串，B为t中以j-1为结尾的子串；</span><br>        <span class="hljs-comment">// dp[i][j] 表示使AB相同的最小操作步数</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++j) dp[<span class="hljs-number">0</span>][j] = j;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= m; ++i) dp[i][<span class="hljs-number">0</span>] = i;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (word1[i - <span class="hljs-number">1</span>] == word2[j - <span class="hljs-number">1</span>]) &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">//                  word1删        word2删        替换</span><br>                    dp[i][j] = <span class="hljs-number">1</span> + <span class="hljs-built_in">min</span>(&#123;dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
      <tag>动态规划</tag>
      
      <tag>总结</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>递归与贪心与动态规划</title>
    <link href="/2022/07/31/%E9%80%92%E5%BD%92%E4%B8%8E%E8%B4%AA%E5%BF%83%E4%B8%8E%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <url>/2022/07/31/%E9%80%92%E5%BD%92%E4%B8%8E%E8%B4%AA%E5%BF%83%E4%B8%8E%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><h3 id="递归三部曲"><a href="#递归三部曲" class="headerlink" title="递归三部曲"></a>递归三部曲</h3><ul><li><p><strong>确定递归函数的参数和返回值</strong>： 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数，并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</p></li><li><p><strong>确定终止条件</strong>： 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</p></li><li><p><strong>确定单层递归的逻辑</strong>：确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</p></li></ul><h3 id="一些小记"><a href="#一些小记" class="headerlink" title="一些小记"></a>一些小记</h3><ul><li>如果需要遍历整棵树，递归函数就不能有返回值；</li><li>如果需要遍历某一条固定路线，递归函数就一定要有返回值；</li><li>对于递归函数，如果让空节点（空指针）进入递归，就不加if，如果不让空节点进入递归，就加if限制一下， 终止条件也会相应的调整；</li><li>例如二叉树，需要返回节点时就需要用某个临时变量接住返回值，用于后序逻辑处理；</li><li>二叉树递归时，想着对它的左右子节点同样递归操作；</li><li>对于二叉树，可以使用前序（中左右），也可以使用后序遍历（左右中），使用前序求的就是<strong>深度</strong>，使用后序求的是<strong>高度</strong>；</li><li>自底向上是单层递归，时间复杂度为O(n) ；而自顶向下是双层递归，时间复杂度是O(n^2)；</li></ul><h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><p><strong>贪心的本质是选择每一阶段的局部最优，从而达到全局最优；</strong></p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划:"></a>动态规划:</h2><p>动态规划中<strong>每一个状态是由上一个状态推导出来</strong>的，贪心则没有状态推导，而是从局部直接选最优的。</p><h3 id="动规五步曲："><a href="#动规五步曲：" class="headerlink" title="动规五步曲："></a>动规五步曲：</h3><ol><li>确定dp数组（dp table）以及下标的含义；</li><li>确定递推公式；</li><li>dp数组如何初始化；</li><li>确定遍历顺序；</li><li>举例推导dp数组；</li></ol><ul><li>做动规的题目，写代码之前一定要把状态转移在dp数组的上具体情况模拟一遍，心中有数，确定最后推出的是想要的结果。</li><li>然后再写代码，如果代码没通过就打印dp数组，看看是不是和自己预先推导的哪里不一样。</li><li>如果打印出来和自己预先模拟推导是一样的，那么就是自己的递归公式、初始化或者遍历顺序有问题了。</li><li>如果和自己预先模拟推导的不一样，那么就是代码实现细节有问题。</li></ul><hr><p>【参考资料】<a href="https://programmercarl.com/">代码随想录</a>、力扣</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
      <tag>动态规划</tag>
      
      <tag>递归</tag>
      
      <tag>贪心算法</tag>
      
      <tag>概念</tag>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>背包问题</title>
    <link href="/2022/07/31/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <url>/2022/07/31/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><blockquote><p>一个商品如果可以重复多次放入是<strong>完全背包</strong>，而只能放入一次是<strong>01背包</strong></p></blockquote><h2 id="01背包："><a href="#01背包：" class="headerlink" title="01背包："></a>01背包：</h2><p>问题描述：有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。</p><h3 id="一维dp"><a href="#一维dp" class="headerlink" title="一维dp"></a>一维dp</h3><ol><li>确定dp数组以及下标的含义：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">p[j] 表示容量为j的背包的价值总和最大是多少<br></code></pre></td></tr></table></figure><ol start="2"><li>确定递推公式：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);<br></code></pre></td></tr></table></figure><ol start="3"><li>初始化dp数组：</li></ol><ul><li>dp[0]就应该是0，因为背包容量为0所背的物品的最大价值就是0；</li><li>如果题目给的价值都是正整数那么非0下标都初始化为0；</li><li><strong>01背包的dp数组初始化为0</strong>;</li></ul><ol start="4"><li>确定遍历顺序：</li></ol><ul><li>二维dp遍历的时候，背包容量是从小到大，而<strong>一维dp遍历的时候，背包是从大到小</strong>；</li><li>倒序遍历是为了保证物品i只被放入一次；</li><li><strong>先遍历物品再遍历背包容量</strong>是保证每个容量可放入多个物品；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = bagWeight; j &gt;= weight[i]; j--) &#123; <span class="hljs-comment">// 遍历背包容量, j必须&gt;=weight[i];</span><br>        dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="5"><li>举例推导···</li></ol><h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><p>问题描述：</p><p>完全背包和01背包问题唯一不同的地方就是，每种物品有无限件。</p><ul><li><p>01背包和完全背包唯一不同就是体现在<strong>遍历顺序</strong>上;</p></li><li><p>01背包中一维dp数组的两个for循环先后循序一定是先遍历物品，再遍历背包容量；</p></li><li><p>完全背包物品和背包的先后遍历顺序都可以，区别是求组合还是排列数；</p></li><li><p>01背包内嵌(背包容量)的循环是从大到小遍历，为了保证每个物品仅被添加一次；</p></li><li><p>而完全背包的物品是可以添加多次的，所以完全背包的内嵌遍历顺序要<strong>从小到大</strong>去遍历；</p></li><li><p>如果求<strong>组合数</strong>就是外层for循环遍历物品，内层for遍历背包。</p></li><li><p>如果求<strong>排列数</strong>就是外层for遍历背包，内层for循环遍历物品。</p></li></ul><h3 id="一维dp-1"><a href="#一维dp-1" class="headerlink" title="一维dp"></a>一维dp</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 先遍历物品，再遍历背包</span><br><span class="hljs-comment">// 组合</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = weight[i]; j &lt;= bagWeight ; j++) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>        dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 先遍历背包，再遍历物品</span><br><span class="hljs-comment">// 排列</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= amount; j++) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; coins.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>        <span class="hljs-keyword">if</span> (j - coins[i] &gt;= <span class="hljs-number">0</span>) dp[j] += dp[j - coins[i]];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>问能否能装满背包（或者最多装多少）：dp[j] &#x3D; max(dp[j], dp[j - nums[i]] + nums[i]); </p></li><li><p>问装满背包有几种方法：dp[j] +&#x3D; dp[j - nums[i]]；(初始化dp[0] &#x3D; 1)</p></li><li><p>问背包装满最大价值：dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + value[i]); </p></li><li><p>问装满背包所有物品的最小个数：dp[j] &#x3D; min(dp[j - coins[i]] + 1, dp[j]);</p></li></ul><hr><p>【参考资料】<a href="https://programmercarl.com/">代码随想录</a>、力扣</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
      <tag>背包问题</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回溯算法</title>
    <link href="/2022/07/31/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    <url>/2022/07/31/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>可解决的问题</p><ul><li>组合问题：N个数里面按一定规则找出k个数的集合</li><li>切割问题：一个字符串按一定规则有几种切割方式</li><li>排列问题：N个数按一定规则全排列，有几种排列方式</li><li>棋盘问题：N皇后，数独等等</li></ul><h2 id="总结模板"><a href="#总结模板" class="headerlink" title="总结模板"></a>总结模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(参数)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (终止条件) &#123;<br>        存放结果;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;<br>        处理节点;<br>        <span class="hljs-built_in">backtracking</span>(路径，选择列表); <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>回溯法抽象为树形结构后，其遍历过程就是：for循环横向遍历，递归纵向遍历，回溯不断调整结果集。</li><li>一般需要两个全局变量，或者放在函数形参里面；</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result; <span class="hljs-comment">// 存放符合条件结果的集合</span><br>vector&lt;<span class="hljs-type">int</span>&gt; path; <span class="hljs-comment">// 用来存放符合条件结果</span><br></code></pre></td></tr></table></figure><ul><li><p>还有一个可选的位于回溯函数形参的int型<code>startIndex</code>变量，用来记录本层递归中，集合从哪里开始遍历；</p></li><li><p>组合问题，startIndex用在循环中<code>for (int i = startIndex; i &lt; n; i++)</code>;</p></li><li><p>排列问题，不用startIndex，是&#96;for (int i &#x3D; 0; i &lt; n; i++);</p></li><li><p>不重复选取某一元素<code>backTrack(candidates, target, i);</code></p></li><li><p>重复选取某一元素<code>backTrack(candidates, target, i + 1);</code></p></li><li><p>结果集去重，注意先<strong>排序</strong>；</p></li><li><ul><li>组合问题可以使用下标去重：<code>if (i &gt; startIdx &amp;&amp; nums[i] == nums[i - 1]) continue;</code></li><li>排列问题去重使用bool数组，注意树枝和树层去重，最好画N叉树图看，更直观；</li><li>也还可以使用set集合去重；</li></ul></li><li><p>字符串分割时要有判断条件<code>if (isValid(s, startIndex, i));</code></p></li></ul><h2 id="组合问题"><a href="#组合问题" class="headerlink" title="组合问题"></a>组合问题</h2><h3 id="一个集合"><a href="#一个集合" class="headerlink" title="一个集合"></a>一个集合</h3><ul><li>需要startIndex；</li><li>递归传参时<code>i+1</code>表示不能重复使用元素；</li><li>递归传参时<code>i</code>表示可以重复使用元素；</li></ul><h4 id="集合元素唯一"><a href="#集合元素唯一" class="headerlink" title="集合元素唯一"></a>集合元素唯一</h4><p>①如果是一个元素唯一的集合来求组合的话，就需要startIndex，并且递归时用<code>i+1</code>；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt;= n; i++) &#123; <span class="hljs-comment">// 控制树的横向遍历</span><br>    path.<span class="hljs-built_in">push_back</span>(i); <span class="hljs-comment">// 处理节点 </span><br>    <span class="hljs-built_in">backtracking</span>(n, k, i + <span class="hljs-number">1</span>); <span class="hljs-comment">// 递归：控制树的纵向遍历，注意下一层搜索要从i+1开始</span><br>    path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯，撤销处理的节点</span><br>&#125;<br></code></pre></td></tr></table></figure><p>②如果题目说明<strong>可以重复选取元素</strong>，则仍然用startIndex，但递归时不用<code>i+1</code>而是<code>i</code>；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; candidates.<span class="hljs-built_in">size</span>(); i++) &#123;<br>    sum += candidates[i];<br>    path.<span class="hljs-built_in">push_back</span>(candidates[i]);<br>    <span class="hljs-comment">// 关键点:不用i+1了，表示可以重复读取当前的数</span><br>    <span class="hljs-built_in">backtracking</span>(candidates, target, sum, i); <br>    sum -= candidates[i];   <span class="hljs-comment">// 回溯</span><br>    path.<span class="hljs-built_in">pop_back</span>();        <span class="hljs-comment">// 回溯</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="集合元素不唯一"><a href="#集合元素不唯一" class="headerlink" title="集合元素不唯一"></a>集合元素不唯一</h4><p>即组合<strong>去重</strong>问题，集合（数组）有重复元素，但还不能有重复的组合，一般要求集合即数组<strong>排序</strong>。仍然需要用到startIndex，并且加一个bool型数组used，用来记录同一树枝上的元素是否使用过。要去重的是同一树层上的“使用过”，同一树枝上的都是一个组合里的元素，不用去重。</p><p><strong>在candidates[i] &#x3D;&#x3D; candidates[i - 1]的情况下：</strong></p><ul><li><strong>used[i - 1] &#x3D;&#x3D; true，说明同一树枝candidates[i - 1]使用过</strong></li><li><strong>used[i - 1] &#x3D;&#x3D; false，说明同一树层candidates[i - 1]使用过</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; candidates.<span class="hljs-built_in">size</span>() &amp;&amp; sum + candidates[i] &lt;= target; i++) &#123;<br>    <span class="hljs-comment">// 要对同一树层使用过的元素进行跳过</span><br>    <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; candidates[i] == candidates[i - <span class="hljs-number">1</span>] &amp;&amp; used[i - <span class="hljs-number">1</span>] == <span class="hljs-literal">false</span>) &#123;<br>        <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-comment">// 要对同一树层使用过的元素进行跳过，使用startIndex去重，就可以不用used数组</span><br>    <span class="hljs-comment">//if (i &gt; startIndex &amp;&amp; candidates[i] == candidates[i - 1]) &#123;</span><br>    <span class="hljs-comment">//    continue;</span><br>    <span class="hljs-comment">//&#125;</span><br>    sum += candidates[i];<br>    path.<span class="hljs-built_in">push_back</span>(candidates[i]);<br>    used[i] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-built_in">backtracking</span>(candidates, target, sum, i + <span class="hljs-number">1</span>, used); <br>    used[i] = <span class="hljs-literal">false</span>;<br>    sum -= candidates[i];<br>    path.<span class="hljs-built_in">pop_back</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="多个集合"><a href="#多个集合" class="headerlink" title="多个集合"></a>多个集合</h3><p>如果是多个集合取组合，各个集合之间相互不影响，那么就不用startIndex，例如：17.电话号码的字母组合，本题增加index来表示深度，以判断递归结束条件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; letters.<span class="hljs-built_in">size</span>(); i++) &#123;<br>    s.<span class="hljs-built_in">push_back</span>(letters[i]);            <span class="hljs-comment">// 处理</span><br>    <span class="hljs-built_in">backtracking</span>(digits, index + <span class="hljs-number">1</span>);    <span class="hljs-comment">// 递归，注意index+1，下层要处理下一个数字了</span><br>    s.<span class="hljs-built_in">pop_back</span>();                       <span class="hljs-comment">// 回溯</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="排列问题"><a href="#排列问题" class="headerlink" title="排列问题"></a>排列问题</h2><h3 id="无重复元素的序列"><a href="#无重复元素的序列" class="headerlink" title="无重复元素的序列"></a>无重复元素的序列</h3><p>例：给定一个没有重复数字的序列，返回其所有可能的全排列。</p><p>输入: [1,2,3]</p><p>输出: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ]</p><p>思路：</p><ul><li>不用startIndex</li><li>需要一个used数组，标记已经选择的元素</li></ul><p>当收集元素的数组path的大小达到和nums数组一样大的时候，说明找到了一个全排列，也表示到达了叶子节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>    <span class="hljs-keyword">if</span> (used[i] == <span class="hljs-literal">true</span>) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// path里已经收录的元素，直接跳过</span><br>    used[i] = <span class="hljs-literal">true</span>;<br>    path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>    <span class="hljs-built_in">backtracking</span>(nums, used);<br>    path.<span class="hljs-built_in">pop_back</span>();<br>    used[i] = <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：</p><ul><li>每层都是从0开始搜索</li><li>需要used数组记录path里都放了哪些元素了</li></ul><h3 id="有重复元素的序列"><a href="#有重复元素的序列" class="headerlink" title="有重复元素的序列"></a>有重复元素的序列</h3><p>例：输入：nums &#x3D; [1,1,2]</p><p>输出： [[1,1,2], [1,2,1], [2,1,1]]</p><p>需要去重，去重一定要对元素进行排序，这样我们才方便通过相邻的节点来判断是否重复使用了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span> <span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; used)</span> </span>&#123;<br>    <span class="hljs-comment">// 此时说明找到了一组</span><br>    <span class="hljs-keyword">if</span> (path.<span class="hljs-built_in">size</span>() == nums.<span class="hljs-built_in">size</span>()) &#123;<br>        result.<span class="hljs-built_in">push_back</span>(path);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-comment">// used[i - 1] == true，说明同一树枝nums[i - 1]使用过</span><br>        <span class="hljs-comment">// used[i - 1] == false，说明同一树层nums[i - 1]使用过</span><br>        <span class="hljs-comment">// 如果同一树层nums[i - 1]使用过则直接跳过</span><br>        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &amp;&amp; used[i - <span class="hljs-number">1</span>] == <span class="hljs-literal">false</span>) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (used[i] == <span class="hljs-literal">true</span>) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">// path里已经收录的元素，直接跳过</span><br>        used[i] = <span class="hljs-literal">true</span>;<br>        path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>        <span class="hljs-built_in">backtracking</span>(nums, used);<br>        path.<span class="hljs-built_in">pop_back</span>();<br>        used[i] = <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于排列问题，树层上去重和树枝上去重，都是可以的，但是树层上去重效率更高！</p><h2 id="分割问题"><a href="#分割问题" class="headerlink" title="分割问题"></a>分割问题</h2><p>切割问题类似组合问题，<strong>需要startIndex</strong>；</p><p>对于分割回文串问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;string&gt;&gt; result;<br>vector&lt;string&gt; path; <span class="hljs-comment">// 放已经回文的子串</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span> <span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s, <span class="hljs-type">int</span> startIndex)</span> </span><br></code></pre></td></tr></table></figure><p>注意切割过的位置，不能重复切割，所以是backtracking(s, i + 1); 传入下一层的起始位置为i + 1。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isValid</span>(s, startIndex, i)) &#123;   <span class="hljs-comment">// 是回文子串</span><br>        <span class="hljs-comment">// 获取[startIndex,i]在s中的子串</span><br>        string str = s.<span class="hljs-built_in">substr</span>(startIndex, i - startIndex + <span class="hljs-number">1</span>);<br>        path.<span class="hljs-built_in">push_back</span>(str);<br>        <span class="hljs-built_in">backtracking</span>(s, i + <span class="hljs-number">1</span>); <span class="hljs-comment">// 寻找i+1为起始位置的子串</span><br>        path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯过程，弹出本次已经填在的子串</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;             <br>        <span class="hljs-keyword">continue</span>;<span class="hljs-comment">// 不是回文，跳过；有时是break，不合法，直接结束本层循环例如ip地址。</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="棋盘问题"><a href="#棋盘问题" class="headerlink" title="棋盘问题"></a>棋盘问题</h2><ul><li><p>写回溯算法的时候，一般函数返回值都是void；</p></li><li><p>但也有bool的时候，就是需要在树形结构中找到唯一的一条通向叶子节点的路线</p></li></ul><p>例一，N皇后</p><p>因为是每一行都放一个皇后，所以是一维递归；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// n 为输入的棋盘大小</span><br><span class="hljs-comment">// row 是当前递归到棋盘的第几行了</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> row, vector&lt;string&gt;&amp; chessboard)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (row == n) &#123;<br>        result.<span class="hljs-built_in">push_back</span>(chessboard);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> col = <span class="hljs-number">0</span>; col &lt; n; col++) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isValid</span>(row, col, chessboard, n)) &#123; <span class="hljs-comment">// 验证合法就可以放</span><br>            chessboard[row][col] = <span class="hljs-string">&#x27;Q&#x27;</span>; <span class="hljs-comment">// 放置皇后</span><br>            <span class="hljs-built_in">backtracking</span>(n, row + <span class="hljs-number">1</span>, chessboard);<br>            chessboard[row][col] = <span class="hljs-string">&#x27;.&#x27;</span>; <span class="hljs-comment">// 回溯，撤销皇后</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>例二，数独</p><p>二维递归！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; board.<span class="hljs-built_in">size</span>(); i++) &#123;        <span class="hljs-comment">// 遍历行</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); j++) &#123; <span class="hljs-comment">// 遍历列</span><br>            <span class="hljs-keyword">if</span> (board[i][j] != <span class="hljs-string">&#x27;.&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> k = <span class="hljs-string">&#x27;1&#x27;</span>; k &lt;= <span class="hljs-string">&#x27;9&#x27;</span>; k++) &#123;     <span class="hljs-comment">// (i, j) 这个位置放k是否合适</span><br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isValid</span>(i, j, k, board)) &#123;<br>                    board[i][j] = k;                <span class="hljs-comment">// 放置k</span><br>                    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">backtracking</span>(board)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 如果找到合适一组立刻返回</span><br>                    board[i][j] = <span class="hljs-string">&#x27;.&#x27;</span>;              <span class="hljs-comment">// 回溯，撤销k</span><br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;                <span class="hljs-comment">// 9个数都试完了，都不行，那么就返回false</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 遍历完没有返回false，说明找到了合适棋盘位置了</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><p>【参考资料】<a href="https://programmercarl.com/">代码随想录</a>、力扣</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>差分数组</title>
    <link href="/2022/07/31/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/"/>
    <url>/2022/07/31/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>差分数组是把原数组中后一个元素减前一个元素的差构成一个新的数组，作为辅助数组使用；</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26347529/1655727418850-32c596c1-f38c-4205-8e71-3595f973d00d.png" alt="img"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">diff[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>diff[<span class="hljs-number">1</span>] = nums[<span class="hljs-number">1</span>] - nums[<span class="hljs-number">0</span>];<br>diff[<span class="hljs-number">2</span>] = nums[<span class="hljs-number">2</span>] - nums[<span class="hljs-number">1</span>];<br>...<br><br>nums[<span class="hljs-number">0</span>] = diff[<span class="hljs-number">0</span>];<br>nums[<span class="hljs-number">1</span>] = diff[<span class="hljs-number">1</span>] + nums[<span class="hljs-number">0</span>] =  diff[<span class="hljs-number">0</span>] + diff[<span class="hljs-number">1</span>];<br>nums[<span class="hljs-number">2</span>] = nums[<span class="hljs-number">1</span>] + diff[<span class="hljs-number">2</span>] =  diff[<span class="hljs-number">0</span>] + diff[<span class="hljs-number">1</span>] + diff[<span class="hljs-number">2</span>];<br></code></pre></td></tr></table></figure><p>可知根据差分数组各项的前缀和，即可还原出原数组的各值，差分数组常用于对区间内元素值的统一修改。</p><p>比如想对[1, 3]范围的元素都加1时，只需用<code>diff[1] += 1``diff[4] -= 1</code>; </p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><a href="https://leetcode.cn/problems/my-calendar-iii/">预定日程</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>在每次book的时候:</p><ul><li>start处++,代表时间推进到start的时候,多了一个预定任务；</li><li>end处–,代表时间推进到end的时候预定任务减少一个;</li></ul><p>然后整体遍历一遍有序的map表，找到累计的最大预定次数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCalendarThree</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyCalendarThree</span>() &#123;<br><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">book</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> maxBook = <span class="hljs-number">0</span>;<br>        cnt[start]++;<br>        cnt[end]--;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;[_, freq] : cnt) &#123;<br>            <span class="hljs-comment">//根据差分数组还原原来数组的值，用于下面求最大值</span><br>            maxBook += freq;<br>            <span class="hljs-comment">//更新最大预定值；</span><br>            ans = <span class="hljs-built_in">max</span>(maxBook, ans);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">//构建差分数组</span><br>    map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; cnt;<span class="hljs-comment">//不能是umap</span><br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyCalendarThree object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyCalendarThree* obj = new MyCalendarThree();</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;book(start,end);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
      <tag>差分数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单调栈与单调队列</title>
    <link href="/2022/07/31/%E5%8D%95%E8%B0%83%E6%A0%88%E4%B8%8E%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    <url>/2022/07/31/%E5%8D%95%E8%B0%83%E6%A0%88%E4%B8%8E%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<blockquote><p>不管是单调栈还是单调队列，都有<strong>金字塔</strong>形状和<strong>倒金字塔</strong>形状，按照具体题意分析；</p></blockquote><h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><p>问题类型：</p><p>在数组里面找到下一个比当前元素大的元素数值或下标、接雨水等等；</p><ul><li>栈里面可以存下标或数值，建议存下标；</li><li>单调栈分为<strong>金字塔</strong>形状和<strong>倒金字塔</strong>形状；</li><li>按遍历方向不同，有不同的实现方式；</li></ul><h3 id="样式代码"><a href="#样式代码" class="headerlink" title="样式代码"></a>样式代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 从后往前遍历</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nextGreaterElementCore</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>    stack&lt;<span class="hljs-type">int</span>&gt; st;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; st.<span class="hljs-built_in">top</span>() &lt;= nums[i]) &#123;<br>            st.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        ans[i] = st.<span class="hljs-built_in">empty</span>() ? <span class="hljs-number">-1</span> : st.<span class="hljs-built_in">top</span>();<br>        st.<span class="hljs-built_in">push</span>(nums[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-comment">// 从前往后遍历</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dailyTemperatures</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; T)</span> </span>&#123;<br>    stack&lt;<span class="hljs-type">int</span>&gt; st; <span class="hljs-comment">// 递增栈</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(T.size(), <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; T.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; T[i] &gt; T[st.<span class="hljs-built_in">top</span>()]) &#123; <span class="hljs-comment">// 注意栈不能为空</span><br>            result[st.<span class="hljs-built_in">top</span>()] = i - st.<span class="hljs-built_in">top</span>();<br>            st.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        st.<span class="hljs-built_in">push</span>(i);<br><br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><br><span class="hljs-comment">// 遇到循环数组时</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> * n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>    <span class="hljs-type">int</span> curIndex = i % n;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h2><h3 id="样式代码-1"><a href="#样式代码-1" class="headerlink" title="样式代码"></a>样式代码</h3><ul><li>从front到back单调递减；</li><li>que.pop(滑动窗口中移除元素的数值)</li><li>que.push(滑动窗口添加元素的数值)</li><li>que.front()就返回我们要的最大值</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123; <span class="hljs-comment">//单调队列（从大到小）</span><br><span class="hljs-keyword">public</span>:<br>    deque&lt;<span class="hljs-type">int</span>&gt; que; <span class="hljs-comment">// 使用deque来实现单调队列</span><br>    <span class="hljs-comment">// 每次弹出的时候，比较当前要弹出的数值是否等于队列出口元素的数值，如果相等则弹出。</span><br>    <span class="hljs-comment">// 同时pop之前判断队列当前是否为空。</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!que.<span class="hljs-built_in">empty</span>() &amp;&amp; value == que.<span class="hljs-built_in">front</span>()) &#123;<br>            que.<span class="hljs-built_in">pop_front</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 如果push的数值大于入口元素的数值，那么就将队列后端的数值弹出，</span><br>    <span class="hljs-comment">// 直到push的数值小于等于队列入口元素的数值为止。</span><br>    <span class="hljs-comment">// 这样就保持了队列里的数值是单调从大到小的了。</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>() &amp;&amp; value &gt; que.<span class="hljs-built_in">back</span>()) &#123;<br>            que.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>        que.<span class="hljs-built_in">push_back</span>(value);<br>    &#125;<br>    <span class="hljs-comment">// 查询当前队列里的最大值 直接返回队列前端也就是front就可以了。</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">front</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> que.<span class="hljs-built_in">front</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>【参考资料】<a href="https://programmercarl.com/">代码随想录</a>、力扣</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
      <tag>单调栈</tag>
      
      <tag>单调队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跳表</title>
    <link href="/2022/07/31/%E8%B7%B3%E8%A1%A8/"/>
    <url>/2022/07/31/%E8%B7%B3%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul><li>跳表全称叫做跳跃表，简称跳表。</li><li>跳表是一个随机化的数据结构，实质就是一种可以进行<strong>二分查找</strong>的有序链表。</li><li>跳表不仅能提高搜索性能，同时也可以提高插入和删除操作的性能。</li><li>跳表可以被看做二叉树的一个变种，它在性能上和红黑树，AVL树不相上下，但是跳表的原理非常简单，目前在Redis中有用到。</li><li>跳表采用随机技术决定链表中哪些节点应增加<strong>向前指针</strong>以及在该节点中应增加多少个指针。跳表结构的头节点需有足够的指针域，以满足可能构造最大级数的需要，而尾节点不需要指针域。</li><li>跳表在原有的有序链表上面增加了多级索引，通过索引来实现快速查找。首先在最高级索引上查找<strong>最后一个小于</strong>当前查找元素的位置，然后再跳到次高级索引继续查找，直到跳到最底层为止，这时候已经十分接近要查找的元素的位置。</li><li>跳表中的搜索、插入、删除操作的时间均为O(logn)，然而，最坏情况下时间复杂性却变成O(n)。</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="跳表层数"><a href="#跳表层数" class="headerlink" title="跳表层数"></a>跳表层数</h3><p>由于跳表是多层链表结构，层数需要指定，即跳表的最大高度，取经验值<code>level = 8</code>;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> level = <span class="hljs-number">8</span>;  <span class="hljs-comment">// 层数，经验值 8</span><br></code></pre></td></tr></table></figure><h3 id="跳表节点"><a href="#跳表节点" class="headerlink" title="跳表节点"></a>跳表节点</h3><p>在跳表的每一层都由头节点引出一条链表，所以一个跳表节点需要：</p><ul><li>节点值；</li><li>next数组，存储该节点在每一层的next指针，没有就是空指针；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 定义跳表节点</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    <br>    <span class="hljs-comment">// 记录节点在每一层的 next，next[i] 表示当前节点第 i 层的 next</span><br>    vector&lt;Node*&gt; next;<br><br>    <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> _val) : <span class="hljs-built_in">val</span>(_val) &#123; next.<span class="hljs-built_in">resize</span>(level, <span class="hljs-literal">nullptr</span>); &#125;<br>&#125; *head;  <span class="hljs-comment">// 定义头节点 head</span><br></code></pre></td></tr></table></figure><h3 id="跳表结构"><a href="#跳表结构" class="headerlink" title="跳表结构"></a>跳表结构</h3><ul><li>一个跳表类中成员函数一般就是查找、插入、删除操作；</li><li>层索引是从最下层到最上层，0~level-1;</li><li>我们统一定义一个辅助的查询函数<code>find()</code>，用来找到<strong>每一层</strong>中<strong>小于目标值的最大的节点</strong>；</li><li>每一层的查找、插入、删除操作同于操作普通链表；</li><li>插入操作时<strong>从下往上遍历</strong>每一层，每一层有50%的概率插入新节点，第0层一定是含有所有节点；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Skiplist</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数创建头节点</span><br>    <span class="hljs-built_in">Skiplist</span>() &#123;<br>        head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 析构函数删除头节点</span><br>    ~<span class="hljs-built_in">Skiplist</span>() &#123;<br>        <span class="hljs-keyword">delete</span> head;<br>    &#125;<br><br>    <span class="hljs-comment">// 辅助函数：找到每一层(层索引i)中小于目标值 target 的最大节点 pre[i]</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> target, vector&lt;Node*&gt;&amp; pre)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> p = head;<br>        <span class="hljs-comment">// 从头节点开始遍历，从上层往下层找</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = level - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            <span class="hljs-keyword">while</span> (p-&gt;next[i] &amp;&amp; p-&gt;next[i]-&gt;val &lt; target) &#123;<br>                p = p-&gt;next[i];<br>            &#125;<br>            pre[i] = p;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 从跳表中查找 target</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-comment">// 先找到每一层 i 小于目标值 target 的最大节点 pre[i]</span><br>        <span class="hljs-function">vector&lt;Node*&gt; <span class="hljs-title">pre</span><span class="hljs-params">(level)</span></span>;<br>        <span class="hljs-built_in">find</span>(target, pre);<br><br>        <span class="hljs-keyword">auto</span> p = pre[<span class="hljs-number">0</span>]-&gt;next[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">return</span> p &amp;&amp; p-&gt;val == target;<br>    &#125;<br><br>    <span class="hljs-comment">// 向跳表中插入元素 num</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>        <span class="hljs-comment">// 先找到每一层 i 小于目标值 target 的最大节点 pre[i]</span><br>        <span class="hljs-function">vector&lt;Node*&gt; <span class="hljs-title">pre</span><span class="hljs-params">(level)</span></span>;<br>        <span class="hljs-built_in">find</span>(num, pre);<br><br>        <span class="hljs-keyword">auto</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(num); <br>        <span class="hljs-comment">// 从下往上遍历每一层，每一层是单链表的插入逻辑</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; level; i++) &#123;<br>            p-&gt;next[i] = pre[i]-&gt;next[i]; <br>            pre[i]-&gt;next[i] = p;<br>            <span class="hljs-comment">// 每一层有 50% 的概率不插入新节点</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">rand</span>() % <span class="hljs-number">2</span>) <span class="hljs-keyword">break</span>;  <br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 从跳表中删除 num</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">erase</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>        <span class="hljs-comment">// 先找到每一层 i 小于目标值 target 的最大节点 pre[i]</span><br>        <span class="hljs-function">vector&lt;Node*&gt; <span class="hljs-title">pre</span><span class="hljs-params">(level)</span></span>;<br>        <span class="hljs-built_in">find</span>(num, pre);<br><br>        <span class="hljs-comment">// 先判断 num 是否存在，不存在直接返回 false，只需在第0层判断</span><br>        <span class="hljs-keyword">auto</span> p = pre[<span class="hljs-number">0</span>]-&gt;next[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">if</span> (!p || p-&gt;val != num) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-comment">// 删除每一层的 num，如果 pre[i]-&gt;next[i] == p 说明第 i 层存在 p</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; level &amp;&amp; pre[i]-&gt;next[i] == p; ++i) &#123;<br>            pre[i]-&gt;next[i] = p-&gt;next[i];<br>        &#125;<br><br>        <span class="hljs-keyword">delete</span> p;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><hr><p>【参考资料】<a href="https://leetcode.cn/problems/design-skiplist/solution/by-tonngw-ls2k/">力扣题解-设计跳表</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
      <tag>跳表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>删除二叉树节点</title>
    <link href="/2022/07/25/%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%A0%91%E8%8A%82%E7%82%B9/"/>
    <url>/2022/07/25/%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%A0%91%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="普通二叉树"><a href="#普通二叉树" class="headerlink" title="普通二叉树"></a>普通二叉树</h2><p>删除普通二叉树的节点，用交换值的操作，使用有返回值的递归，可以通过返回值来移除节点；</p><p>代码中目标节点（要删除的节点）被操作了两次：</p><ul><li>第一次是和目标节点的右子树最左面节点交换。</li><li>第二次直接被nullptr覆盖了。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">deleteNode</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-keyword">if</span> (root-&gt;val == key) &#123;<br>            <span class="hljs-comment">// 这里第二次操作目标值：最终删除的作用</span><br>            <span class="hljs-keyword">if</span> (root-&gt;right == <span class="hljs-literal">nullptr</span>) &#123; <br>                <span class="hljs-keyword">return</span> root-&gt;left;<br>            &#125;<br>            TreeNode *cur = root-&gt;right;<br>            <span class="hljs-keyword">while</span> (cur-&gt;left) &#123;<br>                cur = cur-&gt;left;<br>            &#125;<br>            <span class="hljs-comment">// 这里第一次操作目标值：交换目标值其右子树最左面节点</span><br>            <span class="hljs-built_in">swap</span>(root-&gt;val, cur-&gt;val); <br>        &#125;<br>        root-&gt;left = <span class="hljs-built_in">deleteNode</span>(root-&gt;left, key);<br>        root-&gt;right = <span class="hljs-built_in">deleteNode</span>(root-&gt;right, key);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p>利用二叉搜索树特性，递归处理：</p><ul><li>第一种情况：没找到删除的节点，遍历到空节点直接返回了</li></ul><p>找到目标节点：</p><ul><li>第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回nullptr为根节点；</li><li>第三种情况：删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点；</li><li>第四种情况：删除节点的右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点；</li><li>第五种情况：左右孩子节点都不为空，则将删除节点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点；</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">deleteNode</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> root; <span class="hljs-comment">// 第一种情况：没找到删除的节点，遍历到空节点直接返回了</span><br>        <span class="hljs-keyword">if</span> (root-&gt;val == key) &#123;<br>            <span class="hljs-comment">// 第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点</span><br>            <span class="hljs-keyword">if</span> (root-&gt;left == <span class="hljs-literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="hljs-literal">nullptr</span>) &#123;<br>                <span class="hljs-comment">///! 内存释放</span><br>                <span class="hljs-keyword">delete</span> root;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>            &#125;<br>            <span class="hljs-comment">// 第三种情况：其左孩子为空，右孩子不为空，删除节点，右孩子补位 ，返回右孩子为根节点</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root-&gt;left == <span class="hljs-literal">nullptr</span>) &#123;<br>                <span class="hljs-keyword">auto</span> retNode = root-&gt;right;<br>                <span class="hljs-comment">///! 内存释放</span><br>                <span class="hljs-keyword">delete</span> root;<br>                <span class="hljs-keyword">return</span> retNode;<br>            &#125;<br>            <span class="hljs-comment">// 第四种情况：其右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root-&gt;right == <span class="hljs-literal">nullptr</span>) &#123;<br>                <span class="hljs-keyword">auto</span> retNode = root-&gt;left;<br>                <span class="hljs-comment">///! 内存释放</span><br>                <span class="hljs-keyword">delete</span> root;<br>                <span class="hljs-keyword">return</span> retNode;<br>            &#125;<br>            <span class="hljs-comment">// 第五种情况：左右孩子节点都不为空，则将删除节点的左子树放到删除节点的右子树的最左面节点的左孩子的位置</span><br>            <span class="hljs-comment">// 并返回删除节点右孩子为新的根节点。</span><br>            <span class="hljs-keyword">else</span> &#123;<br>                TreeNode* cur = root-&gt;right; <span class="hljs-comment">// 找右子树最左面的节点</span><br>                <span class="hljs-keyword">while</span>(cur-&gt;left != <span class="hljs-literal">nullptr</span>) &#123;<br>                    cur = cur-&gt;left;<br>                &#125;<br>                cur-&gt;left = root-&gt;left; <span class="hljs-comment">// 把要删除的节点（root）左子树放在cur的左孩子的位置</span><br>                TreeNode* tmp = root;   <span class="hljs-comment">// 把root节点保存一下，下面来删除</span><br>                root = root-&gt;right;     <span class="hljs-comment">// 返回旧root的右孩子作为新root</span><br>                <span class="hljs-keyword">delete</span> tmp;             <span class="hljs-comment">// 释放节点内存（这里不写也可以，但C++最好手动释放一下吧）</span><br>                <span class="hljs-keyword">return</span> root;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root-&gt;val &gt; key) root-&gt;left = <span class="hljs-built_in">deleteNode</span>(root-&gt;left, key);<br>        <span class="hljs-keyword">if</span> (root-&gt;val &lt; key) root-&gt;right = <span class="hljs-built_in">deleteNode</span>(root-&gt;right, key);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重建二叉树</title>
    <link href="/2022/07/25/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2022/07/25/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="重建普通二叉树"><a href="#重建普通二叉树" class="headerlink" title="重建普通二叉树"></a>重建普通二叉树</h2><ul><li>优化，借助下标索引，而不是vector；</li><li>不能从前序和后序重建；</li><li>左闭右开（或左闭右闭）就是循环不变量；</li></ul><h3 id="一、从中序和后序重建"><a href="#一、从中序和后序重建" class="headerlink" title="一、从中序和后序重建"></a>一、从中序和后序重建</h3><h4 id="①传vector"><a href="#①传vector" class="headerlink" title="①传vector"></a>①传vector</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder)</span> </span>&#123;<br>        <span class="hljs-comment">//保证输入合规、节点值唯一</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">build</span>(inorder, postorder);<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">build</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder)</span> </span>&#123;<br>        <span class="hljs-comment">//第一步：如果为空，返回</span><br>        <span class="hljs-type">int</span> n = postorder.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(!n) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br>        <span class="hljs-comment">//第二步：从后序最后一个得到根节点</span><br>        <span class="hljs-type">int</span> rootValue = postorder[n<span class="hljs-number">-1</span>];<br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(rootValue);<br><br>        <span class="hljs-comment">//叶子节点</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-number">1</span> == n) <span class="hljs-keyword">return</span> root;<br><br>        <span class="hljs-comment">//第三部：根据根节点切分中序，得到 中序左序列（左子树）、中序右序列（右子树）</span><br>        <span class="hljs-type">int</span> cutIndex1 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(; cutIndex1 &lt; n; ++cutIndex1)&#123;<br>            <span class="hljs-keyword">if</span>(inorder[cutIndex1] == rootValue)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 左闭右开区间：[0, cutIndex)</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderLeft</span><span class="hljs-params">(inorder.begin(), inorder.begin() + cutIndex1)</span></span>;<br>        <span class="hljs-comment">// [cutIndex + 1, end)</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderRight</span><span class="hljs-params">(inorder.begin() + cutIndex1 + <span class="hljs-number">1</span>, inorder.end())</span></span>;<br><br>        <span class="hljs-comment">//第四步：根据左右子树切分后序序列得到 后序左序列（左子树）、后序右序列（右子树）</span><br>        <span class="hljs-comment">// 先postorder舍弃末尾元素，因为这个元素就是中间根节点，已经用过了</span><br>        postorder.<span class="hljs-built_in">resize</span>(n - <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> cutIndex2 = inorderLeft.<span class="hljs-built_in">size</span>();<span class="hljs-comment">//使用了左中序数组大小作为切割点</span><br>        <span class="hljs-comment">// 左闭右开，[0, inorderLeft.size())</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderLeft</span><span class="hljs-params">(postorder.begin(), postorder.begin() + cutIndex2)</span></span>;<br>        <span class="hljs-comment">// [inorderLeft.size(), end)</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderRight</span><span class="hljs-params">(postorder.begin() + cutIndex2, postorder.end())</span></span>;<br><br>        <span class="hljs-comment">//第五步：递归处理左右区间</span><br>        root-&gt;left = <span class="hljs-built_in">build</span>(inorderLeft, postorderLeft);<br>        root-&gt;right = <span class="hljs-built_in">build</span>(inorderRight, postorderRight);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="②传index"><a href="#②传index" class="headerlink" title="②传index"></a>②传index</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = inorder.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">build</span>(inorder, postorder, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">build</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder, <span class="hljs-type">int</span> inStart, <span class="hljs-type">int</span> inEnd,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">int</span> postStart, <span class="hljs-type">int</span> postEnd)</span> </span>&#123;<br>        <span class="hljs-comment">// 左闭右开</span><br>        <span class="hljs-keyword">if</span> (inStart &gt; inEnd) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br>        <span class="hljs-type">int</span> rootValue = postorder[postEnd];<br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(rootValue);<br><br>        <span class="hljs-type">int</span> idx = inStart;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = inStart; i &lt;= inEnd; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (inorder[i] == rootValue) &#123;<br>                idx = i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span> leftInStart = inStart;<br>        <span class="hljs-type">int</span> leftInEnd = idx - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> leftPostStart = postStart;<br>        <span class="hljs-type">int</span> leftPostEnd = postStart + leftInEnd - leftInStart;<br>        <span class="hljs-comment">//printf(&quot;%d | %d %d %d %d\n&quot;, idx, leftInStart, leftInEnd, leftPostStart, leftPostEnd);</span><br>        TreeNode* left = <span class="hljs-built_in">build</span>(inorder, postorder, leftInStart, leftInEnd, leftPostStart, leftPostEnd);<br><br>        <span class="hljs-type">int</span> rightInStart = idx + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> rightInEnd = inEnd;<br>        <span class="hljs-type">int</span> rightPostStart = leftPostEnd + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> rightPostEnd = postEnd - <span class="hljs-number">1</span>;<br>        TreeNode* right = <span class="hljs-built_in">build</span>(inorder, postorder, rightInStart, rightInEnd, rightPostStart, rightPostEnd);<br><br>        root-&gt;left = left;<br>        root-&gt;right = right;<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="二、从中序和前序重建"><a href="#二、从中序和前序重建" class="headerlink" title="二、从中序和前序重建"></a>二、从中序和前序重建</h3><h4 id="①传vector-1"><a href="#①传vector-1" class="headerlink" title="①传vector"></a>①传vector</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">build</span>(preorder, inorder);<br>    &#125;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">build</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder)</span> </span>&#123;<br>        <span class="hljs-comment">//第一步：判断是否为空</span><br>        <span class="hljs-type">int</span> n = inorder.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(!n) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br>        <span class="hljs-comment">//第二步：从前序第一个找到根节点</span><br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(preorder[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> root;<br><br>        <span class="hljs-comment">//第三步：切分中序</span><br>        <span class="hljs-type">int</span> inorderCutIndex = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(; inorderCutIndex &lt; n; ++inorderCutIndex)&#123;<br>            <span class="hljs-keyword">if</span>(inorder[inorderCutIndex] == preorder[<span class="hljs-number">0</span>])&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderLeft</span><span class="hljs-params">(inorder.begin(), inorder.begin() + inorderCutIndex)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderRight</span><span class="hljs-params">(inorder.begin() + inorderCutIndex + <span class="hljs-number">1</span>, inorder.end())</span></span>;<br><br>        <span class="hljs-comment">//第四步：切分前序</span><br>        <span class="hljs-type">int</span> preorderCutIndex = inorderLeft.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>;<span class="hljs-comment">//加1是因为跳过第一个用过的根节点</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderLeft</span><span class="hljs-params">(preorder.begin() + <span class="hljs-number">1</span>, </span></span><br><span class="hljs-params"><span class="hljs-function">                                 preorder.begin() + preorderCutIndex)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderRight</span><span class="hljs-params">(preorder.begin() + preorderCutIndex, preorder.end())</span></span>;<br><br>        <span class="hljs-comment">//第五步：递归处理</span><br>        root-&gt;left = <span class="hljs-built_in">build</span>(preorderLeft, inorderLeft);<br>        root-&gt;right = <span class="hljs-built_in">build</span>(preorderRight, inorderRight);<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="②传index-1"><a href="#②传index-1" class="headerlink" title="②传index"></a>②传index</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">traversal</span> <span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, <span class="hljs-type">int</span> inorderBegin, <span class="hljs-type">int</span> inorderEnd, </span></span><br><span class="hljs-params"><span class="hljs-function">                         vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, <span class="hljs-type">int</span> preorderBegin, <span class="hljs-type">int</span> preorderEnd)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (preorderBegin == preorderEnd) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br>        <span class="hljs-type">int</span> rootValue = preorder[preorderBegin]; <span class="hljs-comment">// 注意用preorderBegin 不要用0</span><br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(rootValue);<br>        <span class="hljs-keyword">if</span> (preorderEnd - preorderBegin == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> root;<br><br>        <span class="hljs-comment">// 切割中序数组</span><br>        <span class="hljs-type">int</span> delimiterIndex = inorderBegin;<br>        <span class="hljs-keyword">for</span> (; delimiterIndex &lt; inorderEnd; delimiterIndex++) &#123;<br>            <span class="hljs-keyword">if</span> (inorder[delimiterIndex] == rootValue) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">// 中序左区间，左闭右开[leftInorderBegin, leftInorderEnd)</span><br>        <span class="hljs-type">int</span> leftInorderBegin = inorderBegin;<br>        <span class="hljs-type">int</span> leftInorderEnd = delimiterIndex;<br>        <span class="hljs-comment">// 中序右区间，左闭右开[rightInorderBegin, rightInorderEnd)</span><br>        <span class="hljs-type">int</span> rightInorderBegin = delimiterIndex + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> rightInorderEnd = inorderEnd;<br><br>        <span class="hljs-comment">// 切割前序数组，(delimiterIndex - inorderBegin)是中序左区间的大小</span><br>        <span class="hljs-comment">// 前序左区间，左闭右开[leftPreorderBegin, leftPreorderEnd)</span><br>        <span class="hljs-type">int</span> leftPreorderBegin =  preorderBegin + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> leftPreorderEnd = preorderBegin + <span class="hljs-number">1</span> + delimiterIndex - inorderBegin; <br>        <span class="hljs-comment">// 前序右区间, 左闭右开[rightPreorderBegin, rightPreorderEnd)</span><br>        <span class="hljs-type">int</span> rightPreorderBegin = preorderBegin + <span class="hljs-number">1</span> + delimiterIndex - inorderBegin;<br>        <span class="hljs-type">int</span> rightPreorderEnd = preorderEnd;<br><br>        root-&gt;left = <span class="hljs-built_in">traversal</span>(inorder, leftInorderBegin, leftInorderEnd, <br>                               preorder, leftPreorderBegin, leftPreorderEnd);<br>        root-&gt;right = <span class="hljs-built_in">traversal</span>(inorder, rightInorderBegin, rightInorderEnd,<br>                                preorder, rightPreorderBegin, rightPreorderEnd);<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder)</span> </span>&#123;<br>        <span class="hljs-comment">// 参数坚持左闭右开的原则</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">traversal</span>(inorder, <span class="hljs-number">0</span>, inorder.<span class="hljs-built_in">size</span>(), preorder, <span class="hljs-number">0</span>, preorder.<span class="hljs-built_in">size</span>());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="重建平衡二叉树"><a href="#重建平衡二叉树" class="headerlink" title="重建平衡二叉树"></a>重建平衡二叉树</h2><ul><li>从数组构造二叉树，构成平衡树是自然而然的事情；</li><li>寻找分割点，分割点作为当前节点，然后递归左区间和右区间；</li><li>分割点就是数组中间位置的节点；</li><li>从有序数组构建就是平衡二叉搜索树；</li><li>构造二叉树的时候尽量不要重新定义左右区间数组，而是用下标来操作原数组；</li><li>我们选择左闭右闭的区间作为循环不变量；</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">buildBST</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(left &gt; right) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>    TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(nums[mid]);<br>    root-&gt;left = <span class="hljs-built_in">buildBST</span>(nums, left, mid - <span class="hljs-number">1</span>);<br>    root-&gt;right = <span class="hljs-built_in">buildBST</span>(nums, mid + <span class="hljs-number">1</span>, right);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>遍历二叉树</title>
    <link href="/2022/07/25/%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2022/07/25/%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="深度优先遍历（栈）"><a href="#深度优先遍历（栈）" class="headerlink" title="深度优先遍历（栈）"></a>深度优先遍历（栈）</h2><p>保证入栈节点不是空节点！</p><h3 id="前序遍历（中左右）"><a href="#前序遍历（中左右）" class="headerlink" title="前序遍历（中左右）"></a>前序遍历（中左右）</h3><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(TreeNode* cur, vector&lt;<span class="hljs-type">int</span>&gt;&amp; res)</span></span>&#123;<br><span class="hljs-keyword">if</span>(cur == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>res.<span class="hljs-built_in">push_back</span>(cur-&gt;val); <span class="hljs-comment">//中</span><br><span class="hljs-built_in">visit</span>(cur-&gt;left, res);   <span class="hljs-comment">//左</span><br><span class="hljs-built_in">visit</span>(cur-&gt;right, res);  <span class="hljs-comment">//右</span><br>&#125;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; result;<br><span class="hljs-built_in">visit</span>(root, result);<br><span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>stack&lt;TreeNode*&gt; st;<br>vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    TreeNode* cur = root;<br><span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span> || !st.<span class="hljs-built_in">empty</span>())&#123;<br><span class="hljs-keyword">if</span>(cur != <span class="hljs-literal">nullptr</span>)&#123;<br>res.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<span class="hljs-comment">//**********该行变化**************</span><br>st.<span class="hljs-built_in">push</span>(cur);<br>cur = cur-&gt;left;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>cur = st.<span class="hljs-built_in">top</span>();<br>st.<span class="hljs-built_in">pop</span>();<br>cur = cur-&gt;right;<br>&#125;<br>&#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="中序遍历（左中右）"><a href="#中序遍历（左中右）" class="headerlink" title="中序遍历（左中右）"></a>中序遍历（左中右）</h3><h4 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(TreeNode* cur, vector&lt;<span class="hljs-type">int</span>&gt;&amp; res)</span></span>&#123;<br><span class="hljs-keyword">if</span>(cur == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">visit</span>(cur-&gt;left, res);   <span class="hljs-comment">//左</span><br>    res.<span class="hljs-built_in">push_back</span>(cur-&gt;val); <span class="hljs-comment">//中</span><br><span class="hljs-built_in">visit</span>(cur-&gt;right, res);  <span class="hljs-comment">//右</span><br>&#125;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; result;<br><span class="hljs-built_in">visit</span>(root, result);<br><span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="迭代-1"><a href="#迭代-1" class="headerlink" title="迭代"></a>迭代</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>stack&lt;TreeNode*&gt; st;<br>vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    TreeNode* cur = root;<br><span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span> || !st.<span class="hljs-built_in">empty</span>())&#123;<br><span class="hljs-keyword">if</span>(cur != <span class="hljs-literal">nullptr</span>)&#123;  <span class="hljs-comment">// 指针来访问节点，访问到最底层</span><br>st.<span class="hljs-built_in">push</span>(cur);    <span class="hljs-comment">// 将访问的节点放进栈</span><br>cur = cur-&gt;left; <br>&#125;<span class="hljs-keyword">else</span>&#123;<br>cur = st.<span class="hljs-built_in">top</span>();<br>st.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据）</span><br>            res.<span class="hljs-built_in">push_back</span>(cur-&gt;val); <span class="hljs-comment">//**********该行变化**************</span><br>cur = cur-&gt;right;        <br>&#125;<br>&#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="后序遍历（左右中）"><a href="#后序遍历（左右中）" class="headerlink" title="后序遍历（左右中）"></a>后序遍历（左右中）</h3><h4 id="递归-2"><a href="#递归-2" class="headerlink" title="递归"></a>递归</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(TreeNode* cur, vector&lt;<span class="hljs-type">int</span>&gt;&amp; res)</span></span>&#123;<br><span class="hljs-keyword">if</span>(cur == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-built_in">visit</span>(cur-&gt;left, res);   <span class="hljs-comment">//左</span><br><span class="hljs-built_in">visit</span>(cur-&gt;right, res);  <span class="hljs-comment">//右</span><br>    res.<span class="hljs-built_in">push_back</span>(cur-&gt;val); <span class="hljs-comment">//中</span><br>&#125;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; result;<br><span class="hljs-built_in">visit</span>(root, result);<br><span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="迭代-2"><a href="#迭代-2" class="headerlink" title="迭代"></a>迭代</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; res;<br>stack&lt;TreeNode*&gt; st;<br>TreeNode* cur = root;<br>TreeNode* prenode;<br><span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span> || !st.<span class="hljs-built_in">empty</span>())&#123;<br><span class="hljs-keyword">if</span>(cur != <span class="hljs-literal">nullptr</span>)&#123;<br>st.<span class="hljs-built_in">push</span>(cur);<br>cur = cur-&gt;left;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>cur = st.<span class="hljs-built_in">top</span>();<br>st.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">if</span>(cur-&gt;right == <span class="hljs-literal">nullptr</span> || cur-&gt;right == prenode)&#123;<span class="hljs-comment">//没有右结点或已经访问过</span><br>res.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>prenode = cur;<br>cur = <span class="hljs-literal">nullptr</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>st.<span class="hljs-built_in">push</span>(cur);<br>cur = cur-&gt;right;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br>或反转变化的前序（根右左）遍历<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">REVERpreorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>stack&lt;TreeNode*&gt; st;<br>vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    TreeNode* cur = root;<br><span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span> || !st.<span class="hljs-built_in">empty</span>())&#123;<br><span class="hljs-keyword">if</span>(cur != <span class="hljs-literal">nullptr</span>)&#123;<br>res.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>st.<span class="hljs-built_in">push</span>(cur);<br>cur = cur-&gt;right;<span class="hljs-comment">//**********该行变化**************</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br>cur = st.<span class="hljs-built_in">top</span>();<br>st.<span class="hljs-built_in">pop</span>();<br>cur = cur-&gt;left;<span class="hljs-comment">//**********该行变化**************</span><br>&#125;<br>&#125;<br>    <span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="广度优先遍历（队列）"><a href="#广度优先遍历（队列）" class="headerlink" title="广度优先遍历（队列）"></a>广度优先遍历（队列）</h2><h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        queue&lt;TreeNode*&gt; que;<br>        <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">nullptr</span>) que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            vector&lt;<span class="hljs-type">int</span>&gt; res;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i)&#123;<br>                TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>                res.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>                <span class="hljs-keyword">if</span>(node-&gt;left != <span class="hljs-literal">nullptr</span>) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span>(node-&gt;right != <span class="hljs-literal">nullptr</span>) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>                que.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            result.<span class="hljs-built_in">push_back</span>(res);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="二叉搜索树（BST）"><a href="#二叉搜索树（BST）" class="headerlink" title="二叉搜索树（BST）"></a>二叉搜索树（BST）</h2><p>不需要使用栈或队列~</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">searchBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (root != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">if</span> (root-&gt;val &gt; val) root = root-&gt;left;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root-&gt;val &lt; val) root = root-&gt;right;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树基本概念</title>
    <link href="/2022/07/25/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <url>/2022/07/25/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><ol><li>结点的度：节点拥有的子树数；</li><li>树的度：树内各结点度的最大值；</li><li>结点的层次从根开始定义，根为第一层；</li><li>树的深度或高度：树中结点的最大层次；</li><li>路径长度：路径上的分支数目；</li><li>树的路径长度是从树根到每一结点的路径长度之和，完全二叉树路径长度最短；</li></ol><ul><li><p>二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数。 </p></li><li><p>二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数。</p></li></ul><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><ol><li>二叉树每个结点至多有两个子树；</li><li>在二叉树的第i层至多有<code>2i-1</code>个结点；</li><li>深度为k的二叉树至多有<code>2k-1</code> 个结点；</li><li>对任何一棵二叉树，如果其终端结点数为n0 ，度为2的结点数为n2 ，则<code>n0 = n2 + 1</code>；</li><li>满二叉树：一棵深度为k的有2k - 1 个结点的二叉树；</li><li>赫夫曼树，又称最优二叉树，是一类带权路径长度最短的树；</li></ol><h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><ul><li><p>定义：自上而下，自左而右，每一结点编号对应于满二叉树。</p></li><li><p>特点：对完全二叉树的任一结点 <code>i``(1&lt;=i&lt;=n)</code>有：</p></li><li><ul><li>若<code>i&gt;1</code>，则其<strong>双亲结点</strong>为结点<code>i/2</code>；</li><li>若<code>2i&gt;n</code>，则结点i无<strong>左孩子</strong>，否则其左孩子为结点<code>2i</code>；</li><li>若<code>2i+1&gt;n</code>，则结点i无<strong>右孩子</strong>，否则其右孩子为结点<code>2i+1</code>；</li></ul></li></ul><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><ul><li><p>深度优先遍历<strong>（栈）</strong></p></li><li><ul><li>前序遍历（递归法，迭代法）</li><li>中序遍历（递归法，迭代法）</li><li>后序遍历（递归法，迭代法）</li></ul></li><li><p>广度优先遍历<strong>（队列）</strong></p></li><li><ul><li>层次遍历（迭代法）</li></ul></li></ul><h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p>也称二叉排序树，定义如下：</p><ul><li><p>或者是一棵空树，或者满足以下条件；</p></li><li><p>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</p></li><li><p>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</p></li><li><p>它的左、右子树也分别为二叉排序树。</p></li></ul><h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p>也称<strong>AVL树</strong>，定义如下：</p><ul><li>它是一棵空树或它的左右两个子树的<strong>高度</strong>差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</li></ul><p>C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树（<strong>红黑树</strong>），所以map、set的增删操作时间时间复杂度是<strong>logn</strong>；</p><p>unordered_map、unordered_set，unordered_map、unordered_map底层实现是<strong>哈希表</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Makefile使用</title>
    <link href="/2022/07/23/Makefile%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/07/23/Makefile%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul><li>当一个工程里面的源文件非常多时，手动敲命令就比较麻烦，就可以使用makefile；</li><li>Makefile 文件定义了一系列的规则来指定哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为 Makefile 文件就像一个 Shell 脚本一样，也可以执行操作系统的命令；</li><li>Makefile 带来的好处就是“自动化编译” ，一旦写好，只需要一个 make 命令，整个工程完全自动编译；</li><li><strong>make</strong> 是一个命令工具，是一个解释 Makefile 文件中指令的命令工具；</li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="文件命名"><a href="#文件命名" class="headerlink" title="文件命名"></a>文件命名</h3><p>makefile 或者 Makefile</p><h3 id="Makefile-规则"><a href="#Makefile-规则" class="headerlink" title="Makefile 规则"></a>Makefile 规则</h3><ul><li><p>一个 Makefile 文件中可以有一个或者多个规则</p></li><li><ul><li>目标 … : 依赖 …</li><li>命令（Shell 命令）</li><li>…</li></ul></li><li><p>目标：最终要生成的文件（伪目标除外）</p></li><li><p>依赖：生成目标所需要的文件或是目标</p></li><li><p>命令：通过执行命令对依赖操作生成目标（命令前必须 Tab 缩进）</p></li><li><p>Makefile 中的其它规则一般都是为第一条规则服务的</p></li><li><p>自定义变量</p></li><li><ul><li>定义：变量名&#x3D;变量值，例如 var&#x3D;hello</li><li>使用：获取变量的值，即<code> $(var)</code></li></ul></li><li><p>预定义变量</p></li><li><ul><li>AR : 归档维护程序的名称，默认值为 ar</li><li>CC : C 编译器的名称，默认值为 cc</li><li>CXX : C++ 编译器的名称，默认值为 g++</li><li>……</li></ul></li></ul><h2 id="简单举例"><a href="#简单举例" class="headerlink" title="简单举例"></a>简单举例</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs makefile">CXX = g++<br>CFLAGS = -std=c++17 -O2 -g -Wall<br><br>TARGET = serverApp<br>OBJS = ../code/buffer/*.cpp ../code/http/*.cpp ../code/logsys/*.cpp \<br>       ../code/pool/*.cpp ../code/server/*.cpp ../code/timer/*.cpp \<br>       ../code/json/*.cpp ../main.cpp<br><br><span class="hljs-section">all: </span><br><span class="hljs-variable">$(CXX)</span> <span class="hljs-variable">$(CFLAGS)</span> <span class="hljs-variable">$(OBJS)</span> -o ../<span class="hljs-variable">$(TARGET)</span>  -pthread -lmysqlclient<br><br><span class="hljs-section">clean:</span><br>rm -rf ../<span class="hljs-variable">$(TARGET)</span><br></code></pre></td></tr></table></figure><p>一般我们写好makefile后只需运行：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">make</span><br></code></pre></td></tr></table></figure><p>若想清理生成的文件：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">make clean</span><br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Makefile</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GNU编译工具使用</title>
    <link href="/2022/07/23/GNU%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/07/23/GNU%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">sudo apt update<br># 通过以下命令安装编译器和调试器<br>sudo apt install build-essential gdb<br><br># 查看版本号<br>gcc --version<br>g++ --version<br>gdb --version<br></code></pre></td></tr></table></figure><h2 id="gcc-x2F-g-基本用法"><a href="#gcc-x2F-g-基本用法" class="headerlink" title="gcc&#x2F;g++基本用法"></a>gcc&#x2F;g++基本用法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">gcc filename -o outputfileName<br><br><span class="hljs-meta"># gdb支持</span><br>gcc filename -g -o outputfileName<br></code></pre></td></tr></table></figure><h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><blockquote><p>生成**.i** 文件</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># -E 选项指示编译器仅对输入文件进行预处理</span><br>g++ -E test.cpp -o test.i<br></code></pre></td></tr></table></figure><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><blockquote><p>生成**.s** 文件</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># -S 编译选项告诉 g++ 在为 C++ 代码产生了汇编语言文件后停止编译</span><br><span class="hljs-comment"># g++ 产生的汇编语言文件的缺省扩展名是 .s </span><br>g++ -S test.i -o test.s<br></code></pre></td></tr></table></figure><h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><blockquote><p>生成**.o** 文件</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># -c 选项告诉 g++ 仅把源代码编译为机器语言的目标代码</span><br><span class="hljs-comment"># 缺省时 g++ 建立的目标代码文件有一个 .o 的扩展名。</span><br>g++ -c test.s -o test.o<br></code></pre></td></tr></table></figure><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><blockquote><p>生成<strong>可执行</strong> 文件</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># -o 编译选项来为将产生的可执行文件用指定的文件名</span><br>g++ test.o -o <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><h2 id="重要参数"><a href="#重要参数" class="headerlink" title="重要参数"></a>重要参数</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">-E 预处理指定的源文件，不进行编译<br>-S 编译指定的源文件，但是不进行汇编<br>-c 编译、汇编指定的源文件，但是不进行链接<br>[file2] -o [file1] 将文件 file2 编译成可执行文件 file1，指定输出文件名<br>-I directory 指定 include 包含文件的搜索目录<br>-g 在编译的时候，生成调试信息，该程序可以被调试器调试<br>-D 在程序编译的时候，指定一个宏<br>-w 不生成任何警告信息<br>-Wall 生成所有警告信息<br>-O[n] n的取值范围：0~3，编译器的优化选项的4个级别，-O0表示没有优化，-O1为缺省值，-O3优化级别最高<br>-l 在程序编译的时候，指定使用的库<br>-L 指定编译的时候，搜索的库的路径<br>-fPIC/fpic 生成与位置无关的代码<br>-shared 生成共享目标文件，通常用在建立共享库时<br>-std 指定C方言，如:-std=c++11<br></code></pre></td></tr></table></figure><h2 id="静态库与动态库"><a href="#静态库与动态库" class="headerlink" title="静态库与动态库"></a>静态库与动态库</h2><ul><li>库文件是计算机上的一类文件，可以简单的把库文件看成一种代码仓库，它提供给使用者一些可以直接拿来用的变量、函数或类。</li><li>库是特殊的一种程序，只是库不能单独运行。</li><li>库文件有两种，静态库和动态库（共享库），区别是：静态库在程序的链接阶段被<strong>复制</strong>到了程序中；动态库在链接阶段没有被复制到程序中，而是程序在运行时由系统动态加载到<strong>内存</strong>中供程序调用。</li><li>库的好处：代码保密、方便部署和分发。</li></ul><h3 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">命名规则：<br>◆ Linux : libxxx.a<br>lib : 前缀（固定）<br>xxx : 库的名字，自己起<br>.a  : 后缀（固定）<br>◆ Windows : libxxx.lib<br><br>制作：<br><span class="hljs-comment"># gcc 获得.o 文件</span><br><span class="hljs-comment"># 将.o 文件打包，使用 ar 工具（archive）</span><br>ar rcs libxxx.a xxx.o xxx.o<br></code></pre></td></tr></table></figure><h3 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">命名规则：<br>◆ Linux : libxxx.so<br>lib : 前缀（固定）<br>xxx : 库的名字，自己起<br>.so : 后缀（固定）<br>在Linux下是一个可执行文件<br>◆ Windows : libxxx.dll<br><br>制作：<br><span class="hljs-comment"># gcc 得到 .o 文件，得到和位置无关的代码</span><br>gcc -c –fpic/-fPIC a.c b.c<br><span class="hljs-comment"># gcc 得到动态库</span><br>gcc -shared a.o b.o -o libcalc.so<br></code></pre></td></tr></table></figure><h2 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h2><p>功能：</p><ul><li>设置断点(断点可以是条件表达式)</li><li>使程序在指定的代码行上暂停执行，便于观察</li><li>单步执行程序，便于调试</li><li>查看程序中变量值的变化</li><li>动态改变程序的执行环境</li><li>分析崩溃程序产生的core文件</li></ul><blockquote><p>指令可以简写，是第一个字符</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 启动</span><br>gdb outputfileName<br><br><span class="hljs-comment"># 退出</span><br>quit<br><br><span class="hljs-comment"># GDB 使用帮助</span><br><span class="hljs-built_in">help</span><br><br><span class="hljs-comment"># 查看当前文件代码</span><br>list/l （从默认位置显示）<br>list/l 行号 （从指定的行显示）<br>list/l 函数名（从指定的函数显示）<br><br><span class="hljs-comment"># 设置断点</span><br>b/break 行号<br>b/break 函数名<br>b/break 文件名:行号<br>b/break 文件名:函数<br><span class="hljs-comment"># 删除断点</span><br>d/del/delete 断点编号<br><span class="hljs-comment"># 设置断点无效</span><br>dis/disable 断点编号<br><span class="hljs-comment"># 设置断点生效</span><br>ena/enable 断点编号<br><span class="hljs-comment"># 设置条件断点（一般用在循环的位置）</span><br>b/break 10 <span class="hljs-keyword">if</span> i==5<br><br><span class="hljs-comment"># 运行</span><br>start（程序停在第一行）<br>run（遇到断点才停）<br><br><span class="hljs-comment"># 暂停后继续，到下一个断点停</span><br>c/continue<br><br><span class="hljs-comment"># 通过命令&#x27;next&#x27; 和&#x27;step&#x27; 逐行运行程序。</span><br><span class="hljs-comment"># Next 将控件严格保持在当前范围内</span><br>n/next <span class="hljs-comment"># 向下执行一行代码（不会进入函数体）</span><br><br><span class="hljs-comment"># 向下单步调试（遇到函数进入函数体）</span><br>s/step<br>finish（跳出函数体）<br><br><span class="hljs-comment"># 变量操作</span><br>p/print 变量名（打印变量值）<br>ptype 变量名（打印变量类型）<br><br><span class="hljs-comment"># 修改变量</span><br><span class="hljs-built_in">set</span> &lt;var&gt; = &lt;value&gt;<br><br><span class="hljs-comment"># 设置观察点，每当发生更改时，程序都会暂停并为您提供更改的详细信息。</span><br><span class="hljs-comment"># 只能在变量处于范围内时为其设置观察点</span><br>watch &lt;var&gt;<br><br></code></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://b23.tv/tWqKrC">https://b23.tv/tWqKrC</a></p></li><li><p>牛客网C++教学视频</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>GNU</tag>
      
      <tag>GCC</tag>
      
      <tag>G++</tag>
      
      <tag>GDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux下Vim编辑器的使用</title>
    <link href="/2022/07/23/Linux%E4%B8%8BVim%E7%BC%96%E8%BE%91%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/07/23/Linux%E4%B8%8BVim%E7%BC%96%E8%BE%91%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="command-mode"><a href="#command-mode" class="headerlink" title="command mode"></a>command mode</h2><blockquote><p> 首先进入的就是命令模式。</p></blockquote><h3 id="模式切换"><a href="#模式切换" class="headerlink" title="模式切换"></a>模式切换</h3><ul><li><strong>i</strong> 切换到输入模式，以输入字符；</li><li><strong>:</strong> 切换到底线命令模式，以在最后一行输入命令；</li></ul><h3 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h3><ul><li><strong>方向键</strong> 移动光标；</li><li><strong>h&#x2F;j&#x2F;k&#x2F;l</strong> 光标左、下、上、右移动一个字符，30j表示下移光标30行；</li><li><strong>pg up&#x2F;dn</strong> 上下翻页；</li><li><strong>ctrl + b&#x2F;f</strong> 上下翻页；</li><li><strong>ctrl + u&#x2F;d</strong> 上下翻半页；</li><li><strong>n + space</strong> 光标向右移动n个字符；</li><li><strong>H&#x2F;M&#x2F;L</strong> 光标移动到整个屏幕的最上方、中间、最下方那一行的第一个字符；</li><li><strong>G&#x2F;gg</strong> 光标移动到最后一行、第一行；</li></ul><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><ul><li><strong>&#x2F;word</strong> 向光标之下搜索word这个字符串，按<strong>n&#x2F;N</strong>后依次找到出现的目标字符串；</li><li><strong>?word</strong> 向光标之上搜索word这个字符串，按<strong>n&#x2F;N</strong>后依次找到出现的目标字符串；</li></ul><h3 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h3><ul><li><strong>x</strong> 删除当前光标所在字符，<strong>X</strong> 删除当前光标前一个字符；</li><li><strong>dd</strong> 剪切光标所在的一行，<strong>ndd</strong> 剪切光标所在的向下n行；</li><li><strong>yy</strong> 复制光标所在的一行，<strong>nyy</strong> 复制光标所在的向下n行；</li><li><strong>p&#x2F;P</strong> 在光标下&#x2F;上一行粘贴；</li><li><strong>u</strong> 复原前一个操作；</li></ul><h2 id="insert-mode"><a href="#insert-mode" class="headerlink" title="insert mode"></a>insert mode</h2><ul><li><strong>enter</strong> 回车键，换行；</li><li><strong>backspace</strong> 退格键，删除光标前一个字符；</li><li><strong>delete</strong> 删除键，删除光标后一个字符；</li><li><strong>方向键</strong> 移动光标；</li><li><strong>home&#x2F;end</strong> 移动光标到行首行尾；</li><li><strong>pg up&#x2F;dn</strong> 上下翻页；</li><li><strong>esc</strong> 退出输入模式，切换到命令模式；</li></ul><h2 id="lastline-mode"><a href="#lastline-mode" class="headerlink" title="lastline mode"></a>lastline mode</h2><blockquote><p>命令在输入回车键后运行。</p></blockquote><ul><li><strong>esc</strong> 退出底线模式，切换到命令模式；</li><li><strong>q</strong> 退出程序；</li><li><strong>q!</strong> 强制退出程序并且不保存；</li><li><strong>w</strong> 保存文件；</li><li><strong>w!</strong> 强制保存文件；</li><li><strong>wq</strong> 保存文件后离开；</li><li><strong>wq!</strong> 强制保存文件后离开；</li><li><strong>w filename</strong> 将编辑过的文件另存为filename这个文件；</li><li><strong>set nu</strong> 显示行号；</li><li><strong>set nonu</strong> 取消显示行号；</li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git使用和常用命令</title>
    <link href="/2022/07/23/Git%E4%BD%BF%E7%94%A8%E5%92%8C%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/07/23/Git%E4%BD%BF%E7%94%A8%E5%92%8C%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h3 id="第一次下载"><a href="#第一次下载" class="headerlink" title="第一次下载"></a>第一次下载</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">apt-get install git<br><br>git config --global user.name <span class="hljs-string">&quot;zyue&quot;</span>        <span class="hljs-comment"># your name</span><br>git config --global user.email <span class="hljs-string">&quot;3506656950@qq.com&quot;</span>    <span class="hljs-comment"># your email</span><br>git config --global core.editor vim            <span class="hljs-comment"># your favourite editor</span><br>git config --global color.ui <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git init<br></code></pre></td></tr></table></figure><h3 id="添加文件到git仓库"><a href="#添加文件到git仓库" class="headerlink" title="添加文件到git仓库"></a>添加文件到git仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 第一步</span><br>git add filename<br><span class="hljs-comment"># 全部文件</span><br>git add .<br><br><span class="hljs-comment"># 第二步</span><br>git commit -m <span class="hljs-string">&quot;此次提交说明&quot;</span><br><br><span class="hljs-comment"># add把要提交的修改放在暂存区，commit一次性把暂存区的所有修改提交到分支</span><br></code></pre></td></tr></table></figure><h3 id="仓库状态"><a href="#仓库状态" class="headerlink" title="仓库状态"></a>仓库状态</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 当前仓库状态</span><br>git status <br><br><span class="hljs-comment"># 比较同一个文件在不同版本中的区别</span><br>git diff filename<br></code></pre></td></tr></table></figure><h3 id="查看所有存档"><a href="#查看所有存档" class="headerlink" title="查看所有存档"></a>查看所有存档</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">log</span> <br><br><span class="hljs-comment"># 输出的 HEAD 表示当前版本</span><br><span class="hljs-comment"># 输出的 HEAD^ 表示上一个版本</span><br><span class="hljs-comment"># 输出的 HEAD^^ 表示上上个版本</span><br><span class="hljs-comment"># 输出的 HEAD~N 表示上N个版本</span><br><br><span class="hljs-comment"># 简化输出</span><br>git <span class="hljs-built_in">log</span> --pretty=oneline<br></code></pre></td></tr></table></figure><h3 id="回退版本"><a href="#回退版本" class="headerlink" title="回退版本"></a>回退版本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset --hard HEAD^<br><span class="hljs-comment"># 或</span><br>git reset --hard 版本号前几位<br><br><span class="hljs-comment"># 注意shell关闭后就回不到将来了</span><br></code></pre></td></tr></table></figure><h3 id="查看历史命令"><a href="#查看历史命令" class="headerlink" title="查看历史命令"></a>查看历史命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reflog<br></code></pre></td></tr></table></figure><h3 id="远程github"><a href="#远程github" class="headerlink" title="远程github"></a>远程github</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建ssh key</span><br>ssh-keygen -t rsa -C <span class="hljs-string">&quot;邮箱账号&quot;</span><br><span class="hljs-comment"># id_rsa.pub是公钥，用于添加远程账户</span><br><br><span class="hljs-comment"># ssh比https方便</span><br>git remote add origin git@github.com:H-ZYUE/learn_Ubuntu2104.git <span class="hljs-comment"># 关联仓库</span><br>git branch -m main <span class="hljs-comment"># 改名当前分支为main，master也可以</span><br>git push -u origin main <span class="hljs-comment"># 第一次加 -u，推送到远程仓库</span><br><br><span class="hljs-comment"># 后续上传</span><br>git push origin main<br><br>git remote <span class="hljs-built_in">rm</span> origin <span class="hljs-comment">#删除原来关联</span><br>git remote -v <span class="hljs-comment">#查看已有关联</span><br><br><span class="hljs-comment"># 从github克隆</span><br>git <span class="hljs-built_in">clone</span> 仓库名字<br></code></pre></td></tr></table></figure><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建并切换分支，dev是分支名</span><br><span class="hljs-comment"># git checkout -b dev</span><br><br><span class="hljs-comment"># -b表示创建并切换，上述等同于如下</span><br><span class="hljs-comment"># git branch dev</span><br><span class="hljs-comment"># git checkout dev </span><br><br><span class="hljs-comment"># 创建并切换到创建的分支</span><br>git switch -c branchName<br><br><span class="hljs-comment"># 切换到已有分支</span><br>git switch branchName<br><br><span class="hljs-comment"># 查看分支，*指示当前分支</span><br>git branch<br><br><span class="hljs-comment"># 当在dev分支完成工作后可以合并分支</span><br><span class="hljs-comment"># 合并指定分支到当前分支</span><br>git merge dev <span class="hljs-comment"># 此时在master分支下</span><br><br><span class="hljs-comment"># 合并完可以删除不需要的分支</span><br>git branch -d dev<br><br><span class="hljs-comment"># 通常使用分支完成某个任务，成功完成任务后合并其到master分支，再删除不需要的分支</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>Github</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux常用命令笔记</title>
    <link href="/2022/07/23/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/07/23/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="管理用户"><a href="#管理用户" class="headerlink" title="管理用户"></a>管理用户</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 按默认值添加用户</span><br>useradd userName<br><br><span class="hljs-comment"># 在root环境下，root帮userName设置密码</span><br>passwd userName<br><span class="hljs-comment"># 或</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;密码&quot;</span> | passwd --stdin userName<br><br><span class="hljs-comment"># userName这个用户第一次登录时（默认密码是用户名），自己设置自己密码</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;userName&quot;</span> | passwd --stdin userName<br>chage -d 0 userName<br>chage -l userName | <span class="hljs-built_in">head</span> -n 3<br><span class="hljs-comment"># 不过这一般还需改psaawd和shadow权限</span><br><br><span class="hljs-comment"># 删除用户</span><br>userdel -r userName<br><span class="hljs-comment"># 最好删除前找到属于要删用户的文件</span><br>find / -user userName<br></code></pre></td></tr></table></figure><h2 id="权限切换"><a href="#权限切换" class="headerlink" title="权限切换"></a>权限切换</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 普通用户要想使用sudo，先用visudo编辑/etc/sudoers文件</span><br>visudo <span class="hljs-comment"># 会打开sudoers文件</span><br><span class="hljs-comment"># 或</span><br>vim /etc/sudoers<br><br><span class="hljs-comment"># 指定用户sudo，添加下行</span><br>userName ALL=(ALL) ALL<br><span class="hljs-comment"># 指定用户免密sudo，添加下行</span><br>userName ALL=(ALL) NOPASSWD:ALL<br><br><span class="hljs-comment"># 某用户组免密sudo，添加下行</span><br>%groupName ALL=(ALL) NOPASSWD:ALL<br><br><span class="hljs-comment"># 经由 sudo 所执行的指令就好像是 root 亲自执行</span><br>sudo 指令 <span class="hljs-comment"># 此处输入的密码是当前用户的密码，也可以设置成不输入密码执行sudo</span><br><br><span class="hljs-comment"># 系统第一次使用su切换至root权限时，先设置密码</span><br>sudo passwd root<br><br><span class="hljs-comment"># su 是最简单的用户切换命令</span><br>su - <span class="hljs-comment"># 环境和权限都切换到root</span><br><br><span class="hljs-comment"># 使用 exit 命令进行手动切换回原用户</span><br><span class="hljs-built_in">exit</span><br></code></pre></td></tr></table></figure><h2 id="压缩-x2F-解压"><a href="#压缩-x2F-解压" class="headerlink" title="压缩&#x2F;解压"></a>压缩&#x2F;解压</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 对于bzip2的解压缩</span><br><br><span class="hljs-comment"># 压缩</span><br>tar -jcv -f filename.tar.bz2 要被压缩的文件或目录<br><br><span class="hljs-comment"># 解压</span><br>tar -jxv -f filename.tar.bz2 -C 要解压在那个目录的位置<br><br><span class="hljs-comment"># -----------------------------------</span><br>-j <span class="hljs-comment"># bzip2，即*.tar.bz2</span><br>-J <span class="hljs-comment"># xz，即*.tar.xz</span><br>-z <span class="hljs-comment"># gzip，即*.tar.gz</span><br></code></pre></td></tr></table></figure><h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 基于RPM</span><br><span class="hljs-comment"># 安装需root权限</span><br><br><span class="hljs-comment"># yum 在线安装</span><br>yum search appName <span class="hljs-comment"># 在yum服务器上找这个软件</span><br>yum install appName <span class="hljs-comment"># 安装软件</span><br>yum update appName <span class="hljs-comment"># 升级这个软件</span><br>yum remove appName <span class="hljs-comment"># 删除软件</span><br><br><span class="hljs-comment"># rpm 查询与效验，也可以使用.rpm文件安装</span><br>rpm -ivh packageName.rpm <span class="hljs-comment"># 安装</span><br>rpm -qa <span class="hljs-comment"># 查询已安装软件</span><br>rpm -q appName <span class="hljs-comment"># 查询是否安装appName这个软件</span><br>rpm -e appName <span class="hljs-comment"># 删除软件</span><br><br><span class="hljs-comment"># -----------------------------------------------</span><br><span class="hljs-comment"># dpkg系</span><br>sudo apt-get update   <span class="hljs-comment"># 取回更新的软件包列表信息</span><br>sudo apt-get upgrade<span class="hljs-comment"># 升级所有软件包</span><br><br>sudo apt-get install packagename<span class="hljs-comment"># 安装软件包</span><br>sudo apt-get remove packagename  <span class="hljs-comment"># 卸载软件包</span><br>sudo apt-get purge packagename  <span class="hljs-comment"># 卸载并清除软件包的配置</span><br><br>sudo dpkg -i filename.deb <span class="hljs-comment"># 安装本地二进制deb包</span><br>sudo dpkg -r packagename <span class="hljs-comment"># 卸载软件包</span><br><br>sudo apt-get clean            <span class="hljs-comment"># 删除所有已下载的包文件</span><br></code></pre></td></tr></table></figure><h2 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 文件属性：</span><br><span class="hljs-comment"># 读r 4</span><br><span class="hljs-comment"># 写w 2</span><br><span class="hljs-comment"># 执行   x 1</span><br><span class="hljs-comment"># 目录  d</span><br><span class="hljs-comment"># 文件  -</span><br><span class="hljs-comment"># 链接文件   l</span><br><br><span class="hljs-comment"># 修改用户组，-R递归修改</span><br><span class="hljs-built_in">chgrp</span> 用户组名 文件或目录名<br><br><span class="hljs-comment"># 修改拥有者，-R递归修改</span><br><span class="hljs-built_in">chown</span> 用户名 文件或目录名<br><span class="hljs-built_in">chown</span> 用户名:用户组名 文件或目录名 <span class="hljs-comment"># 也可同时修改用户组</span><br><br><span class="hljs-comment"># 修改权限，-R递归修改</span><br><span class="hljs-built_in">chmod</span> 777 文件名<br><span class="hljs-comment"># u,g,o,这3种身份，a是全部</span><br><span class="hljs-built_in">chmod</span> u=rwx,g=rx,0=r 文件名 <span class="hljs-comment"># =是设置</span><br><span class="hljs-built_in">chmod</span> a+w 文件名 <span class="hljs-comment"># +是加入某权限</span><br><span class="hljs-built_in">chmod</span> g-x 文件名 <span class="hljs-comment"># -是取消某权限</span><br><br><span class="hljs-comment"># 文件隐藏属性</span><br><span class="hljs-comment"># 常用的是+i，+a</span><br>chattr +i 文件名 <span class="hljs-comment"># 使此文件无法被修改</span><br>chattr -i 文件名 <span class="hljs-comment"># 使此文件可修改</span><br><span class="hljs-comment"># a是只能添加，不能修改和删除</span><br></code></pre></td></tr></table></figure><h2 id="变量设置"><a href="#变量设置" class="headerlink" title="变量设置"></a>变量设置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看变量，echo有显示打印的意思，$后接变量名</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$PATH</span><br><span class="hljs-comment"># 或</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;PATH&#125;</span><br><br><span class="hljs-comment"># 添加PATH路径</span><br>PATH=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;PATH&#125;</span>:/somedirpath&quot;</span><br><br><span class="hljs-comment"># 设置变量，=号两边无空格</span><br>var=something<br><span class="hljs-comment"># 变量内容有空格时</span><br>var=<span class="hljs-string">&quot;lang is <span class="hljs-variable">$LANG</span>&quot;</span> <span class="hljs-comment"># 双引号保留原有属性</span><br>var=<span class="hljs-string">&#x27;lang is $LANG&#x27;</span> <span class="hljs-comment"># 单引号不保留原有属性</span><br><br><span class="hljs-comment"># 扩为环境变量</span><br><span class="hljs-built_in">export</span> var<br><br><span class="hljs-comment"># 取消变量</span><br><span class="hljs-built_in">unset</span> var<br><br><span class="hljs-comment"># 查看环境变量</span><br><span class="hljs-built_in">env</span> <span class="hljs-comment"># 或export</span><br><br><span class="hljs-comment"># 查看环境变量与自定义变量</span><br><span class="hljs-built_in">set</span><br></code></pre></td></tr></table></figure><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 终端后台</span><br><br><span class="hljs-comment"># 在命令最后加上&amp;，表示后台执行</span><br>somecommand &amp; <br><span class="hljs-comment"># 如果命令有输出，可重定向数据流</span><br><br><span class="hljs-comment"># 将目前任务丢到后台中，暂停</span><br>ctrl-z<br><br><span class="hljs-comment"># 查看后台任务</span><br><span class="hljs-built_in">jobs</span> -l<br><br><span class="hljs-comment"># 将后台任务拿到前台，%可选</span><br><span class="hljs-built_in">fg</span> %jobnumber<br><br><span class="hljs-comment"># 将后台任务状态变成运行中</span><br><span class="hljs-built_in">bg</span> %jobnumber<br><br><span class="hljs-comment"># 删除任务</span><br><span class="hljs-built_in">kill</span> -9 %jobnumber <span class="hljs-comment"># 强制删除</span><br><span class="hljs-built_in">kill</span> -15 %jobnumber <span class="hljs-comment"># 正常删除</span><br><br><span class="hljs-comment"># -------------------------------------------------</span><br><br><span class="hljs-comment"># 系统后台</span><br><span class="hljs-built_in">nohup</span> somecommand &amp; <span class="hljs-comment"># 注销登录后也继续运行</span><br><br><span class="hljs-comment"># -------------------------------------------------</span><br><br><span class="hljs-comment"># 查看自己bash相关进程</span><br>ps -l<br><br><span class="hljs-comment"># 查看系统中所有运行进程</span><br>ps aux<br></code></pre></td></tr></table></figure><h2 id="系统服务"><a href="#系统服务" class="headerlink" title="系统服务"></a>系统服务</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 管理服务unit</span><br>systemctl <span class="hljs-built_in">command</span> unit<br><span class="hljs-comment"># command有(常用)：</span><br>status   <span class="hljs-comment"># 查看状态</span><br>start    <span class="hljs-comment"># 立即启动</span><br>stop     <span class="hljs-comment"># 立即关闭</span><br>restart  <span class="hljs-comment"># 重启</span><br>reload   <span class="hljs-comment"># 重新加载配置文件</span><br><span class="hljs-built_in">enable</span>   <span class="hljs-comment"># 开机自启</span><br><span class="hljs-built_in">disable</span> <span class="hljs-comment"># 不开机自启</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>命令</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KMP算法</title>
    <link href="/2022/07/23/KMP%E7%AE%97%E6%B3%95/"/>
    <url>/2022/07/23/KMP%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><ul><li>KMP算法用来在<strong>文本串</strong>中匹配<strong>模式串</strong>，查找模式串出现的位置。</li><li>KMP的主要思想是当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。</li><li>需要用到next数组，即前缀表。前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。<ul><li>前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串。</li><li>后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串。</li></ul></li><li>前缀表：<strong>记录下标i之前（包括i）的字符串中，子串(s[0]至s[i])有多大<code>长度</code>的相同长度的前缀、后缀</strong>。</li></ul><h3 id="计算前缀表"><a href="#计算前缀表" class="headerlink" title="计算前缀表"></a>计算前缀表</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// i是后缀末尾，j是前缀末尾</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getNext</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; next, <span class="hljs-type">const</span> string&amp; s)</span> </span>&#123;<br>    <span class="hljs-type">int</span> j   = <span class="hljs-number">0</span>;<br>    next[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// j指向前缀末尾位置，i指向后缀末尾位置</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; s[i] != s[j]) &#123;<br>            j = next[j - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (s[i] == s[j]) &#123;<br>            ++j;<br>        &#125;<br>        next[i] = j;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a>字符串匹配</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">strStr</span><span class="hljs-params">(string haystack, string needle)</span> </span>&#123;<br>    <span class="hljs-type">int</span> m = haystack.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> n = needle.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span> || n &gt; m) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">next</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-built_in">getNext</span>(next, needle);<br><br>    <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// j 是模式串的下标，i 是文本串的下标</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>        <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; haystack[i] != needle[j]) &#123;<br>            <span class="hljs-comment">// 遇到不匹配字符时，跳转到前一个字符的前缀表的记录位置</span><br>            j = next[j - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (haystack[i] == needle[j]) &#123;<br>            <span class="hljs-comment">// 字符匹配</span><br>            ++j;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (j == n) &#123;<br>            <span class="hljs-keyword">return</span> i - n + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-comment">// 可发现匹配过程与创建前缀表的过程相似</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string s1 = <span class="hljs-string">&quot;aabaabaafa&quot;</span>;<br>    string s2 = <span class="hljs-string">&quot;aabaaf&quot;</span>;<br>    cout &lt;&lt; <span class="hljs-built_in">strStr</span>(s1, s2) &lt;&lt; endl;<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h3><p><a href="https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC">代码随想录</a>、<a href="https://leetcode.cn/problems/implement-strstr/">LeetCode 28题</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高性能并发Web服务器</title>
    <link href="/2022/07/18/%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91Web%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2022/07/18/%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91Web%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="WebServer"><a href="#WebServer" class="headerlink" title="WebServer"></a>WebServer</h2><p>高性能并发服务器，由<code>webbench</code>测试可达到上万QPS；</p><p><strong>【关键词】</strong></p><p><strong>C++11、IO多路复用技术Epoll、Reactor高并发模型、线程池、异步日志系统、最小堆定时器、数据库连接池、有限状态机、自增长缓冲区、单例模式、自定义Json解析器</strong></p><hr><ul><li><a href="#webserver">WebServer</a></li><li><a href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B">工作流程</a><ul><li><a href="#%E6%B5%81%E7%A8%8B%E5%9B%BE">流程图</a></li></ul></li><li><a href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%A8%A1%E5%9D%97">线程池模块</a></li><li><a href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E6%A8%A1%E5%9D%97">缓冲区模块</a></li><li><a href="#epoll%E6%A8%A1%E5%9D%97">Epoll模块</a></li><li><a href="#http%E8%BF%9E%E6%8E%A5%E6%A8%A1%E5%9D%97">HTTP连接模块</a></li><li><a href="#http%E8%A7%A3%E6%9E%90%E6%A8%A1%E5%9D%97">HTTP解析模块</a></li><li><a href="#http%E5%93%8D%E5%BA%94%E6%A8%A1%E5%9D%97">HTTP响应模块</a></li><li><a href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E6%A8%A1%E5%9D%97">定时器模块</a></li><li><a href="#%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97">日志模块</a></li><li><a href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E6%A8%A1%E5%9D%97">阻塞队列模块</a></li><li><a href="#mysql%E8%BF%9E%E6%8E%A5%E6%B1%A0%E6%A8%A1%E5%9D%97">MySQL连接池模块</a></li><li><a href="#json%E8%A7%A3%E6%9E%90%E6%A8%A1%E5%9D%97">Json解析模块</a></li><li><a href="#webserver%E6%A8%A1%E5%9D%97">WebServer模块</a></li><li><a href="#%E5%8F%82%E8%80%83%E5%8F%8A%E8%87%B4%E8%B0%A2">参考及致谢</a></li></ul><hr><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><ol><li>本服务器项目采用的是<strong>同步I&#x2F;O</strong>(<code>epoll_wait</code>)实现<code>Reactor</code>事件处理模式；</li><li>主线程负责监听文件描述符上是否有事件发生、接受新连接，工作线程负责读写数据，处理客户请求；</li><li>工作流程是：主线程往 epoll 内核事件表中注册 <strong>监听socket</strong> 上的读就绪事件，而后调用 epoll_wait 等待 socket 上的事件发生，如下是可能事件类型：</li></ol><ul><li><p>若是新连接，主线程就往 epoll 内核事件表中注册该 socket 上的读就绪事件；</p></li><li><p>socket 上是错误事件时，主线程就关闭该连接；</p></li><li><p>socket 上是读事件时， 主线程则将<strong>读任务</strong>放入任务队列，睡眠在请求队列上的某个工作线程被唤醒，它从 socket 读取数据，并处理客户请求(解析HTTP报文，生成HTTP响应)，然后往 epoll 内核事件表中注册该 socket 上的写就绪事件；</p></li><li><p>socket上是写事件时，主线程将<strong>写任务</strong>放入任务队列，睡眠在请求队列上的某个工作线程被唤醒，它往 socket 上写入响应报文，若是长连接就再次注册该 socket 上的读就绪事件，否则关闭连接；</p></li></ul><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img src="/./text_img/flowchart.jpg"></p><hr><h2 id="线程池模块"><a href="#线程池模块" class="headerlink" title="线程池模块"></a>线程池模块</h2><ul><li>池是一组资源的集合，服务器事先初始化好一组线程，即创建好线程池，这称为静态资源；</li><li>当服务器运行的时候，需要处理时就从池中取出一个线程，用完后还回去，无需动态申请和销毁资源，是一种以空间换时间的概念；</li><li>在构造函数中创建一组线程，用<strong>lambda表达式</strong>这种可调用对象作为子线程的工作函数，并设置<strong>线程分离</strong>；</li><li>使用<strong>互斥量</strong>和<strong>条件变量</strong>保证线程同步，需要运行的任务装载在一个队列中，即<strong>任务队列</strong>；</li><li>任务就是<strong>函数模板对象</strong>，类中有一个加入任务的模板成员函数<code>addTask</code>，每加入一个任务，唤醒一个线程；</li><li>子线程的工作逻辑其实就是从任务队列中取出任务然后执行它，若队列为空就休眠等待直到被唤醒；</li><li>还可以拓展的是：添加一个容器来装载各子线程、限制任务队列中最大任务数量；</li></ul><h2 id="缓冲区模块"><a href="#缓冲区模块" class="headerlink" title="缓冲区模块"></a>缓冲区模块</h2><ul><li>利用<code>vector&lt;char&gt;</code>实现的动态增长的缓冲区，用来保存数据以及读写数据；</li><li>一个缓冲区对象主要包括3个部分：已读取段、未读取段、未写入段；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">  已读取段    未读取段  未写入段<br>缓冲区：++++++++++++++-------------xxxxxxxxxxxxx<br>     ^  ^   ^<br>       读指针  写指针   容器结尾处<br></code></pre></td></tr></table></figure><ul><li>自动扩容机制是比较即将写入缓存的数据大小是否小于<strong>已读段加上未写段</strong>的大小，如果满足则将<strong>未读段</strong>移动到最左边，否则重新申请更大的内存；</li><li>缓冲区从<code>sockfd</code>读取数据时采用<strong>分散读</strong><code>readv</code>的方式，一块是指向当前缓冲区，另一块是辅助字符串防止缓冲区装不下，如果装不下后序再扩容缓冲区，然后合并到缓冲区中；</li><li>缓冲区往<code>sockfd</code>发送数据时直接调用<code>write</code>写入当前缓冲区中<strong>未读取段</strong>的数据；</li><li>缓冲区对应操作有：读取数据、返回读写位置、返回各个段信息、写入数据；</li></ul><h2 id="Epoll模块"><a href="#Epoll模块" class="headerlink" title="Epoll模块"></a>Epoll模块</h2><ul><li>用于初始化<code>epoll</code>实例，便于管理；</li><li>功能是在epoll实例中增、删、改socket文件描述符及其监听事件类型；</li></ul><h2 id="HTTP连接模块"><a href="#HTTP连接模块" class="headerlink" title="HTTP连接模块"></a>HTTP连接模块</h2><ul><li>每个HTTP连接对象表示一个客户端连接的各种<strong>属性</strong>，及其操作方法(<strong>读、处理、写</strong>)；</li><li>静态成员变量有：连接用户数、资源目录、epoll触发模式；</li><li>其它成员变量是：连接地址信息、socket文件描述符、连接是否关闭、读写缓冲区(自定义的buffer对象)、HTTP解析类对象、HTTP响应类对象；</li><li>主要操作方法有：初始化每个客户端连接、接收请求信息、发送响应信息、关闭连接；</li><li>简而言之，HTTP连接类对象就是用来接收请求然后回送响应，请求的解析和响应的生成是交给解析类对象和响应类对象去执行的；</li><li>读取请求数据是直接read客户端连接的socket文件描述符，读到<strong>读缓冲区</strong>里面；</li><li>请求的解析是调用解析类对象的成员函数，解析结果交给响应类对象去制作响应报文；</li><li>发送响应数据是采用<strong>聚集写</strong><code>writev</code>的方式，在一次函数调用中写多个非连续缓冲区，并且再循环里面调整区块一与区块二的基址和长度，区块一对应<strong>写缓冲区</strong>，区块二对应客户端请求的<strong>资源文件</strong>，区块的基址及长度由响应类对象的返回结果配置；</li></ul><h2 id="HTTP解析模块"><a href="#HTTP解析模块" class="headerlink" title="HTTP解析模块"></a>HTTP解析模块</h2><ul><li>HTTP解析类对象用来解析<strong>读缓冲区</strong>中的HTTP请求报文，支持解析GET和POST请求；</li><li>采用了<strong>正则表达式</strong>和<strong>有限状态机</strong>来解析；</li><li>有限状态机是逻辑单元内部的一种高效编程方法，报文的每种数据类型字段可以映射为逻辑单元的一种执行状态，可以根据它来编写相应的解析逻辑，并转移到相应状态继续解析；</li><li>一个类对象包含：当前解析状态(枚举变量)、协议版本、HTTP请求方法(GET或POST)、请求资源路径、请求头、请求体、是否长连接等等；</li><li>请求体和请求体的信息采用<strong>有序容器</strong><code>&lt;key:string, value:string&gt;</code>记录；</li><li>一个客户端连接可能有多次请求(<strong>长连接</strong>)，所以需要保存上次解析状态，用以指示是否为新的HTTP请求，当上一次的请求为完成状态时，会再次初始化解析类对象，以重新开始解析一个HTTP请求；</li><li>如果是GET请求，就不会解析<strong>请求体</strong>，如果是POST请求，还要从请求体中解析出账户与密码，然后MySQL连接池取出一个连接，调用API执行SQL语句，分别处理登录和注册的情况；</li><li>解析类对象中成员函数由HTTP连接类对象调用，读缓冲区作为主体解析函数的引用形式的形参传入；</li></ul><h2 id="HTTP响应模块"><a href="#HTTP响应模块" class="headerlink" title="HTTP响应模块"></a>HTTP响应模块</h2><ul><li>HTTP响应类对象负责根据解析结果，拼接响应报文到<strong>写缓冲区</strong>中；</li><li>使用了<strong>哈希表</strong>方便组装需要返回的状态码、头部字段信息；</li><li>成员变量有：请求资源文件(发送文件)的路径、是否长连接、状态码、内存映射区、文件信息；</li><li>操作方法有：往写缓冲区添加状态行、报文头部、报文正文(资源文件)；</li><li>资源文件通过<strong>内存映射</strong>方法映射到内存中，提高速度，当然会检查文件是否存在以及权限；</li><li>响应类对象中成员函数也由HTTP连接类对象调用，写缓冲区作为响应制作函数的引用形式的形参传入，如果有请求资源文件，还会返回文件映射在内存中的地址给连接类对象；</li></ul><h2 id="定时器模块"><a href="#定时器模块" class="headerlink" title="定时器模块"></a>定时器模块</h2><ul><li>每个连接对应一个<code>TimeNodo</code>节点，里面封装了超时时间、回调函数等信息；</li><li>采用最小堆数据结构管理所有连接的超时信息，即维护一个<strong>最小堆定时器</strong>；</li><li>最小堆是采用<code>vertor&lt;TimeNode&gt;</code>数组实现的，堆顶元素就是最先超时的连接；</li><li>数组下标从0开始，0下标即对应堆顶节点，对于堆中某一节点，令它在数组中下标为<code>k</code>，则左子节点为<code>2*k + 1</code>，右子节点为<code>2*k + 2</code>，父节点为<code>(k - 1) / 2</code>；</li><li>插入节点时，插入到数组中的最后一个节点的后面，然后与该节点的父节点比较大小，如果插入的元素小于父节点元素，那么与父节点交换位置。重复上述步骤直到大于父节点元素或者到达堆顶。该过程叫做<strong>上浮</strong>，即插入时上浮；</li><li>移除节点时，将该节点与末尾节点交换，然后当前节点(之前的尾部节点)与子节点中的较小者比较，如果当前节点大于较小子节点，那么与较小子节点交换位置，重复上述步骤直到小于较小子节点或者到达倒数第二个节点为止。最后再删除末尾节点。该过程叫做<strong>下沉</strong>，即移除元素时下沉;</li><li>最小堆定时器的操作有：添加节点、删除所有超时节点(断开超时连接)、调整节点的过期时间；</li></ul><h2 id="日志模块"><a href="#日志模块" class="headerlink" title="日志模块"></a>日志模块</h2><ul><li>日志模块用于同步或异步记录服务器运行信息，具有按天分类，超行分类功能；</li><li><strong>同步日志</strong>是日志写入函数与工作线程串行执行，由于涉及到I&#x2F;O操作，当单条日志比较大的时候，同步模式会阻塞整个处理流程，服务器的并发能力将有所下降；</li><li><strong>异步日志</strong>是将所写的日志内容先存入阻塞队列，写线程从阻塞队列中取出内容，写入日志；</li><li>异步日志用到了<strong>阻塞队列</strong>，还有<strong>单例模式</strong>，保证日志类对象只有一个实例对象，采用<strong>局部静态变量懒汉模式</strong>的方法实现；</li><li>日志有4个级别可选，分别是DEBUG、INFO、WARN、ERROR，分别对应级别0~3，比如设置级别为0时每个级别的信息都记录，设置为3时只记录错误信息；</li><li>成员变量有：是否开启日志记录、是否开启异步、日志文件路径、行数、时间、阻塞队列的智能指针、异步写入线程、自定义缓冲区，是否启用异步写入由阻塞队列的大小判断，如果阻塞队列大小不为0就是异步写入；</li><li>写入函数中将日志数据格式化并添加到我们<strong>自定义的缓冲区</strong>对象，若是同步写入就直接将缓存区中数据写入到磁盘日志文件，若是异步写入则调用生产者将其加入到阻塞队列，由写线程调用消费者负责写入到磁盘文件；</li><li>日志的格式用到了可变参数列表，<code>fputs</code>是将字符串写入流，FILE对象标识了要被写入字符串的流，<code>fflush</code>是强制将<strong>系统缓冲区</strong>数据刷新进参数指定的流中，防止数据丢失;</li><li>统一使用宏定义<code>LOG_BASE</code>写日志，宏中由单例模式的<code>instance</code>取得日志类对象实例的引用，再由其调用写入函数；</li><li>日志文件保存在工作目录的log文件夹，文件夹和日志文件如果不存在会自动创建；</li></ul><h2 id="阻塞队列模块"><a href="#阻塞队列模块" class="headerlink" title="阻塞队列模块"></a>阻塞队列模块</h2><ul><li>封装生产者-消费者模式，配合日志模块异步运行时使用；</li><li>对于<strong>生产者-消费者</strong>模型，以多线程为例，生产者线程与消费者线程共享一个缓冲区，其中生产者线程往缓冲区中push内容，消费者线程从缓冲区中pop内容；</li><li>为了实现线程间数据同步，将生产者-消费者模型进行封装，其中<strong>共享缓冲区</strong>采用队列<code>queue&lt;string&gt;</code>实现，称为<strong>阻塞队列</strong>，有最大缓存容量限制；</li><li>使用<strong>互斥量</strong>、<strong>条件变量</strong>(生产者条件变量、消费者条件变量)保证线程安全，工作线程将要写的内容push进队列，写线程从队列中pop出内容，</li><li>类的成员函数中，pop和push函数由Log类中调用，flush函数用于唤醒一个消费者；</li></ul><h2 id="MySQL连接池模块"><a href="#MySQL连接池模块" class="headerlink" title="MySQL连接池模块"></a>MySQL连接池模块</h2><ul><li>类似线程池，在程序初始化时创建多个数据库连接，并把他们集中管理，保证较快的数据库读写速度；</li><li>具体就是工作线程从数据库连接池取得一个连接，访问数据库中的数据，访问完毕后将连接交还连接池；</li><li>本项目中使用局部静态变量懒汉方法<strong>单例模式</strong>和<strong>队列</strong>创建数据库连接池，实现对数据库连接资源的复用；</li><li>项目中的数据库模块分为两部分，其一是数据库连接池的定义，其二是利用连接池完成登录和注册的校验功能，<strong>校验逻辑</strong>其实是在<strong>HTTP解析类</strong>中进行的；</li><li>数据库连接池的功能主要有：初始化、获取连接、释放连接、销毁连接池；</li><li>运用RAII机制封装了一个<code>connRAII</code>类，用于从MySQL连接池取出连接，连接就通过析构函数中自动回池；</li><li>因为连接总数一定且有限，所以使用<strong>互斥量</strong>和<strong>信号量</strong>来同步线程，将信号量初始化为数据库的连接总数；</li><li>每次取出连接使信号量原子减1，释放连接使信号量原子加1，若连接池内没有连接了，则阻塞等待；</li></ul><h2 id="Json解析模块"><a href="#Json解析模块" class="headerlink" title="Json解析模块"></a>Json解析模块</h2><ul><li>自定义简易Json解析模块，读取本地配置文件来初始化服务器；</li><li>详见<a href="https://github.com/zyue2022/lightJson">lightJson</a>;</li></ul><h2 id="WebServer模块"><a href="#WebServer模块" class="headerlink" title="WebServer模块"></a>WebServer模块</h2><ul><li>该模块就是服务器程序的核心模块，联系起各个子功能模块，主线程就是运行它；</li><li>WebServer类中成员变量有：定时器类对象、线程池类对象、Epoller类对象、HTTP连接类对象、本地的监听文件描述符及端口、资源路径；</li><li>操作方法有设置文件描述符非阻塞、设置事件触发模式、初始化本地监听文件描述符(创建、绑定、监听)、设置优雅关闭及端口复用、添加客户端连接到epoll实例、关闭客户端连接、处理连接的读写、设置及调整连接的超时时间等等；</li><li>构造函数中根据传入参数初始化Webserver对象实例，包括初始化监听文件描述符、epoll实例、数据库连接池、线程池、日志系统实例、最小堆定时器、设置好文件描述符的事件触发模式及事件类型；</li><li>事件类型<code>EPOLLONESHOT</code>是为了保证当前连接在同一时刻只被一个线程处理，注册了 EPOLLONESHOT 事件的 socket 一旦被某个线程处理完毕， 还需要重置这个socket 上的 EPOLLONESHOT 事件；</li><li>HTTP连接类对象是装载在哈希表中的，这样可以在有新连接到来时再实例化一个连接对象；</li><li>整体工作逻辑是在循环中监听所有socket上的事件，对不同事件类型做不同处理，同时关闭超时连接；</li></ul><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">举例：客户端请求网页，webserver类工作流程如下<br><span class="hljs-number">1.</span> 检测到读就绪时，调用<span class="hljs-keyword">http</span>连接类的读方法，将请求报文读到读缓冲区；<br><span class="hljs-number">2.</span> 调用<span class="hljs-keyword">http</span>连接类中的处理方法，其中：<br>- <span class="hljs-keyword">http</span>连接类调用自己成员中的<span class="hljs-keyword">http</span>解析类，解析读缓冲区中请求报文；<br>- <span class="hljs-keyword">http</span>连接类调用自己成员中的<span class="hljs-keyword">http</span>响应类，制作响应报文到写缓冲区中，并进行请求资源文件的内存映射；<br>- <span class="hljs-keyword">http</span>连接类向对应文件描述符注册写就绪事件；<br><span class="hljs-number">3.</span> 检测到写就绪，调用<span class="hljs-keyword">http</span>连接类的写方法，将响应报文和内存中映射的资源文件发给客户端；<br></code></pre></td></tr></table></figure><hr><h2 id="参考及致谢"><a href="#参考及致谢" class="headerlink" title="参考及致谢"></a>参考及致谢</h2><ul><li><strong>《Linux高性能服务器编程》游双</strong></li><li><a href="https://www.nowcoder.com/study/live/504">牛客网C++课程 - 项目实战</a></li><li><a href="https://github.com/markparticle/WebServer">@markparticle</a>、<a href="https://github.com/InnovatorZhang/my-WebServer">@InnovatorZhang</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>并发服务器</tag>
      
      <tag>C++11</tag>
      
      <tag>总结</tag>
      
      <tag>项目</tag>
      
      <tag>Json解析</tag>
      
      <tag>线程池</tag>
      
      <tag>MySQL连接池</tag>
      
      <tag>最小堆定时器</tag>
      
      <tag>日志</tag>
      
      <tag>缓冲区</tag>
      
      <tag>Epoll</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++11多线程编程笔记</title>
    <link href="/2022/07/12/C++11%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/07/12/C++11%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="线程创建、启动、结束"><a href="#线程创建、启动、结束" class="headerlink" title="线程创建、启动、结束"></a>线程创建、启动、结束</h2><ul><li>线程类的参数是一个可调用对象，如函数(可以是类中的成员函数)、函数指针、仿函数、lambda表达式、bind创建的对象；</li><li><code>jion()</code> 是阻塞主线程并等待子线程执行完，当子线程执行完毕，join()就执行完毕，主线程继续往下执行，join意为汇合，子线程和主线程回合；</li><li><code>detach()</code> 是线程分离，主线程不再与子线程汇合，不再等待子线程，detach后，子线程和主线程失去关联，驻留在后台，由C++运行时库接管；</li><li><code>joinable()</code>判断是否可以成功使用join()或者detach()，返回true就可以调用，如果返回false，证明调用过join()或者detach()；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">childFunc</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//子线程代码逻辑</span><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//创建子线程，线程执行起点是childFunc，然后执行线程</span><br>    <span class="hljs-function">thread <span class="hljs-title">childThread</span><span class="hljs-params">(childFunc)</span></span>;<br><br>    <span class="hljs-comment">//阻塞主线程并等待子线程执行完毕</span><br>    childThread.<span class="hljs-built_in">join</span>();<br><br>    <span class="hljs-comment">//线程分离，由C++运行时库回收子线程</span><br>    <span class="hljs-comment">//childThread.detach();</span><br><br>    <span class="hljs-keyword">if</span> (childThread.<span class="hljs-built_in">joinable</span>()) &#123;<br>        <span class="hljs-comment">//可以调用可以调用join()或者detach()</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//不能调用可以调用join()或者detach()</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>TODO: 补充如何给子线程传参：类中的成员函数、函数指针、仿函数、lambda表达式、bind创建的对象</p></blockquote><h2 id="mutex互斥量"><a href="#mutex互斥量" class="headerlink" title="mutex互斥量"></a>mutex互斥量</h2><ul><li>互斥量是个类对象，我也称为互斥锁；</li><li>多个线程尝试用lock()成员函数来加锁，只有一个线程能锁定成功；</li><li>如果没有锁成功，那么流程将卡在lock()这里不断尝试去加锁；</li><li>成员函数lock()和unlock()要成对使用；</li><li>使用互斥量少了达不到效果，多了影响效率；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 定义</span><br>mutex mux;<br><br><span class="hljs-comment">// 一般使用步骤</span><br><span class="hljs-number">1.</span>加锁mux.<span class="hljs-built_in">lock</span>();<br><span class="hljs-number">2.</span>操作共享数据<br><span class="hljs-number">3.</span>解锁mux.<span class="hljs-built_in">unlock</span>();<br></code></pre></td></tr></table></figure><h2 id="std-lock-函数模板"><a href="#std-lock-函数模板" class="headerlink" title="std::lock()函数模板"></a>std::lock()函数模板</h2><ul><li><code>std::lock(mutex1,mutex2...); </code>一次锁定多个互斥量（一般这种情况很少），用于处理多个互斥量；</li><li>如果互斥量中某一个没锁住，它就等待所有互斥量都锁住，才能继续执行；</li><li>如果有一个没锁住，就会把已经锁住的释放掉；</li><li>要么互斥量都锁住，要么都没锁住，防止死锁；</li></ul><h2 id="lock-guard类模板"><a href="#lock-guard类模板" class="headerlink" title="lock_guard类模板"></a>lock_guard类模板</h2><ul><li>可以取代使用<code>mux</code>互斥量的lock()和unlock()成员函数；</li><li>lock_guard构造函数执行了mutex::lock()，在作用域结束时，调用析构函数，执行mutex::unlock()；</li><li>所有使用时注意<strong>作用域</strong>范围；</li><li>若使用第二个参数<code>std::adopt_lock</code>，则表示这个互斥量已经lock()，构造时不需要再lock()；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">lock_guard&lt;mutex&gt; <span class="hljs-title">guard</span><span class="hljs-params">(mux)</span></span>;<br><span class="hljs-comment">// 或</span><br><span class="hljs-function">lock_guard&lt;mutex&gt; <span class="hljs-title">guard</span><span class="hljs-params">(mux,adopt_lock)</span></span>;<br></code></pre></td></tr></table></figure><h2 id="unique-lock类模板"><a href="#unique-lock类模板" class="headerlink" title="unique_lock类模板"></a>unique_lock类模板</h2><ul><li>类似lock_guard，但有更多用法；</li><li><strong>无需自己unlock()</strong>;</li><li>其第二个参数有：<br>   1. <code>adopt_lock</code>; 同lock_guard中的，前提是已经lock()；<br>   2. <code>try_to_lock</code>; 尝试用去锁定，如果没有锁定成功，会立即返回，不会阻塞在那里，前提是没有lock()；<br>   3. <code>defer_lock</code>; 初始化一个没有加锁的互斥量mutex，以便后序调用其它方法，前提是没有lock()；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">unique_lock&lt;mutex&gt; <span class="hljs-title">uniLock</span><span class="hljs-params">(mux)</span></span>; <span class="hljs-comment">// 相当于把mux和uniLock绑定在了一起，uniLock拥有mux的所有权</span><br><span class="hljs-comment">// 或</span><br><span class="hljs-function">unique_lock&lt;mutex&gt; <span class="hljs-title">uniLock</span><span class="hljs-params">(myMutex, defer_lock)</span></span>;<br><br>uniLock.<span class="hljs-built_in">lock</span>();   <span class="hljs-comment">// 加锁</span><br>uniLock.<span class="hljs-built_in">unlock</span>(); <span class="hljs-comment">// 解锁</span><br><br><span class="hljs-comment">// 尝试给互斥量加锁，如果拿不到锁，返回false，否则返回true</span><br>uniLock.<span class="hljs-built_in">try_lock</span>(); <br><br><span class="hljs-comment">// 解除绑定，返回它所管理的mutex对象的指针，并释放所有权，所有权由ptx接管</span><br>mutex* ptx = uniLock.<span class="hljs-built_in">release</span>();<br><br><span class="hljs-comment">// uniLock可以把自己对mux的所有权转移，但是不能复制</span><br><span class="hljs-function">unique_lock&lt;mutex&gt; <span class="hljs-title">uniLock2</span><span class="hljs-params">(std::move(uniLock))</span></span>;<br></code></pre></td></tr></table></figure><h2 id="单例类与共享数据"><a href="#单例类与共享数据" class="headerlink" title="单例类与共享数据"></a>单例类与共享数据</h2><p><strong>单例设计模式：</strong> </p><p>定义：单例模式保证一个类仅有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享。</p><p>实现思路：私有化它的构造函数，以防止外界创建单例类的对象；使用类的私有静态指针变量指向类的唯一实例，并用一个公有的静态方法获取该实例。</p><h3 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h3><p>用到的时候再创建，需要锁；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>mutex myMutex;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//双重判断 提高效率</span><br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-function">lock_guard&lt;mutex&gt; <span class="hljs-title">myLockGua</span><span class="hljs-params">(myMutex)</span></span>;<br>            <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">NULL</span>) &#123;<br>                instance = <span class="hljs-keyword">new</span> Singleton;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>    <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Singleton</span>() &#123;&#125;<br>    <span class="hljs-type">static</span> Singleton* instance;<br>&#125;;<br>Singleton* Singleton::instance = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><h3 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h3><p>一开始就创建，所以不需要锁；</p><blockquote><p>饿汉模式的问题在于非静态对象（函数外的static对象）在不同编译单元中的初始化顺序是未定义的。如果在初始化完成之前调用 getInstance() 方法会返回一个未定义的实例。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>mutex myMutex;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton2</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton2* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> instance; &#125;<br>    <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Singleton2</span>() &#123;&#125;<br>    <span class="hljs-type">static</span> Singleton2* instance;<br>&#125;;<br>Singleton2* Singleton2::instance = <span class="hljs-keyword">new</span> Singleton2;<br></code></pre></td></tr></table></figure><h3 id="使用call-once函数模板"><a href="#使用call-once函数模板" class="headerlink" title="使用call_once函数模板"></a>使用<strong>call_once</strong>函数模板</h3><p>参数：第一个参数为标记，第二个参数是一个函数名；<br>功能：能够保证函数只被调用一次，具备互斥量的能力，而且比互斥量消耗的资源更少，更高效。</p><blockquote><p>标记为std::once_flag，call_once()就是通过标记来决定函数是否执行，调用成功后，就把标记设置为一种已调用状态；</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>once_flag g_flag;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//call_once保证其只被调用一次</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">CreateInstance</span><span class="hljs-params">()</span> </span>&#123; instance = <span class="hljs-keyword">new</span> Singleton; &#125;<br><br>    <span class="hljs-comment">//两个线程同时执行到这里，其中一个线程要等另外一个线程执行完毕</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton *<span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-built_in">call_once</span>(g_flag, CreateInstance);<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Singleton</span>() &#123;&#125;<br>    <span class="hljs-type">static</span> Singleton *instance;<br>&#125;;<br>Singleton *Singleton::instance = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><h3 id="借助局部静态对象实现"><a href="#借助局部静态对象实现" class="headerlink" title="借助局部静态对象实现"></a>借助局部静态对象实现</h3><blockquote><p>《Effective C++》（Item 04）中提出一种更优雅的单例模式实现，使用函数内的局部静态对象，这种方法在C++11及之后不用加锁和解锁操作。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">single</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">single</span>() &#123;&#125;<br>    ~<span class="hljs-built_in">single</span>() &#123;&#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> single* <span class="hljs-title">getinstance</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-function">single* <span class="hljs-title">single::getinstance</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">static</span> single obj;<br>    <span class="hljs-keyword">return</span> &amp;obj;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><ul><li><code>std::condition_variable</code>实际上是一个和条件相关的类，就是等待一个条件达成；</li><li>条件变量的作用是阻塞线程，然后等待通知将其唤醒；</li><li>可以通过判断某个函数是否符合某种条件来决定是阻塞线程等待通知还是唤醒线程，由此实现线程间的同步；</li><li>condition_variable的等待函数有三个，分别是wait()——等待、wait_for()——等待一段时间、wait_until()——等待至某一时刻；</li><li>另外针对每个函数condition_variable还提供了有条件等待和无条件等待两种方式；</li><li>如果阻塞，则阻塞到其他某个线程调用<code>notify_one()</code>或<code>notify_all</code>成员函数为止，就被唤醒；</li><li>只要执行到wait后面就一定加锁成功；</li></ul><h3 id="无条件等待"><a href="#无条件等待" class="headerlink" title="无条件等待"></a>无条件等待</h3><ol><li><code>void wait(unique_lock&amp; lck)</code>会无条件的阻塞当前线程然后等待通知，前提是此时对象lck已经成功获取了锁；</li><li>等待(休眠)时会调用lck.unlock()释放锁，使其它线程可以获取锁。一旦得到通知(由其他线程显式地通知)，函数就会释放阻塞并调用lck.lock()，使lck保持与调用函数时相同的状态，然后函数返回；</li><li>wati()函数因为没有条件判断，因此有时候会产生<strong>虚假唤醒</strong>，而有条件的等待可以很好的解决这一问题；</li><li>效果跟有条件等待的第二个参数返回false一样；</li><li>无条件等待被唤醒后wait()不断尝试获取互斥量锁，如果获取不到那么流程就卡在wait()这里等待加锁，当获取到了，wait()就继续执行；</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>std::mutex                   mux;<br><span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">uniLock</span><span class="hljs-params">(mux)</span></span>;<br>std::condition_variable      condition;<br><br>condition.<span class="hljs-built_in">wait</span>(uniLock);<br></code></pre></td></tr></table></figure><h3 id="有条件等待"><a href="#有条件等待" class="headerlink" title="有条件等待"></a>有条件等待</h3><ol><li><code>void wait (unique_lock&amp; lck, Predicate pred)</code>为有条件的等待；</li><li>pred是一个可调用的对象或函数，它不接受任何参数，并返回一个可以作为bool的值；</li><li>当pred为false时wait()函数才会使线程等待(休眠)，在收到其他线程通知时只有当pred返回true时才会被唤醒；</li><li>有条件等待被唤醒后，就判断第二个参数(例如lambda表达式)的值：<ul><li>如果为false，那wait又对互斥量解锁，然后又休眠，等待再次被notify唤醒；</li><li>如果为true，则wait返回，流程可以继续执行（<strong>此时互斥量已被锁住</strong>）；</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br>std::mutex                   mux;<br><span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">uniLock</span><span class="hljs-params">(mux)</span></span>;<br>std::condition_variable      condition;<br><br>condition.<span class="hljs-built_in">wait</span>(uniLock, [<span class="hljs-keyword">this</span>] &#123;<br>    <span class="hljs-comment">// 等待消息队列不为空</span><br>    <span class="hljs-keyword">if</span> (!msgRecvQueue.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;);<br><span class="hljs-comment">// 如果第二个参数的lambda表达式返回值是false，那么wait()将解锁互斥量，并阻塞;</span><br><span class="hljs-comment">// 如果第二个参数的lambda表达式返回值是true，那么wait()直接返回并继续执行;</span><br></code></pre></td></tr></table></figure><h2 id="future类模板"><a href="#future类模板" class="headerlink" title="future类模板"></a>future类模板</h2><ul><li><code>std::future</code>的<code>get()</code>成员函数是<strong>转移</strong>数据，不能多次get；</li><li><code>std::future_status</code> status &#x3D; result.<strong>wait_for</strong>(std::chrono::seconds(几秒)) 可以卡住当前流程，等待std::async()的异步任务运行一段时间，然后返回其状态std::future_status，如果std::async()的参数是std::launch::deferred（延迟执行），则不会卡住主流程；</li><li>std::future_status是枚举类型，表示异步任务的执行状态，取值有std::future_status::timeout、std::future_status::ready、std::future_status::deferred；</li></ul><h3 id="async函数模板"><a href="#async函数模板" class="headerlink" title="async函数模板"></a>async函数模板</h3><ul><li><code>std::async</code>是一个函数模板，用来启动一个异步任务（启动一个异步任务，就是自动创建一个线程，并开始执行对应的线程入口函数）；</li><li>启动一个异步任务之后，async返回一个<code>std::future</code>对象，这个对象是个类模板，这个std::future对象中就含有线程入口函数所返回的结果，可以调用future对象的成员函数get()来获取结果；</li><li>std::future提供了一种访问异步操作结果的机制，可以理解为理解future中保存着一个值，这个值是在将来的某个时刻能够拿到；</li><li>std::future对象的<code>get()</code>成员函数会等待线程执行结束并返回结果，拿不到结果它就会一直等待；</li><li>std::future对象的<code>wait()</code>成员函数，用于等待线程返回，本身并不返回结果，这个效果和 std::thread 的join()更像；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mythread</span><span class="hljs-params">(<span class="hljs-type">int</span> mypar)</span> </span>&#123;<br>        cout &lt;&lt; mypar &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> mypar;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mythread</span><span class="hljs-params">(<span class="hljs-type">int</span> mypar)</span> </span>&#123;<br>cout &lt;&lt; mypar &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;mythread() start&quot;</span> &lt;&lt; <span class="hljs-string">&quot;threadid = &quot;</span> &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() &lt;&lt; endl;<br>std::<span class="hljs-function">chrono::milliseconds <span class="hljs-title">dura</span><span class="hljs-params">(<span class="hljs-number">5000</span>)</span></span>;<br>std::this_thread::<span class="hljs-built_in">sleep_for</span>(dura);<br>cout &lt;&lt; <span class="hljs-string">&quot;mythread() end&quot;</span> &lt;&lt; <span class="hljs-string">&quot;threadid = &quot;</span> &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    A a;<br>    <span class="hljs-type">int</span> tmp = <span class="hljs-number">12</span>;<br><br>    <span class="hljs-comment">//普通函数作为异步任务参数</span><br>    std::future&lt;<span class="hljs-type">int</span>&gt; result1 = std::<span class="hljs-built_in">async</span>(mythread);<br>    cout &lt;&lt; result1.<span class="hljs-built_in">get</span>() &lt;&lt; endl;  <span class="hljs-comment">//卡在这里等待mythread()执行完毕，拿到结果</span><br><br>    <span class="hljs-comment">//类成员函数作为异步任务参数</span><br>    <span class="hljs-comment">//第二个参数是对象引用才能保证线程里执行的是同一个对象</span><br>    std::future&lt;<span class="hljs-type">int</span>&gt; result2 = std::<span class="hljs-built_in">async</span>(&amp;A::mythread, &amp;a, tmp);<br>    cout &lt;&lt; result2.<span class="hljs-built_in">get</span>() &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>参数<code>std::lunch::deferred</code>表示线程入口函数的调用会被延迟，一直到std::future的wait()或者get()函数被调用时（由主线程调用）才会执行，如果wait()或者get()没有被调用，则根本就不会创建新线程执行；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::future&lt;<span class="hljs-type">int</span>&gt; result1 = std::<span class="hljs-built_in">async</span>(std::launch::deferred ,mythread);<br></code></pre></td></tr></table></figure><ul><li>参数<code>std::launch::async</code>，在调用async函数的时候就开始创建新线程;</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::future&lt;<span class="hljs-type">int</span>&gt; result1 = std::<span class="hljs-built_in">async</span>(std::launch::async ,mythread);<br></code></pre></td></tr></table></figure><h3 id="packaged-task类模板"><a href="#packaged-task类模板" class="headerlink" title="packaged_task类模板"></a>packaged_task类模板</h3><ul><li><code>std::packaged_task</code>的模板参数是各种<strong>可调用对象</strong>，通过packaged_task把各种可调用对象包装起来，方便将来作为线程入口函数来调用；</li><li>packaged_task包装起来的可调用对象还可以直接调用，从这个角度来讲，packaged_task对象也是一个可调用对象；</li><li>通过调用<code>get_future()</code>成员函数得到future对象；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mythread</span><span class="hljs-params">(<span class="hljs-type">int</span> mypar)</span> </span>&#123;<br><span class="hljs-comment">// ......</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;main&quot;</span> &lt;&lt; <span class="hljs-string">&quot;threadid = &quot;</span> &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() &lt;&lt; endl;<br><span class="hljs-comment">// 我们把函数mythread通过packaged_task包装起来</span><br>    <span class="hljs-comment">// 参数是一个int，返回值类型是int</span><br>    <span class="hljs-function">std::packaged_task&lt;<span class="hljs-title">int</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>&gt; <span class="hljs-title">mypt</span><span class="hljs-params">(mythread)</span></span>;<br>    <span class="hljs-comment">// t1是线程</span><br><span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(std::ref(mypt), <span class="hljs-number">1</span>)</span></span>;<br>t1.<span class="hljs-built_in">join</span>();<br>    <span class="hljs-comment">// 用std::future对象接收线程入口函数的返回结果</span><br>std::future&lt;<span class="hljs-type">int</span>&gt; result = mypt.<span class="hljs-built_in">get_future</span>(); <br>cout &lt;&lt; result.<span class="hljs-built_in">get</span>() &lt;&lt; endl;<br>   <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 可调用对象可由函数换成lambda表达式</span><br><span class="hljs-function">std::packaged_task&lt;<span class="hljs-title">int</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>&gt; <span class="hljs-title">mypt</span><span class="hljs-params">([](<span class="hljs-type">int</span> mypar) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">    cout &lt;&lt; mypar &lt;&lt; endl;</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-comment">// ......</span></span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;)</span></span>; <br></code></pre></td></tr></table></figure><h3 id="promise类模板"><a href="#promise类模板" class="headerlink" title="promise类模板"></a>promise类模板</h3><ul><li>我们能够在某个线程中给它赋值，然后我们可以在其他线程中，把这个值取出来；</li><li>即通过<code>std::promise</code>保存一个值，在将来某个时刻把一个future绑定到这个promise上，来得到绑定的值;</li><li>通过调用<code>get_future()</code>成员函数得到future对象；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mythread</span><span class="hljs-params">(std::promise&lt;<span class="hljs-type">int</span>&gt; &amp;tmp, <span class="hljs-type">int</span> clac)</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;mythread() start&quot;</span> &lt;&lt; <span class="hljs-string">&quot;threadid = &quot;</span> &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() &lt;&lt; endl;<br>std::<span class="hljs-function">chrono::milliseconds <span class="hljs-title">dura</span><span class="hljs-params">(<span class="hljs-number">5000</span>)</span></span>;<br>std::this_thread::<span class="hljs-built_in">sleep_for</span>(dura);<br>cout &lt;&lt; <span class="hljs-string">&quot;mythread() end&quot;</span> &lt;&lt; <span class="hljs-string">&quot;threadid = &quot;</span> &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() &lt;&lt; endl;<br><span class="hljs-type">int</span> result = clac;<br>tmp.<span class="hljs-built_in">set_value</span>(result); <span class="hljs-comment">//结果保存到了tmp这个对象中</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br> <br>vector&lt;std::packaged_task&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>)&gt;&gt; task_vec;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>std::promise&lt;<span class="hljs-type">int</span>&gt; myprom;<br><span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(mythread, std::ref(myprom), <span class="hljs-number">180</span>)</span></span>;<br>t1.<span class="hljs-built_in">join</span>(); <span class="hljs-comment">//在这里线程已经执行完了</span><br>std::future&lt;<span class="hljs-type">int</span>&gt; fu1 = myprom.<span class="hljs-built_in">get_future</span>(); <span class="hljs-comment">//promise和future绑定，用于获取线程返回值</span><br><span class="hljs-keyword">auto</span> result = fu1.<span class="hljs-built_in">get</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;result = &quot;</span> &lt;&lt; result &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>使用thread时，必须 join() 或者 detach() 否则程序会报异常</p></blockquote><h2 id="shared-future类模板"><a href="#shared-future类模板" class="headerlink" title="shared_future类模板"></a>shared_future类模板</h2><p>std::shared_future 的 get() 成员函数是<strong>复制</strong>数据；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::future&lt;<span class="hljs-type">int</span>&gt; result = mypt.<span class="hljs-built_in">get_future</span>();<br><br> <span class="hljs-comment">//判断future中的值是不是一个有效值</span><br><span class="hljs-type">bool</span> ifcanget = result.<span class="hljs-built_in">valid</span>();<br><br><span class="hljs-comment">//执行完毕后result_s里有值，而result里空了</span><br><span class="hljs-function">std::shared_future&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result_s</span><span class="hljs-params">(result.share())</span></span>; <br><br><span class="hljs-comment">//或通过get_future返回值直接构造一个shared_future对象</span><br><span class="hljs-function">std::shared_future&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result_s</span><span class="hljs-params">(mypt.get_future())</span></span>;<br><br><span class="hljs-comment">// 可以多次get，因为是赋值</span><br><span class="hljs-keyword">auto</span> myresult1 = result_s.<span class="hljs-built_in">get</span>();<br><span class="hljs-keyword">auto</span> myresult2 = result_s.<span class="hljs-built_in">get</span>();<br></code></pre></td></tr></table></figure><h2 id="atomic类模板"><a href="#atomic类模板" class="headerlink" title="atomic类模板"></a>atomic类模板</h2><ul><li>在多线程中，如果想要执行<strong>不会被打断的程序执行片段</strong>，一般需要使用互斥量；</li><li>可以把<code>std::atomic</code><strong>原子操作</strong>理解成一种：不需要用到互斥量加锁的多线程并发编程方式；</li><li>从效率上来说，原子操作要比互斥量的方式效率要高；</li><li>互斥量的加锁一般是针对一个代码段，而原子操作针对的一般都是<strong>一个变量</strong>；</li><li>std::atomic是用来封装某个类型的值，原子操作一般用于计数或者统计；</li><li>原子操作实质上是不允许在进行原子对象操作时进行CPU的上下文切换；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atomic&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>std::atomic&lt;<span class="hljs-type">int</span>&gt; g_count = <span class="hljs-number">0</span>;  <span class="hljs-comment">//封装了一个类型为int的 对象（值）</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mythread1</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000</span>; i++) &#123;<br>        g_count++;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(mythread1)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(mythread1)</span></span>;<br>    t1.<span class="hljs-built_in">join</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br>    cout &lt;&lt; g_count &lt;&lt; endl;  <span class="hljs-comment">//得到2000000</span><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++11</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LRU算法</title>
    <link href="/2022/07/02/LRU%E7%AE%97%E6%B3%95/"/>
    <url>/2022/07/02/LRU%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>一种按时序来淘汰的缓存淘汰策略！！！</p></blockquote><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>LRU的全称是Least Recently Used，即最近最少使用，我们认为最近使用过的数据是有用的，很久没有使用过的数据是无用的，内存满了就先删除那些很久没有用过的数据。</p><ul><li>显然cache里面的元素要有时序，支持快速查找，支持在任意位置插入和删除元素；</li><li>用节点来表示每一个键值对key-value；</li><li>可以结合双向链表与哈希表，链表里面是节点，哈希表存储key及链表中对应的节点；</li><li>双向链表中靠头部元素是最久未使用的，靠尾部元素是最近使用的；</li><li>添加元素时先查看缓存容量，只能从尾部插入；</li><li>若添加新元素时遇到相同key值，只需更新value值和将链表中节点移动到尾部；</li><li>缓存容量不足时从链表头部删除节点，并且删除umap中对应节点；</li><li>访问某元素后要将该节点位置移动到链表尾部；</li><li>umap中节点的变动只发生在添加新节点和缓存容量不够时；</li><li>注意移除与删除列表中节点的区别，移除只是离开链表，删除是销毁这个申请的节点内存；</li></ul><h2 id="自定义双向链表，哈希表存节点"><a href="#自定义双向链表，哈希表存节点" class="headerlink" title="自定义双向链表，哈希表存节点"></a>自定义双向链表，哈希表存节点</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-type">int</span> key, value;<br>    Node* prev;<br>    Node* next;<br>    <span class="hljs-comment">//必须添加下面两个构造函数</span><br>    <span class="hljs-built_in">Node</span>() : <span class="hljs-built_in">key</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">value</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">prev</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>    <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> v) : <span class="hljs-built_in">key</span>(k), <span class="hljs-built_in">value</span>(v), <span class="hljs-built_in">prev</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">NodeList</span> &#123;<br>    Node* head;<br>    Node* tail;<br>    <span class="hljs-built_in">NodeList</span>() &#123;<br>        <span class="hljs-comment">//必须要new</span><br>        head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();<br>        tail = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();<br>        head-&gt;next = tail;<br>        tail-&gt;prev = head;<br>    &#125;<br>    <span class="hljs-comment">//添加节点到链表尾部</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addToTail</span><span class="hljs-params">(Node* node)</span> </span>&#123;<br>        node-&gt;prev = tail-&gt;prev;<br>        tail-&gt;prev-&gt;next = node;<br>        node-&gt;next = tail;<br>        tail-&gt;prev = node;<br>    &#125;<br>    <span class="hljs-comment">//从链表中移除某个节点，前提是这个节点必须存在于链表中</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(Node* node)</span> </span>&#123;<br>        node-&gt;prev-&gt;next = node-&gt;next;<br>        node-&gt;next-&gt;prev = node-&gt;prev;<br>    &#125;<br>    <span class="hljs-comment">//删除链表中最久未使用的节点，即靠近头部的那个节点</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cleanOneCache</span><span class="hljs-params">()</span> </span>&#123;<br>        Node* tmp = head-&gt;next;<br>        <span class="hljs-type">int</span> key = tmp-&gt;key;<br>        <span class="hljs-built_in">remove</span>(tmp);<br>        <span class="hljs-keyword">delete</span> tmp;<br>        <span class="hljs-keyword">return</span> key;<br>    &#125;<br>    <span class="hljs-comment">//使某个被访问的元素到链表尾部</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">makeItRecently</span><span class="hljs-params">(Node* node)</span></span>&#123;<br>        <span class="hljs-built_in">remove</span>(node);<br>        <span class="hljs-built_in">addToTail</span>(node);<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    NodeList list;<br>    unordered_map&lt;<span class="hljs-type">int</span>, Node*&gt; umap;<br>    <span class="hljs-type">int</span> capacity;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">LRUCache</span>(<span class="hljs-type">int</span> cap) &#123;<br>        capacity = cap;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(umap.<span class="hljs-built_in">find</span>(key) == umap.<span class="hljs-built_in">end</span>()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Node* node = umap[key];<br>            <span class="hljs-type">int</span> value = node-&gt;value;<br>            <span class="hljs-comment">//更新链表中节点位置</span><br>            list.<span class="hljs-built_in">makeItRecently</span>(node);<br>            <span class="hljs-keyword">return</span> value;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(umap.<span class="hljs-built_in">find</span>(key) != umap.<span class="hljs-built_in">end</span>()) &#123;<br>            Node* cur = umap[key];<br>            <span class="hljs-comment">//更新节点中的value值</span><br>            cur-&gt;value = value;<br>            <span class="hljs-comment">//更新链表中节点位置</span><br>            list.<span class="hljs-built_in">makeItRecently</span>(cur);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//先查看缓存容量是否充足</span><br>            <span class="hljs-keyword">if</span>(capacity == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>            <span class="hljs-keyword">if</span>(umap.<span class="hljs-built_in">size</span>() == capacity) &#123;<br>                <span class="hljs-type">int</span> k = list.<span class="hljs-built_in">cleanOneCache</span>();<br>                umap.<span class="hljs-built_in">erase</span>(k);<br>            &#125;<br>            <span class="hljs-comment">//添加新节点到链表和umap中</span><br>            Node* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(key, value);<br>            list.<span class="hljs-built_in">addToTail</span>(node);<br>            umap[key] = node;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="使用STL链表，哈希表存迭代器"><a href="#使用STL链表，哈希表存迭代器" class="headerlink" title="使用STL链表，哈希表存迭代器"></a>使用STL链表，哈希表存迭代器</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">LRUCache</span>(<span class="hljs-type">int</span> capacity) : <span class="hljs-built_in">capacity_</span>(capacity) &#123;&#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (umap_.<span class="hljs-built_in">find</span>(key) == umap_.<span class="hljs-built_in">end</span>()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">auto</span> it = umap_[key];<br>        <span class="hljs-type">int</span> val = it-&gt;second;<br>        lruList_.<span class="hljs-built_in">erase</span>(it);<br>        lruList_.<span class="hljs-built_in">emplace_front</span>(key, val);<br>        umap_[key] = lruList_.<span class="hljs-built_in">begin</span>();<br>        <span class="hljs-keyword">return</span> val;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (umap_.<span class="hljs-built_in">find</span>(key) != umap_.<span class="hljs-built_in">end</span>()) &#123;<br>            lruList_.<span class="hljs-built_in">erase</span>(umap_[key]);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (umap_.<span class="hljs-built_in">size</span>() == capacity_) &#123;<br>                umap_.<span class="hljs-built_in">erase</span>(lruList_.<span class="hljs-built_in">back</span>().first);<br>                lruList_.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>        &#125;<br>        lruList_.<span class="hljs-built_in">emplace_front</span>(key, value);<br>        umap_[key] = lruList_.<span class="hljs-built_in">begin</span>();<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    list&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; lruList_; <span class="hljs-comment">// 链表 头部进入 尾部离开</span><br>    unordered_map&lt;<span class="hljs-type">int</span>, list&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;::iterator&gt; umap_;<br>    <span class="hljs-type">int</span> capacity_;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>刷题</tag>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
      <tag>LRU缓存淘汰策略</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/2022/07/02/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>/2022/07/02/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<ul><li>并查集用来表示各节点间的连通关系；</li><li>有些问题可以抽象用并查集来解决；</li><li>节点用数组表示！！！</li></ul><h1 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 连接分量的数目</span><br>    <span class="hljs-type">int</span> count;<br>    <br>    <span class="hljs-comment">// 记录每个节点的父节点</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; parent;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">UnionFind</span>(<span class="hljs-type">int</span> n) : <span class="hljs-built_in">count</span>(n) &#123;<br>        parent.<span class="hljs-built_in">resize</span>(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            parent[i] = i;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Count</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 找到该节点所在树的根节点</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findRoot</span> <span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (x != parent[x]) &#123;<br>            x = parent[x];<br>        &#125;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 连接两个节点</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unionIt</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q)</span> </span>&#123;<br>        <span class="hljs-type">int</span> rootP = <span class="hljs-built_in">findRoot</span>(p);<br>        <span class="hljs-type">int</span> rootQ = <span class="hljs-built_in">findRoot</span>(q);<br>        <span class="hljs-keyword">if</span> (rootP == rootQ) <span class="hljs-keyword">return</span>;<br>        <br>        parent[rootP] = rootQ;<br>        --count;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 确认两个节点是否连接</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isConnected</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q)</span> </span>&#123;<br>        <span class="hljs-type">int</span> rootP = <span class="hljs-built_in">findRoot</span>(p);<br>        <span class="hljs-type">int</span> rootQ = <span class="hljs-built_in">findRoot</span>(q);<br>        <span class="hljs-keyword">return</span> rootP == rootQ;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 连接分量的数目</span><br>    <span class="hljs-type">int</span> count;<br>    <span class="hljs-comment">// 记录每棵树的节点个数</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; size;<br>    <span class="hljs-comment">// 记录每个节点的父节点</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; parent;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">UnionFind</span>(<span class="hljs-type">int</span> n) : <span class="hljs-built_in">count</span>(n) &#123;<br>        parent.<span class="hljs-built_in">resize</span>(n);<br>        size.<span class="hljs-built_in">resize</span>(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            parent[i] = i;<br>            size[i] = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Count</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 找到该节点所在树的根节点</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findRoot</span> <span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (x != parent[x]) &#123;<br>            <span class="hljs-comment">// 路径压缩</span><br>            parent[x] = parent[parent[x]];<br>            x = parent[x];<br>        &#125;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 连接两个节点</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unionIt</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q)</span> </span>&#123;<br>        <span class="hljs-type">int</span> rootP = <span class="hljs-built_in">findRoot</span>(p);<br>        <span class="hljs-type">int</span> rootQ = <span class="hljs-built_in">findRoot</span>(q);<br>        <span class="hljs-keyword">if</span> (rootP == rootQ) <span class="hljs-keyword">return</span>;<br>        <br>        <span class="hljs-comment">// 小树接在大树之下，更平衡</span><br>        <span class="hljs-keyword">if</span> (size[rootP] &gt;= size[rootQ]) &#123;<br>            parent[rootQ] = rootP;<br>            size[rootP] += size[rootQ];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            parent[rootP] = rootQ;<br>            size[rootQ] += size[rootP];<br>        &#125;<br>        --count;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 确认两个节点是否连接</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isConnected</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q)</span> </span>&#123;<br>        <span class="hljs-type">int</span> rootP = <span class="hljs-built_in">findRoot</span>(p);<br>        <span class="hljs-type">int</span> rootQ = <span class="hljs-built_in">findRoot</span>(q);<br>        <span class="hljs-keyword">if</span> (rootP == rootQ) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>刷题</tag>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++后端个人书单</title>
    <link href="/2022/07/01/C++%E5%90%8E%E7%AB%AF%E4%B8%AA%E4%BA%BA%E4%B9%A6%E5%8D%95/"/>
    <url>/2022/07/01/C++%E5%90%8E%E7%AB%AF%E4%B8%AA%E4%BA%BA%E4%B9%A6%E5%8D%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>众所周知，书上的知识密度更大~</p></blockquote><p><img src="/./text_img/book.jpg" alt="技术书籍"></p><table><thead><tr><th align="center"><strong>类别</strong></th><th align="center"><strong>书名</strong></th><th align="center"><strong>作者</strong></th></tr></thead><tbody><tr><td align="center"><strong><em>数学基础</em></strong></td><td align="center">程序员的数学2 概率统计</td><td align="center">[日]平冈和幸</td></tr><tr><td align="center"></td><td align="center">程序员的数学3 线性代数</td><td align="center">[日]平冈和幸</td></tr><tr><td align="center"><strong><em>C++</em></strong></td><td align="center">C++ Primer（中文版 第五版）</td><td align="center">[美]Stanley B. Lippman</td></tr><tr><td align="center"></td><td align="center">Effective C++</td><td align="center">[美]Scott Meyers</td></tr><tr><td align="center"></td><td align="center">More Effective C++</td><td align="center">[美]Scott Meyers</td></tr><tr><td align="center"></td><td align="center">Effective Modern C++</td><td align="center">[美]Scott Meyers</td></tr><tr><td align="center"></td><td align="center">STL源码刨析</td><td align="center">侯捷</td></tr><tr><td align="center"></td><td align="center">深度探索C++对象模型</td><td align="center">[美]Stanley B. Lippman</td></tr><tr><td align="center"><strong><em>数据机构与算法</em></strong></td><td align="center">数据机构与算法分析：C++语言描述（第四版）</td><td align="center">[美]Mark Allen Weiss</td></tr><tr><td align="center"></td><td align="center">算法（第4版）</td><td align="center">[美]Robert Sedgewick</td></tr><tr><td align="center"></td><td align="center">编程珠玑 第2版</td><td align="center">[美]Jon,Bentley</td></tr><tr><td align="center"></td><td align="center">剑指Offer 第2版</td><td align="center">何海涛</td></tr><tr><td align="center"></td><td align="center">labuladong的算法小抄</td><td align="center">付东来</td></tr><tr><td align="center"><strong><em>计算机网络</em></strong></td><td align="center">图解TCP&#x2F;IP 第5版</td><td align="center">[日]竹下隆史</td></tr><tr><td align="center"></td><td align="center">图解HTTP</td><td align="center">[日]上野</td></tr><tr><td align="center"></td><td align="center">计算机网络：自顶向下方法</td><td align="center">[美]James F. kurose</td></tr><tr><td align="center"><strong><em>操作系统</em></strong></td><td align="center">操作系统导论</td><td align="center">[美]Remzi · H.Arpaci-Dusseau</td></tr><tr><td align="center"></td><td align="center">程序员的自我修养 ——链接、转载与库</td><td align="center">俞甲子</td></tr><tr><td align="center"></td><td align="center">鸟哥的Linux私房菜基础学习篇（第四版）</td><td align="center">鸟哥</td></tr><tr><td align="center"></td><td align="center">深入理解计算机系统（原书第3版）</td><td align="center">[美]Randal E. Bryant</td></tr><tr><td align="center"><strong><em>数据库</em></strong></td><td align="center">SQL必知必会 第5版</td><td align="center">[美]Ben,Forta</td></tr><tr><td align="center"></td><td align="center">MySQL是怎样运行的</td><td align="center">小孩子4919</td></tr><tr><td align="center"></td><td align="center">高性能MySQL（第3版）</td><td align="center">Baron Schwartz</td></tr><tr><td align="center"></td><td align="center">MySQL技术内幕：lnnoDB存储引擎（第2版）</td><td align="center">姜承尧</td></tr><tr><td align="center"></td><td align="center">Redis设计与实现</td><td align="center">黄健宏</td></tr><tr><td align="center"><strong><em>设计模式</em></strong></td><td align="center">大话设计模式</td><td align="center">程杰</td></tr><tr><td align="center"><strong><em>网络编程</em></strong></td><td align="center">Linux高性能服务器编程</td><td align="center">游双</td></tr><tr><td align="center"></td><td align="center">linux多线程服务端编程</td><td align="center">陈硕</td></tr><tr><td align="center"><strong><em>应用</em></strong></td><td align="center">数据密集型应用系统设计</td><td align="center">[美]Martin Kleppmann</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>书单</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习路线</tag>
      
      <tag>计算机学习</tag>
      
      <tag>书单</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo常用命令</title>
    <link href="/2022/07/01/hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/07/01/hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="前置安装"><a href="#前置安装" class="headerlink" title="前置安装"></a>前置安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm i -g hexo-cli<br><br>npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 新建一个名为new_post的post</span><br>hexo n new_post<br><br><span class="hljs-comment"># 清楚缓存</span><br>hexo clear<br><br><span class="hljs-comment"># 生成</span><br>hexo g<br><br><span class="hljs-comment"># 发布到本地</span><br>hexo s<br><br><span class="hljs-comment"># 发布到github</span><br>hexo d<br></code></pre></td></tr></table></figure><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 本地发布</span><br>hexo clear &amp;&amp; hexo g &amp;&amp; hexo s<br><br><span class="hljs-comment"># github发布</span><br>hexo clear &amp;&amp; hexo g &amp;&amp; hexo d<br><br><span class="hljs-comment"># 删除文章</span><br>删除 <span class="hljs-string">&quot;sourc/_posts&quot;</span> 文件夹中相应的md文件<br></code></pre></td></tr></table></figure><h2 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h2><p>格式举例如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">title:</span> <span class="hljs-string">C++给常用数据结构传入排序算法</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2022-07-01 16:22:30</span><br><span class="hljs-attr">tags:</span> <br>  <span class="hljs-bullet">-</span> <span class="hljs-string">刷题</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">C++</span><br><span class="hljs-attr">categories:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">C++</span><br><span class="hljs-attr">index_img:</span> <span class="hljs-string">/post_img/02.jpg</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++给常用数据结构传入排序算法</title>
    <link href="/2022/07/01/C++%E7%BB%99%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BC%A0%E5%85%A5%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2022/07/01/C++%E7%BB%99%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BC%A0%E5%85%A5%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>在刷<a href="https://leetcode-cn.com/problems/top-k-frequent-elements/">leetcode347题</a>时，遇到c++自定义操作的知识点，总结如下：</p><h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><p><strong>在类中</strong>定义了如下比较函数(函数对象)，但<strong>定义有序容器时</strong>编译不通过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">myComparison</span><span class="hljs-params">(<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; lhs, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; rhs)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> lhs.second &gt; rhs.second;<br>&#125;<br><br><span class="hljs-comment">// 注意：建堆时，左大于右是小顶堆，与写其它容器排序时相反；</span><br><br>priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;,<br>  <span class="hljs-keyword">decltype</span>(&amp;myComparison)&gt; <span class="hljs-built_in">pri_que</span>(myComparison);<br>或<br>priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;,<br>  <span class="hljs-keyword">decltype</span>(myComparison)*&gt; <span class="hljs-built_in">pri_que</span>(myComparison);<br></code></pre></td></tr></table></figure><p>编译报错如下：</p><blockquote><p>error: reference to non-static member function must be called 即必须调用对非静态成员函数的引用</p></blockquote><h3 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h3><p>所以比较函数定义错误，正确解法如下：</p><h4 id="1-定义为静态成员函数"><a href="#1-定义为静态成员函数" class="headerlink" title="1.定义为静态成员函数"></a>1.定义为静态成员函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">myComparison</span><span class="hljs-params">(<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; lhs, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; rhs)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> lhs.second &gt; rhs.second;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-将比较函数定义在类外面"><a href="#2-将比较函数定义在类外面" class="headerlink" title="2.将比较函数定义在类外面"></a>2.将比较函数定义在类外面</h4><p>注意函数声明在类前。</p><h4 id="3-运用仿函数"><a href="#3-运用仿函数" class="headerlink" title="3.运用仿函数"></a>3.运用仿函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">myComparison</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; lhs, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; rhs)</span> <span class="hljs-type">const</span> </span>&#123;<br><span class="hljs-keyword">return</span> lhs.second &gt; rhs.second;<br>&#125;<br>&#125;;<br><br>priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, myComparison&gt; pri_que;<br></code></pre></td></tr></table></figure><hr><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><h4 id="1-容器的操作自定义处"><a href="#1-容器的操作自定义处" class="headerlink" title="1.容器的操作自定义处"></a>1.容器的操作自定义处</h4><blockquote><p>priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, decltype(myComparison)*&gt; pri_que(myComparison);</p></blockquote><ul><li>为了使用自己定义的操作，在定义容器时必须提供两个类型：<strong>关键字类型</strong>即<code>pair&lt;int, int&gt;</code>，<strong>比较操作类型</strong>即指向myComparison的指针<code>decltype(myComparison)*</code>；</li><li>此处使用<code>decltype</code>指出自定义操作的类型，但当使用decltype来获取一个函数指针类型时，须加上一个<code>*</code>号来表示使用一个给定函数类型的指针；</li><li>定义有序容器时，<code>vector&lt;pair&lt;int, int&gt;&gt;</code>表示<strong>基于vector构造</strong>优先队列；</li><li><code>pri_que(myComparison)</code>表示用myComparison来初始化pri_que对象，即向pri_que添加元素时，调用myComparison来排序；</li><li>用<code>pri_que(myComparison)</code>代替<code>pri_que(&amp;myComparison)</code>因为使用函数名字会自动转化为指针；</li></ul><h4 id="2-比较函数自定义处"><a href="#2-比较函数自定义处" class="headerlink" title="2.比较函数自定义处"></a>2.比较函数自定义处</h4><blockquote><p>return lhs.second &gt; rhs.second;</p></blockquote><ul><li><code>&gt;</code>此比较符号表示在优先队列中左大于右就会建立小顶堆；</li></ul><h3 id="扩展："><a href="#扩展：" class="headerlink" title="扩展："></a>扩展：</h3><h4 id="1-向算法传递函数"><a href="#1-向算法传递函数" class="headerlink" title="1.向算法传递函数"></a>1.向算法传递函数</h4><p>即使用标准库的算法时，传入参数使用自己的操作，示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 升序</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isShorter</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s1, <span class="hljs-type">const</span> string&amp; s2)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> s1.<span class="hljs-built_in">size</span>() &lt; s2.<span class="hljs-built_in">size</span>();<br>&#125;<br><span class="hljs-built_in">sort</span>(words.<span class="hljs-built_in">begin</span>(), words.<span class="hljs-built_in">end</span>(), isShorter);<br></code></pre></td></tr></table></figure><h4 id="2-在算法中使用lambda表达式"><a href="#2-在算法中使用lambda表达式" class="headerlink" title="2.在算法中使用lambda表达式"></a>2.在算法中使用lambda表达式</h4><p>即编写与isShorter函数功能相同的lambda表达式，示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">sort</span>(words.<span class="hljs-built_in">begin</span>(), words.<span class="hljs-built_in">end</span>(),<br>    [](<span class="hljs-type">const</span> string&amp; s1, <span class="hljs-type">const</span> string&amp; s2)<br>     &#123;<span class="hljs-keyword">return</span> s1.<span class="hljs-built_in">size</span>() &lt; s2.<span class="hljs-built_in">size</span>();&#125;);<br></code></pre></td></tr></table></figure><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul><li><a href="https://programmercarl.com/">代码随想录</a>博客</li><li>《C++primer》第五版</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>刷题</tag>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
