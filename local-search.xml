<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>KMP算法</title>
    <link href="/2022/07/23/KMP%E7%AE%97%E6%B3%95/"/>
    <url>/2022/07/23/KMP%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><ul><li>KMP算法用来在<strong>文本串</strong>中匹配<strong>模式串</strong>，查找模式串出现的位置。</li><li>KMP的主要思想是当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。</li><li>需要用到next数组，即前缀表。前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。<ul><li>前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串。</li><li>后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串。</li></ul></li><li>前缀表：<strong>记录下标i之前（包括i）的字符串中，子串(s[0]至s[i])有多大<code>长度</code>的相同长度的前缀、后缀</strong>。</li></ul><h3 id="计算前缀表"><a href="#计算前缀表" class="headerlink" title="计算前缀表"></a>计算前缀表</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// i是后缀末尾，j是前缀末尾</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getNext</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; next, <span class="hljs-type">const</span> string&amp; s)</span> </span>&#123;<br>    <span class="hljs-type">int</span> j   = <span class="hljs-number">0</span>;<br>    next[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// j指向前缀末尾位置，i指向后缀末尾位置</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; s[i] != s[j]) &#123;<br>            j = next[j - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (s[i] == s[j]) &#123;<br>            ++j;<br>        &#125;<br>        next[i] = j;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a>字符串匹配</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">strStr</span><span class="hljs-params">(string haystack, string needle)</span> </span>&#123;<br>    <span class="hljs-type">int</span> m = haystack.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> n = needle.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span> || n &gt; m) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">next</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-built_in">getNext</span>(next, needle);<br><br>    <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// j 是模式串的下标，i 是文本串的下标</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>        <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; haystack[i] != needle[j]) &#123;<br>            <span class="hljs-comment">// 遇到不匹配字符时，跳转到前一个字符的前缀表的记录位置</span><br>            j = next[j - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (haystack[i] == needle[j]) &#123;<br>            <span class="hljs-comment">// 字符匹配</span><br>            ++j;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (j == n) &#123;<br>            <span class="hljs-keyword">return</span> i - n + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-comment">// 可发现匹配过程与创建前缀表的过程相似</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string s1 = <span class="hljs-string">&quot;aabaabaafa&quot;</span>;<br>    string s2 = <span class="hljs-string">&quot;aabaaf&quot;</span>;<br>    cout &lt;&lt; <span class="hljs-built_in">strStr</span>(s1, s2) &lt;&lt; endl;<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h3><p><a href="https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC">代码随想录</a>、<a href="https://leetcode.cn/problems/implement-strstr/">LeetCode 28题</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高性能并发Web服务器</title>
    <link href="/2022/07/18/%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91Web%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2022/07/18/%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91Web%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="WebServer"><a href="#WebServer" class="headerlink" title="WebServer"></a>WebServer</h2><p>高性能并发服务器，由<code>webbench</code>测试可达到上万QPS；</p><p><strong>【关键词】</strong></p><p><strong>C++11、IO多路复用技术Epoll、Reactor高并发模型、线程池、异步日志系统、最小堆定时器、数据库连接池、有限状态机、自增长缓冲区、单例模式、自定义Json解析器</strong></p><hr><ul><li><a href="#webserver">WebServer</a></li><li><a href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B">工作流程</a><ul><li><a href="#%E6%B5%81%E7%A8%8B%E5%9B%BE">流程图</a></li></ul></li><li><a href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%A8%A1%E5%9D%97">线程池模块</a></li><li><a href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E6%A8%A1%E5%9D%97">缓冲区模块</a></li><li><a href="#epoll%E6%A8%A1%E5%9D%97">Epoll模块</a></li><li><a href="#http%E8%BF%9E%E6%8E%A5%E6%A8%A1%E5%9D%97">HTTP连接模块</a></li><li><a href="#http%E8%A7%A3%E6%9E%90%E6%A8%A1%E5%9D%97">HTTP解析模块</a></li><li><a href="#http%E5%93%8D%E5%BA%94%E6%A8%A1%E5%9D%97">HTTP响应模块</a></li><li><a href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E6%A8%A1%E5%9D%97">定时器模块</a></li><li><a href="#%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97">日志模块</a></li><li><a href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E6%A8%A1%E5%9D%97">阻塞队列模块</a></li><li><a href="#mysql%E8%BF%9E%E6%8E%A5%E6%B1%A0%E6%A8%A1%E5%9D%97">MySQL连接池模块</a></li><li><a href="#json%E8%A7%A3%E6%9E%90%E6%A8%A1%E5%9D%97">Json解析模块</a></li><li><a href="#webserver%E6%A8%A1%E5%9D%97">WebServer模块</a></li><li><a href="#%E5%8F%82%E8%80%83%E5%8F%8A%E8%87%B4%E8%B0%A2">参考及致谢</a></li></ul><hr><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><ol><li>本服务器项目采用的是<strong>同步I&#x2F;O</strong>(<code>epoll_wait</code>)实现<code>Reactor</code>事件处理模式；</li><li>主线程负责监听文件描述符上是否有事件发生、接受新连接，工作线程负责读写数据，处理客户请求；</li><li>工作流程是：主线程往 epoll 内核事件表中注册 <strong>监听socket</strong> 上的读就绪事件，而后调用 epoll_wait 等待 socket 上的事件发生，如下是可能事件类型：</li></ol><ul><li><p>若是新连接，主线程就往 epoll 内核事件表中注册该 socket 上的读就绪事件；</p></li><li><p>socket 上是错误事件时，主线程就关闭该连接；</p></li><li><p>socket 上是读事件时， 主线程则将<strong>读任务</strong>放入任务队列，睡眠在请求队列上的某个工作线程被唤醒，它从 socket 读取数据，并处理客户请求(解析HTTP报文，生成HTTP响应)，然后往 epoll 内核事件表中注册该 socket 上的写就绪事件；</p></li><li><p>socket上是写事件时，主线程将<strong>写任务</strong>放入任务队列，睡眠在请求队列上的某个工作线程被唤醒，它往 socket 上写入响应报文，若是长连接就再次注册该 socket 上的读就绪事件，否则关闭连接；</p></li></ul><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img src="/./post_img/flowchart.jpg"></p><hr><h2 id="线程池模块"><a href="#线程池模块" class="headerlink" title="线程池模块"></a>线程池模块</h2><ul><li>池是一组资源的集合，服务器事先初始化好一组线程，即创建好线程池，这称为静态资源；</li><li>当服务器运行的时候，需要处理时就从池中取出一个线程，用完后还回去，无需动态申请和销毁资源，是一种以空间换时间的概念；</li><li>在构造函数中创建一组线程，用<strong>lambda表达式</strong>这种可调用对象作为子线程的工作函数，并设置<strong>线程分离</strong>；</li><li>使用<strong>互斥量</strong>和<strong>条件变量</strong>保证线程同步，需要运行的任务装载在一个队列中，即<strong>任务队列</strong>；</li><li>任务就是<strong>函数模板对象</strong>，类中有一个加入任务的模板成员函数<code>addTask</code>，每加入一个任务，唤醒一个线程；</li><li>子线程的工作逻辑其实就是从任务队列中取出任务然后执行它，若队列为空就休眠等待直到被唤醒；</li><li>还可以拓展的是：添加一个容器来装载各子线程、限制任务队列中最大任务数量；</li></ul><h2 id="缓冲区模块"><a href="#缓冲区模块" class="headerlink" title="缓冲区模块"></a>缓冲区模块</h2><ul><li>利用<code>vector&lt;char&gt;</code>实现的动态增长的缓冲区，用来保存数据以及读写数据；</li><li>一个缓冲区对象主要包括3个部分：已读取段、未读取段、未写入段；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">  已读取段    未读取段  未写入段<br>缓冲区：++++++++++++++-------------xxxxxxxxxxxxx<br>     ^  ^   ^<br>       读指针  写指针   容器结尾处<br></code></pre></td></tr></table></figure><ul><li>自动扩容机制是比较即将写入缓存的数据大小是否小于<strong>已读段加上未写段</strong>的大小，如果满足则将<strong>未读段</strong>移动到最左边，否则重新申请更大的内存；</li><li>缓冲区从<code>sockfd</code>读取数据时采用<strong>分散读</strong><code>readv</code>的方式，一块是指向当前缓冲区，另一块是辅助字符串防止缓冲区装不下，如果装不下后序再扩容缓冲区，然后合并到缓冲区中；</li><li>缓冲区往<code>sockfd</code>发送数据时直接调用<code>write</code>写入当前缓冲区中<strong>未读取段</strong>的数据；</li><li>缓冲区对应操作有：读取数据、返回读写位置、返回各个段信息、写入数据；</li></ul><h2 id="Epoll模块"><a href="#Epoll模块" class="headerlink" title="Epoll模块"></a>Epoll模块</h2><ul><li>用于初始化<code>epoll</code>实例，便于管理；</li><li>功能是在epoll实例中增、删、改socket文件描述符及其监听事件类型；</li></ul><h2 id="HTTP连接模块"><a href="#HTTP连接模块" class="headerlink" title="HTTP连接模块"></a>HTTP连接模块</h2><ul><li>每个HTTP连接对象表示一个客户端连接的各种<strong>属性</strong>，及其操作方法(<strong>读、处理、写</strong>)；</li><li>静态成员变量有：连接用户数、资源目录、epoll触发模式；</li><li>其它成员变量是：连接地址信息、socket文件描述符、连接是否关闭、读写缓冲区(自定义的buffer对象)、HTTP解析类对象、HTTP响应类对象；</li><li>主要操作方法有：初始化每个客户端连接、接收请求信息、发送响应信息、关闭连接；</li><li>简而言之，HTTP连接类对象就是用来接收请求然后回送响应，请求的解析和响应的生成是交给解析类对象和响应类对象去执行的；</li><li>读取请求数据是直接read客户端连接的socket文件描述符，读到<strong>读缓冲区</strong>里面；</li><li>请求的解析是调用解析类对象的成员函数，解析结果交给响应类对象去制作响应报文；</li><li>发送响应数据是采用<strong>聚集写</strong><code>writev</code>的方式，在一次函数调用中写多个非连续缓冲区，并且再循环里面调整区块一与区块二的基址和长度，区块一对应<strong>写缓冲区</strong>，区块二对应客户端请求的<strong>资源文件</strong>，区块的基址及长度由响应类对象的返回结果配置；</li></ul><h2 id="HTTP解析模块"><a href="#HTTP解析模块" class="headerlink" title="HTTP解析模块"></a>HTTP解析模块</h2><ul><li>HTTP解析类对象用来解析<strong>读缓冲区</strong>中的HTTP请求报文，支持解析GET和POST请求；</li><li>采用了<strong>正则表达式</strong>和<strong>有限状态机</strong>来解析；</li><li>有限状态机是逻辑单元内部的一种高效编程方法，报文的每种数据类型字段可以映射为逻辑单元的一种执行状态，可以根据它来编写相应的解析逻辑，并转移到相应状态继续解析；</li><li>一个类对象包含：当前解析状态(枚举变量)、协议版本、HTTP请求方法(GET或POST)、请求资源路径、请求头、请求体、是否长连接等等；</li><li>请求体和请求体的信息采用<strong>有序容器</strong><code>&lt;key:string, value:string&gt;</code>记录；</li><li>一个客户端连接可能有多次请求(<strong>长连接</strong>)，所以需要保存上次解析状态，用以指示是否为新的HTTP请求，当上一次的请求为完成状态时，会再次初始化解析类对象，以重新开始解析一个HTTP请求；</li><li>如果是GET请求，就不会解析<strong>请求体</strong>，如果是POST请求，还要从请求体中解析出账户与密码，然后MySQL连接池取出一个连接，调用API执行SQL语句，分别处理登录和注册的情况；</li><li>解析类对象中成员函数由HTTP连接类对象调用，读缓冲区作为主体解析函数的引用形式的形参传入；</li></ul><h2 id="HTTP响应模块"><a href="#HTTP响应模块" class="headerlink" title="HTTP响应模块"></a>HTTP响应模块</h2><ul><li>HTTP响应类对象负责根据解析结果，拼接响应报文到<strong>写缓冲区</strong>中；</li><li>使用了<strong>哈希表</strong>方便组装需要返回的状态码、头部字段信息；</li><li>成员变量有：请求资源文件(发送文件)的路径、是否长连接、状态码、内存映射区、文件信息；</li><li>操作方法有：往写缓冲区添加状态行、报文头部、报文正文(资源文件)；</li><li>资源文件通过<strong>内存映射</strong>方法映射到内存中，提高速度，当然会检查文件是否存在以及权限；</li><li>响应类对象中成员函数也由HTTP连接类对象调用，写缓冲区作为响应制作函数的引用形式的形参传入，如果有请求资源文件，还会返回文件映射在内存中的地址给连接类对象；</li></ul><h2 id="定时器模块"><a href="#定时器模块" class="headerlink" title="定时器模块"></a>定时器模块</h2><ul><li>每个连接对应一个<code>TimeNodo</code>节点，里面封装了超时时间、回调函数等信息；</li><li>采用最小堆数据结构管理所有连接的超时信息，即维护一个<strong>最小堆定时器</strong>；</li><li>最小堆是采用<code>vertor&lt;TimeNode&gt;</code>数组实现的，堆顶元素就是最先超时的连接；</li><li>数组下标从0开始，0下标即对应堆顶节点，对于堆中某一节点，令它在数组中下标为<code>k</code>，则左子节点为<code>2*k + 1</code>，右子节点为<code>2*k + 2</code>，父节点为<code>(k - 1) / 2</code>；</li><li>插入节点时，插入到数组中的最后一个节点的后面，然后与该节点的父节点比较大小，如果插入的元素小于父节点元素，那么与父节点交换位置。重复上述步骤直到大于父节点元素或者到达堆顶。该过程叫做<strong>上浮</strong>，即插入时上浮；</li><li>移除节点时，将该节点与末尾节点交换，然后当前节点(之前的尾部节点)与子节点中的较小者比较，如果当前节点大于较小子节点，那么与较小子节点交换位置，重复上述步骤直到小于较小子节点或者到达倒数第二个节点为止。最后再删除末尾节点。该过程叫做<strong>下沉</strong>，即移除元素时下沉;</li><li>最小堆定时器的操作有：添加节点、删除所有超时节点(断开超时连接)、调整节点的过期时间；</li></ul><h2 id="日志模块"><a href="#日志模块" class="headerlink" title="日志模块"></a>日志模块</h2><ul><li>日志模块用于同步或异步记录服务器运行信息，具有按天分类，超行分类功能；</li><li><strong>同步日志</strong>是日志写入函数与工作线程串行执行，由于涉及到I&#x2F;O操作，当单条日志比较大的时候，同步模式会阻塞整个处理流程，服务器的并发能力将有所下降；</li><li><strong>异步日志</strong>是将所写的日志内容先存入阻塞队列，写线程从阻塞队列中取出内容，写入日志；</li><li>异步日志用到了<strong>阻塞队列</strong>，还有<strong>单例模式</strong>，保证日志类对象只有一个实例对象，采用<strong>局部静态变量懒汉模式</strong>的方法实现；</li><li>日志有4个级别可选，分别是DEBUG、INFO、WARN、ERROR，分别对应级别0~3，比如设置级别为0时每个级别的信息都记录，设置为3时只记录错误信息；</li><li>成员变量有：是否开启日志记录、是否开启异步、日志文件路径、行数、时间、阻塞队列的智能指针、异步写入线程、自定义缓冲区，是否启用异步写入由阻塞队列的大小判断，如果阻塞队列大小不为0就是异步写入；</li><li>写入函数中将日志数据格式化并添加到我们<strong>自定义的缓冲区</strong>对象，若是同步写入就直接将缓存区中数据写入到磁盘日志文件，若是异步写入则调用生产者将其加入到阻塞队列，由写线程调用消费者负责写入到磁盘文件；</li><li>日志的格式用到了可变参数列表，<code>fputs</code>是将字符串写入流，FILE对象标识了要被写入字符串的流，<code>fflush</code>是强制将<strong>系统缓冲区</strong>数据刷新进参数指定的流中，防止数据丢失;</li><li>统一使用宏定义<code>LOG_BASE</code>写日志，宏中由单例模式的<code>instance</code>取得日志类对象实例的引用，再由其调用写入函数；</li><li>日志文件保存在工作目录的log文件夹，文件夹和日志文件如果不存在会自动创建；</li></ul><h2 id="阻塞队列模块"><a href="#阻塞队列模块" class="headerlink" title="阻塞队列模块"></a>阻塞队列模块</h2><ul><li>封装生产者-消费者模式，配合日志模块异步运行时使用；</li><li>对于<strong>生产者-消费者</strong>模型，以多线程为例，生产者线程与消费者线程共享一个缓冲区，其中生产者线程往缓冲区中push内容，消费者线程从缓冲区中pop内容；</li><li>为了实现线程间数据同步，将生产者-消费者模型进行封装，其中<strong>共享缓冲区</strong>采用队列<code>queue&lt;string&gt;</code>实现，称为<strong>阻塞队列</strong>，有最大缓存容量限制；</li><li>使用<strong>互斥量</strong>、<strong>条件变量</strong>(生产者条件变量、消费者条件变量)保证线程安全，工作线程将要写的内容push进队列，写线程从队列中pop出内容，</li><li>类的成员函数中，pop和push函数由Log类中调用，flush函数用于唤醒一个消费者；</li></ul><h2 id="MySQL连接池模块"><a href="#MySQL连接池模块" class="headerlink" title="MySQL连接池模块"></a>MySQL连接池模块</h2><ul><li>类似线程池，在程序初始化时创建多个数据库连接，并把他们集中管理，保证较快的数据库读写速度；</li><li>具体就是工作线程从数据库连接池取得一个连接，访问数据库中的数据，访问完毕后将连接交还连接池；</li><li>本项目中使用局部静态变量懒汉方法<strong>单例模式</strong>和<strong>队列</strong>创建数据库连接池，实现对数据库连接资源的复用；</li><li>项目中的数据库模块分为两部分，其一是数据库连接池的定义，其二是利用连接池完成登录和注册的校验功能，<strong>校验逻辑</strong>其实是在<strong>HTTP解析类</strong>中进行的；</li><li>数据库连接池的功能主要有：初始化、获取连接、释放连接、销毁连接池；</li><li>运用RAII机制封装了一个<code>connRAII</code>类，用于从MySQL连接池取出连接，连接就通过析构函数中自动回池；</li><li>因为连接总数一定且有限，所以使用<strong>互斥量</strong>和<strong>信号量</strong>来同步线程，将信号量初始化为数据库的连接总数；</li><li>每次取出连接使信号量原子减1，释放连接使信号量原子加1，若连接池内没有连接了，则阻塞等待；</li></ul><h2 id="Json解析模块"><a href="#Json解析模块" class="headerlink" title="Json解析模块"></a>Json解析模块</h2><ul><li>自定义简易Json解析模块，读取本地配置文件来初始化服务器；</li><li>详见<a href="https://github.com/zyue2022/lightJson">lightJson</a>;</li></ul><h2 id="WebServer模块"><a href="#WebServer模块" class="headerlink" title="WebServer模块"></a>WebServer模块</h2><ul><li>该模块就是服务器程序的核心模块，联系起各个子功能模块，主线程就是运行它；</li><li>WebServer类中成员变量有：定时器类对象、线程池类对象、Epoller类对象、HTTP连接类对象、本地的监听文件描述符及端口、资源路径；</li><li>操作方法有设置文件描述符非阻塞、设置事件触发模式、初始化本地监听文件描述符(创建、绑定、监听)、设置优雅关闭及端口复用、添加客户端连接到epoll实例、关闭客户端连接、处理连接的读写、设置及调整连接的超时时间等等；</li><li>构造函数中根据传入参数初始化Webserver对象实例，包括初始化监听文件描述符、epoll实例、数据库连接池、线程池、日志系统实例、最小堆定时器、设置好文件描述符的事件触发模式及事件类型；</li><li>事件类型<code>EPOLLONESHOT</code>是为了保证当前连接在同一时刻只被一个线程处理，注册了 EPOLLONESHOT 事件的 socket 一旦被某个线程处理完毕， 还需要重置这个socket 上的 EPOLLONESHOT 事件；</li><li>HTTP连接类对象是装载在哈希表中的，这样可以在有新连接到来时再实例化一个连接对象；</li><li>整体工作逻辑是在循环中监听所有socket上的事件，对不同事件类型做不同处理，同时关闭超时连接；</li></ul><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">举例：客户端请求网页，webserver类工作流程如下<br><span class="hljs-number">1.</span> 检测到读就绪时，调用<span class="hljs-keyword">http</span>连接类的读方法，将请求报文读到读缓冲区；<br><span class="hljs-number">2.</span> 调用<span class="hljs-keyword">http</span>连接类中的处理方法，其中：<br>- <span class="hljs-keyword">http</span>连接类调用自己成员中的<span class="hljs-keyword">http</span>解析类，解析读缓冲区中请求报文；<br>- <span class="hljs-keyword">http</span>连接类调用自己成员中的<span class="hljs-keyword">http</span>响应类，制作响应报文到写缓冲区中，并进行请求资源文件的内存映射；<br>- <span class="hljs-keyword">http</span>连接类向对应文件描述符注册写就绪事件；<br><span class="hljs-number">3.</span> 检测到写就绪，调用<span class="hljs-keyword">http</span>连接类的写方法，将响应报文和内存中映射的资源文件发给客户端；<br></code></pre></td></tr></table></figure><hr><h2 id="参考及致谢"><a href="#参考及致谢" class="headerlink" title="参考及致谢"></a>参考及致谢</h2><ul><li><strong>《Linux高性能服务器编程》游双</strong></li><li><a href="https://www.nowcoder.com/study/live/504">牛客网C++课程 - 项目实战</a></li><li><a href="https://github.com/markparticle/WebServer">@markparticle</a>、<a href="https://github.com/InnovatorZhang/my-WebServer">@InnovatorZhang</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>并发服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++11多线程编程笔记</title>
    <link href="/2022/07/12/C++11%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/07/12/C++11%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="线程创建、启动、结束"><a href="#线程创建、启动、结束" class="headerlink" title="线程创建、启动、结束"></a>线程创建、启动、结束</h2><ul><li>线程类的参数是一个可调用对象，如函数(可以是类中的成员函数)、函数指针、仿函数、lambda表达式、bind创建的对象；</li><li><code>jion()</code> 是阻塞主线程并等待子线程执行完，当子线程执行完毕，join()就执行完毕，主线程继续往下执行，join意为汇合，子线程和主线程回合；</li><li><code>detach()</code> 是线程分离，主线程不再与子线程汇合，不再等待子线程，detach后，子线程和主线程失去关联，驻留在后台，由C++运行时库接管；</li><li><code>joinable()</code>判断是否可以成功使用join()或者detach()，返回true就可以调用，如果返回false，证明调用过join()或者detach()；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">childFunc</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//子线程代码逻辑</span><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//创建子线程，线程执行起点是childFunc，然后执行线程</span><br>    <span class="hljs-function">thread <span class="hljs-title">childThread</span><span class="hljs-params">(childFunc)</span></span>;<br><br>    <span class="hljs-comment">//阻塞主线程并等待子线程执行完毕</span><br>    childThread.<span class="hljs-built_in">join</span>();<br><br>    <span class="hljs-comment">//线程分离，由C++运行时库回收子线程</span><br>    <span class="hljs-comment">//childThread.detach();</span><br><br>    <span class="hljs-keyword">if</span> (childThread.<span class="hljs-built_in">joinable</span>()) &#123;<br>        <span class="hljs-comment">//可以调用可以调用join()或者detach()</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//不能调用可以调用join()或者detach()</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>TODO: 补充如何给子线程传参：类中的成员函数、函数指针、仿函数、lambda表达式、bind创建的对象</p></blockquote><h2 id="mutex互斥量"><a href="#mutex互斥量" class="headerlink" title="mutex互斥量"></a>mutex互斥量</h2><ul><li>互斥量是个类对象，我也称为互斥锁；</li><li>多个线程尝试用lock()成员函数来加锁，只有一个线程能锁定成功；</li><li>如果没有锁成功，那么流程将卡在lock()这里不断尝试去加锁；</li><li>成员函数lock()和unlock()要成对使用；</li><li>使用互斥量少了达不到效果，多了影响效率；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 定义</span><br>mutex mux;<br><br><span class="hljs-comment">// 一般使用步骤</span><br><span class="hljs-number">1.</span>加锁mux.<span class="hljs-built_in">lock</span>();<br><span class="hljs-number">2.</span>操作共享数据<br><span class="hljs-number">3.</span>解锁mux.<span class="hljs-built_in">unlock</span>();<br></code></pre></td></tr></table></figure><h2 id="std-lock-函数模板"><a href="#std-lock-函数模板" class="headerlink" title="std::lock()函数模板"></a>std::lock()函数模板</h2><ul><li><code>std::lock(mutex1,mutex2...); </code>一次锁定多个互斥量（一般这种情况很少），用于处理多个互斥量；</li><li>如果互斥量中某一个没锁住，它就等待所有互斥量都锁住，才能继续执行；</li><li>如果有一个没锁住，就会把已经锁住的释放掉；</li><li>要么互斥量都锁住，要么都没锁住，防止死锁；</li></ul><h2 id="lock-guard类模板"><a href="#lock-guard类模板" class="headerlink" title="lock_guard类模板"></a>lock_guard类模板</h2><ul><li>可以取代使用<code>mux</code>互斥量的lock()和unlock()成员函数；</li><li>lock_guard构造函数执行了mutex::lock()，在作用域结束时，调用析构函数，执行mutex::unlock()；</li><li>所有使用时注意<strong>作用域</strong>范围；</li><li>若使用第二个参数<code>std::adopt_lock</code>，则表示这个互斥量已经lock()，构造时不需要再lock()；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">lock_guard&lt;mutex&gt; <span class="hljs-title">guard</span><span class="hljs-params">(mux)</span></span>;<br><span class="hljs-comment">// 或</span><br><span class="hljs-function">lock_guard&lt;mutex&gt; <span class="hljs-title">guard</span><span class="hljs-params">(mux,adopt_lock)</span></span>;<br></code></pre></td></tr></table></figure><h2 id="unique-lock类模板"><a href="#unique-lock类模板" class="headerlink" title="unique_lock类模板"></a>unique_lock类模板</h2><ul><li>类似lock_guard，但有更多用法；</li><li><strong>无需自己unlock()</strong>;</li><li>其第二个参数有：<br>   1. <code>adopt_lock</code>; 同lock_guard中的，前提是已经lock()；<br>   2. <code>try_to_lock</code>; 尝试用去锁定，如果没有锁定成功，会立即返回，不会阻塞在那里，前提是没有lock()；<br>   3. <code>defer_lock</code>; 初始化一个没有加锁的互斥量mutex，以便后序调用其它方法，前提是没有lock()；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">unique_lock&lt;mutex&gt; <span class="hljs-title">uniLock</span><span class="hljs-params">(mux)</span></span>; <span class="hljs-comment">// 相当于把mux和uniLock绑定在了一起，uniLock拥有mux的所有权</span><br><span class="hljs-comment">// 或</span><br><span class="hljs-function">unique_lock&lt;mutex&gt; <span class="hljs-title">uniLock</span><span class="hljs-params">(myMutex, defer_lock)</span></span>;<br><br>uniLock.<span class="hljs-built_in">lock</span>();   <span class="hljs-comment">// 加锁</span><br>uniLock.<span class="hljs-built_in">unlock</span>(); <span class="hljs-comment">// 解锁</span><br><br><span class="hljs-comment">// 尝试给互斥量加锁，如果拿不到锁，返回false，否则返回true</span><br>uniLock.<span class="hljs-built_in">try_lock</span>(); <br><br><span class="hljs-comment">// 解除绑定，返回它所管理的mutex对象的指针，并释放所有权，所有权由ptx接管</span><br>mutex* ptx = uniLock.<span class="hljs-built_in">release</span>();<br><br><span class="hljs-comment">// uniLock可以把自己对mux的所有权转移，但是不能复制</span><br><span class="hljs-function">unique_lock&lt;mutex&gt; <span class="hljs-title">uniLock2</span><span class="hljs-params">(std::move(uniLock))</span></span>;<br></code></pre></td></tr></table></figure><h2 id="单例类与共享数据"><a href="#单例类与共享数据" class="headerlink" title="单例类与共享数据"></a>单例类与共享数据</h2><p><strong>单例设计模式：</strong> </p><p>定义：单例模式保证一个类仅有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享。</p><p>实现思路：私有化它的构造函数，以防止外界创建单例类的对象；使用类的私有静态指针变量指向类的唯一实例，并用一个公有的静态方法获取该实例。</p><h3 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h3><p>用到的时候再创建，需要锁；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>mutex myMutex;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//双重判断 提高效率</span><br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-function">lock_guard&lt;mutex&gt; <span class="hljs-title">myLockGua</span><span class="hljs-params">(myMutex)</span></span>;<br>            <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">NULL</span>) &#123;<br>                instance = <span class="hljs-keyword">new</span> Singleton;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>    <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Singleton</span>() &#123;&#125;<br>    <span class="hljs-type">static</span> Singleton* instance;<br>&#125;;<br>Singleton* Singleton::instance = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><h3 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h3><p>一开始就创建，所以不需要锁；</p><blockquote><p>饿汉模式的问题在于非静态对象（函数外的static对象）在不同编译单元中的初始化顺序是未定义的。如果在初始化完成之前调用 getInstance() 方法会返回一个未定义的实例。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>mutex myMutex;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton2</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton2* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> instance; &#125;<br>    <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Singleton2</span>() &#123;&#125;<br>    <span class="hljs-type">static</span> Singleton2* instance;<br>&#125;;<br>Singleton2* Singleton2::instance = <span class="hljs-keyword">new</span> Singleton2;<br></code></pre></td></tr></table></figure><h3 id="使用call-once函数模板"><a href="#使用call-once函数模板" class="headerlink" title="使用call_once函数模板"></a>使用<strong>call_once</strong>函数模板</h3><p>参数：第一个参数为标记，第二个参数是一个函数名；<br>功能：能够保证函数只被调用一次，具备互斥量的能力，而且比互斥量消耗的资源更少，更高效。</p><blockquote><p>标记为std::once_flag，call_once()就是通过标记来决定函数是否执行，调用成功后，就把标记设置为一种已调用状态；</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>once_flag g_flag;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//call_once保证其只被调用一次</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">CreateInstance</span><span class="hljs-params">()</span> </span>&#123; instance = <span class="hljs-keyword">new</span> Singleton; &#125;<br><br>    <span class="hljs-comment">//两个线程同时执行到这里，其中一个线程要等另外一个线程执行完毕</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton *<span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-built_in">call_once</span>(g_flag, CreateInstance);<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Singleton</span>() &#123;&#125;<br>    <span class="hljs-type">static</span> Singleton *instance;<br>&#125;;<br>Singleton *Singleton::instance = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><h3 id="借助局部静态对象实现"><a href="#借助局部静态对象实现" class="headerlink" title="借助局部静态对象实现"></a>借助局部静态对象实现</h3><blockquote><p>《Effective C++》（Item 04）中提出一种更优雅的单例模式实现，使用函数内的局部静态对象，这种方法在C++11及之后不用加锁和解锁操作。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">single</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">single</span>() &#123;&#125;<br>    ~<span class="hljs-built_in">single</span>() &#123;&#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> single* <span class="hljs-title">getinstance</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-function">single* <span class="hljs-title">single::getinstance</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">static</span> single obj;<br>    <span class="hljs-keyword">return</span> &amp;obj;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><ul><li><code>std::condition_variable</code>实际上是一个和条件相关的类，就是等待一个条件达成；</li><li>条件变量的作用是阻塞线程，然后等待通知将其唤醒；</li><li>可以通过判断某个函数是否符合某种条件来决定是阻塞线程等待通知还是唤醒线程，由此实现线程间的同步；</li><li>condition_variable的等待函数有三个，分别是wait()——等待、wait_for()——等待一段时间、wait_until()——等待至某一时刻；</li><li>另外针对每个函数condition_variable还提供了有条件等待和无条件等待两种方式；</li><li>如果阻塞，则阻塞到其他某个线程调用<code>notify_one()</code>或<code>notify_all</code>成员函数为止，就被唤醒；</li><li>只要执行到wait后面就一定加锁成功；</li></ul><h3 id="无条件等待"><a href="#无条件等待" class="headerlink" title="无条件等待"></a>无条件等待</h3><ol><li><code>void wait(unique_lock&amp; lck)</code>会无条件的阻塞当前线程然后等待通知，前提是此时对象lck已经成功获取了锁；</li><li>等待(休眠)时会调用lck.unlock()释放锁，使其它线程可以获取锁。一旦得到通知(由其他线程显式地通知)，函数就会释放阻塞并调用lck.lock()，使lck保持与调用函数时相同的状态，然后函数返回；</li><li>wati()函数因为没有条件判断，因此有时候会产生<strong>虚假唤醒</strong>，而有条件的等待可以很好的解决这一问题；</li><li>效果跟有条件等待的第二个参数返回false一样；</li><li>无条件等待被唤醒后wait()不断尝试获取互斥量锁，如果获取不到那么流程就卡在wait()这里等待加锁，当获取到了，wait()就继续执行；</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>std::mutex                   mux;<br><span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">uniLock</span><span class="hljs-params">(mux)</span></span>;<br>std::condition_variable      condition;<br><br>condition.<span class="hljs-built_in">wait</span>(uniLock);<br></code></pre></td></tr></table></figure><h3 id="有条件等待"><a href="#有条件等待" class="headerlink" title="有条件等待"></a>有条件等待</h3><ol><li><code>void wait (unique_lock&amp; lck, Predicate pred)</code>为有条件的等待；</li><li>pred是一个可调用的对象或函数，它不接受任何参数，并返回一个可以作为bool的值；</li><li>当pred为false时wait()函数才会使线程等待(休眠)，在收到其他线程通知时只有当pred返回true时才会被唤醒；</li><li>有条件等待被唤醒后，就判断第二个参数(例如lambda表达式)的值：<ul><li>如果为false，那wait又对互斥量解锁，然后又休眠，等待再次被notify唤醒；</li><li>如果为true，则wait返回，流程可以继续执行（<strong>此时互斥量已被锁住</strong>）；</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br>std::mutex                   mux;<br><span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">uniLock</span><span class="hljs-params">(mux)</span></span>;<br>std::condition_variable      condition;<br><br>condition.<span class="hljs-built_in">wait</span>(uniLock, [<span class="hljs-keyword">this</span>] &#123;<br>    <span class="hljs-comment">// 等待消息队列不为空</span><br>    <span class="hljs-keyword">if</span> (!msgRecvQueue.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;);<br><span class="hljs-comment">// 如果第二个参数的lambda表达式返回值是false，那么wait()将解锁互斥量，并阻塞;</span><br><span class="hljs-comment">// 如果第二个参数的lambda表达式返回值是true，那么wait()直接返回并继续执行;</span><br></code></pre></td></tr></table></figure><h2 id="future类模板"><a href="#future类模板" class="headerlink" title="future类模板"></a>future类模板</h2><ul><li><code>std::future</code>的<code>get()</code>成员函数是<strong>转移</strong>数据，不能多次get；</li><li><code>std::future_status</code> status &#x3D; result.<strong>wait_for</strong>(std::chrono::seconds(几秒)) 可以卡住当前流程，等待std::async()的异步任务运行一段时间，然后返回其状态std::future_status，如果std::async()的参数是std::launch::deferred（延迟执行），则不会卡住主流程；</li><li>std::future_status是枚举类型，表示异步任务的执行状态，取值有std::future_status::timeout、std::future_status::ready、std::future_status::deferred；</li></ul><h3 id="async函数模板"><a href="#async函数模板" class="headerlink" title="async函数模板"></a>async函数模板</h3><ul><li><code>std::async</code>是一个函数模板，用来启动一个异步任务（启动一个异步任务，就是自动创建一个线程，并开始执行对应的线程入口函数）；</li><li>启动一个异步任务之后，async返回一个<code>std::future</code>对象，这个对象是个类模板，这个std::future对象中就含有线程入口函数所返回的结果，可以调用future对象的成员函数get()来获取结果；</li><li>std::future提供了一种访问异步操作结果的机制，可以理解为理解future中保存着一个值，这个值是在将来的某个时刻能够拿到；</li><li>std::future对象的<code>get()</code>成员函数会等待线程执行结束并返回结果，拿不到结果它就会一直等待；</li><li>std::future对象的<code>wait()</code>成员函数，用于等待线程返回，本身并不返回结果，这个效果和 std::thread 的join()更像；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mythread</span><span class="hljs-params">(<span class="hljs-type">int</span> mypar)</span> </span>&#123;<br>        cout &lt;&lt; mypar &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> mypar;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mythread</span><span class="hljs-params">(<span class="hljs-type">int</span> mypar)</span> </span>&#123;<br>cout &lt;&lt; mypar &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;mythread() start&quot;</span> &lt;&lt; <span class="hljs-string">&quot;threadid = &quot;</span> &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() &lt;&lt; endl;<br>std::<span class="hljs-function">chrono::milliseconds <span class="hljs-title">dura</span><span class="hljs-params">(<span class="hljs-number">5000</span>)</span></span>;<br>std::this_thread::<span class="hljs-built_in">sleep_for</span>(dura);<br>cout &lt;&lt; <span class="hljs-string">&quot;mythread() end&quot;</span> &lt;&lt; <span class="hljs-string">&quot;threadid = &quot;</span> &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    A a;<br>    <span class="hljs-type">int</span> tmp = <span class="hljs-number">12</span>;<br><br>    <span class="hljs-comment">//普通函数作为异步任务参数</span><br>    std::future&lt;<span class="hljs-type">int</span>&gt; result1 = std::<span class="hljs-built_in">async</span>(mythread);<br>    cout &lt;&lt; result1.<span class="hljs-built_in">get</span>() &lt;&lt; endl;  <span class="hljs-comment">//卡在这里等待mythread()执行完毕，拿到结果</span><br><br>    <span class="hljs-comment">//类成员函数作为异步任务参数</span><br>    <span class="hljs-comment">//第二个参数是对象引用才能保证线程里执行的是同一个对象</span><br>    std::future&lt;<span class="hljs-type">int</span>&gt; result2 = std::<span class="hljs-built_in">async</span>(&amp;A::mythread, &amp;a, tmp);<br>    cout &lt;&lt; result2.<span class="hljs-built_in">get</span>() &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>参数<code>std::lunch::deferred</code>表示线程入口函数的调用会被延迟，一直到std::future的wait()或者get()函数被调用时（由主线程调用）才会执行，如果wait()或者get()没有被调用，则根本就不会创建新线程执行；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::future&lt;<span class="hljs-type">int</span>&gt; result1 = std::<span class="hljs-built_in">async</span>(std::launch::deferred ,mythread);<br></code></pre></td></tr></table></figure><ul><li>参数<code>std::launch::async</code>，在调用async函数的时候就开始创建新线程;</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::future&lt;<span class="hljs-type">int</span>&gt; result1 = std::<span class="hljs-built_in">async</span>(std::launch::async ,mythread);<br></code></pre></td></tr></table></figure><h3 id="packaged-task类模板"><a href="#packaged-task类模板" class="headerlink" title="packaged_task类模板"></a>packaged_task类模板</h3><ul><li><code>std::packaged_task</code>的模板参数是各种<strong>可调用对象</strong>，通过packaged_task把各种可调用对象包装起来，方便将来作为线程入口函数来调用；</li><li>packaged_task包装起来的可调用对象还可以直接调用，从这个角度来讲，packaged_task对象也是一个可调用对象；</li><li>通过调用<code>get_future()</code>成员函数得到future对象；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mythread</span><span class="hljs-params">(<span class="hljs-type">int</span> mypar)</span> </span>&#123;<br><span class="hljs-comment">// ......</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;main&quot;</span> &lt;&lt; <span class="hljs-string">&quot;threadid = &quot;</span> &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() &lt;&lt; endl;<br><span class="hljs-comment">// 我们把函数mythread通过packaged_task包装起来</span><br>    <span class="hljs-comment">// 参数是一个int，返回值类型是int</span><br>    <span class="hljs-function">std::packaged_task&lt;<span class="hljs-title">int</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>&gt; <span class="hljs-title">mypt</span><span class="hljs-params">(mythread)</span></span>;<br>    <span class="hljs-comment">// t1是线程</span><br><span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(std::ref(mypt), <span class="hljs-number">1</span>)</span></span>;<br>t1.<span class="hljs-built_in">join</span>();<br>    <span class="hljs-comment">// 用std::future对象接收线程入口函数的返回结果</span><br>std::future&lt;<span class="hljs-type">int</span>&gt; result = mypt.<span class="hljs-built_in">get_future</span>(); <br>cout &lt;&lt; result.<span class="hljs-built_in">get</span>() &lt;&lt; endl;<br>   <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 可调用对象可由函数换成lambda表达式</span><br><span class="hljs-function">std::packaged_task&lt;<span class="hljs-title">int</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>&gt; <span class="hljs-title">mypt</span><span class="hljs-params">([](<span class="hljs-type">int</span> mypar) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">    cout &lt;&lt; mypar &lt;&lt; endl;</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-comment">// ......</span></span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;)</span></span>; <br></code></pre></td></tr></table></figure><h3 id="promise类模板"><a href="#promise类模板" class="headerlink" title="promise类模板"></a>promise类模板</h3><ul><li>我们能够在某个线程中给它赋值，然后我们可以在其他线程中，把这个值取出来；</li><li>即通过<code>std::promise</code>保存一个值，在将来某个时刻把一个future绑定到这个promise上，来得到绑定的值;</li><li>通过调用<code>get_future()</code>成员函数得到future对象；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mythread</span><span class="hljs-params">(std::promise&lt;<span class="hljs-type">int</span>&gt; &amp;tmp, <span class="hljs-type">int</span> clac)</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;mythread() start&quot;</span> &lt;&lt; <span class="hljs-string">&quot;threadid = &quot;</span> &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() &lt;&lt; endl;<br>std::<span class="hljs-function">chrono::milliseconds <span class="hljs-title">dura</span><span class="hljs-params">(<span class="hljs-number">5000</span>)</span></span>;<br>std::this_thread::<span class="hljs-built_in">sleep_for</span>(dura);<br>cout &lt;&lt; <span class="hljs-string">&quot;mythread() end&quot;</span> &lt;&lt; <span class="hljs-string">&quot;threadid = &quot;</span> &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() &lt;&lt; endl;<br><span class="hljs-type">int</span> result = clac;<br>tmp.<span class="hljs-built_in">set_value</span>(result); <span class="hljs-comment">//结果保存到了tmp这个对象中</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br> <br>vector&lt;std::packaged_task&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>)&gt;&gt; task_vec;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>std::promise&lt;<span class="hljs-type">int</span>&gt; myprom;<br><span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(mythread, std::ref(myprom), <span class="hljs-number">180</span>)</span></span>;<br>t1.<span class="hljs-built_in">join</span>(); <span class="hljs-comment">//在这里线程已经执行完了</span><br>std::future&lt;<span class="hljs-type">int</span>&gt; fu1 = myprom.<span class="hljs-built_in">get_future</span>(); <span class="hljs-comment">//promise和future绑定，用于获取线程返回值</span><br><span class="hljs-keyword">auto</span> result = fu1.<span class="hljs-built_in">get</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;result = &quot;</span> &lt;&lt; result &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>使用thread时，必须 join() 或者 detach() 否则程序会报异常</p></blockquote><h2 id="shared-future类模板"><a href="#shared-future类模板" class="headerlink" title="shared_future类模板"></a>shared_future类模板</h2><p>std::shared_future 的 get() 成员函数是<strong>复制</strong>数据；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::future&lt;<span class="hljs-type">int</span>&gt; result = mypt.<span class="hljs-built_in">get_future</span>();<br><br> <span class="hljs-comment">//判断future中的值是不是一个有效值</span><br><span class="hljs-type">bool</span> ifcanget = result.<span class="hljs-built_in">valid</span>();<br><br><span class="hljs-comment">//执行完毕后result_s里有值，而result里空了</span><br><span class="hljs-function">std::shared_future&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result_s</span><span class="hljs-params">(result.share())</span></span>; <br><br><span class="hljs-comment">//或通过get_future返回值直接构造一个shared_future对象</span><br><span class="hljs-function">std::shared_future&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result_s</span><span class="hljs-params">(mypt.get_future())</span></span>;<br><br><span class="hljs-comment">// 可以多次get，因为是赋值</span><br><span class="hljs-keyword">auto</span> myresult1 = result_s.<span class="hljs-built_in">get</span>();<br><span class="hljs-keyword">auto</span> myresult2 = result_s.<span class="hljs-built_in">get</span>();<br></code></pre></td></tr></table></figure><h2 id="atomic类模板"><a href="#atomic类模板" class="headerlink" title="atomic类模板"></a>atomic类模板</h2><ul><li>在多线程中，如果想要执行<strong>不会被打断的程序执行片段</strong>，一般需要使用互斥量；</li><li>可以把<code>std::atomic</code><strong>原子操作</strong>理解成一种：不需要用到互斥量加锁的多线程并发编程方式；</li><li>从效率上来说，原子操作要比互斥量的方式效率要高；</li><li>互斥量的加锁一般是针对一个代码段，而原子操作针对的一般都是<strong>一个变量</strong>；</li><li>std::atomic是用来封装某个类型的值，原子操作一般用于计数或者统计；</li><li>原子操作实质上是不允许在进行原子对象操作时进行CPU的上下文切换；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atomic&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>std::atomic&lt;<span class="hljs-type">int</span>&gt; g_count = <span class="hljs-number">0</span>;  <span class="hljs-comment">//封装了一个类型为int的 对象（值）</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mythread1</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000</span>; i++) &#123;<br>        g_count++;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(mythread1)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(mythread1)</span></span>;<br>    t1.<span class="hljs-built_in">join</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br>    cout &lt;&lt; g_count &lt;&lt; endl;  <span class="hljs-comment">//得到2000000</span><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>C++11</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++11多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LRU算法</title>
    <link href="/2022/07/02/LRU%E7%AE%97%E6%B3%95/"/>
    <url>/2022/07/02/LRU%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>一种按时序来淘汰的缓存淘汰策略！！！</p></blockquote><p>LRU的全称是Least Recently Used，即最近最少使用，我们认为最近使用过的数据是有用的，很久没有使用过的数据是无用的，内存满了就先删除那些很久没有用过的数据。</p><ul><li>显然cache里面的元素要有时序，支持快速查找，支持在任意位置插入和删除元素；</li><li>用节点来表示每一个键值对key-value；</li><li>可以结合双向链表与哈希表，链表里面是节点，哈希表存储key及链表中对应的节点；</li><li>双向链表中靠头部元素是最久未使用的，靠尾部元素是最近使用的；</li><li>添加元素时先查看缓存容量，只能从尾部插入；</li><li>若添加新元素时遇到相同key值，只需更新value值和将链表中节点移动到尾部；</li><li>缓存容量不足时从链表头部删除节点，并且删除umap中对应节点；</li><li>访问某元素后要将该节点位置移动到链表尾部；</li><li>umap中节点的变动只发生在添加新节点和缓存容量不够时；</li><li>注意移除与删除列表中节点的区别；</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-type">int</span> key, value;<br>    Node* prev;<br>    Node* next;<br>    <span class="hljs-comment">//必须添加下面两个构造函数</span><br>    <span class="hljs-built_in">Node</span>() : <span class="hljs-built_in">key</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">value</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">prev</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>    <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> v) : <span class="hljs-built_in">key</span>(k), <span class="hljs-built_in">value</span>(v), <span class="hljs-built_in">prev</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">NodeList</span> &#123;<br>    Node* head;<br>    Node* tail;<br>    <span class="hljs-built_in">NodeList</span>() &#123;<br>        <span class="hljs-comment">//必须要new</span><br>        head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();<br>        tail = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();<br>        head-&gt;next = tail;<br>        tail-&gt;prev = head;<br>    &#125;<br>    <span class="hljs-comment">//添加节点到链表尾部</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addToTail</span><span class="hljs-params">(Node* node)</span> </span>&#123;<br>        node-&gt;prev = tail-&gt;prev;<br>        tail-&gt;prev-&gt;next = node;<br>        node-&gt;next = tail;<br>        tail-&gt;prev = node;<br>    &#125;<br>    <span class="hljs-comment">//从链表中移除某个节点，前提是这个节点必须存在于链表中</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(Node* node)</span> </span>&#123;<br>        node-&gt;prev-&gt;next = node-&gt;next;<br>        node-&gt;next-&gt;prev = node-&gt;prev;<br>    &#125;<br>    <span class="hljs-comment">//删除链表中最久未使用的节点，即靠近头部的那个节点</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cleanOneCache</span><span class="hljs-params">()</span> </span>&#123;<br>        Node* tmp = head-&gt;next;<br>        <span class="hljs-type">int</span> key = tmp-&gt;key;<br>        <span class="hljs-built_in">remove</span>(tmp);<br>        <span class="hljs-keyword">delete</span> tmp;<br>        <span class="hljs-keyword">return</span> key;<br>    &#125;<br>    <span class="hljs-comment">//使某个被访问的元素到链表尾部</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">makeItRecently</span><span class="hljs-params">(Node* node)</span></span>&#123;<br>        <span class="hljs-built_in">remove</span>(node);<br>        <span class="hljs-built_in">addToTail</span>(node);<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    NodeList list;<br>    unordered_map&lt;<span class="hljs-type">int</span>, Node*&gt; umap;<br>    <span class="hljs-type">int</span> capacity;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">LRUCache</span>(<span class="hljs-type">int</span> cap) &#123;<br>        capacity = cap;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(umap.<span class="hljs-built_in">find</span>(key) == umap.<span class="hljs-built_in">end</span>()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Node* node = umap[key];<br>            <span class="hljs-type">int</span> value = node-&gt;value;<br>            <span class="hljs-comment">//更新链表中节点位置</span><br>            list.<span class="hljs-built_in">makeItRecently</span>(node);<br>            <span class="hljs-keyword">return</span> value;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(umap.<span class="hljs-built_in">find</span>(key) != umap.<span class="hljs-built_in">end</span>()) &#123;<br>            Node* cur = umap[key];<br>            <span class="hljs-comment">//更新节点中的value值</span><br>            cur-&gt;value = value;<br>            <span class="hljs-comment">//更新链表中节点位置</span><br>            list.<span class="hljs-built_in">makeItRecently</span>(cur);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//先查看缓存容量是否充足</span><br>            <span class="hljs-keyword">if</span>(capacity == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>            <span class="hljs-keyword">if</span>(umap.<span class="hljs-built_in">size</span>() == capacity) &#123;<br>                <span class="hljs-type">int</span> k = list.<span class="hljs-built_in">cleanOneCache</span>();<br>                umap.<span class="hljs-built_in">erase</span>(k);<br>            &#125;<br>            <span class="hljs-comment">//添加新节点到链表和umap中</span><br>            Node* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(key, value);<br>            list.<span class="hljs-built_in">addToTail</span>(node);<br>            umap[key] = node;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/2022/07/02/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>/2022/07/02/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<ul><li>并查集用来表示各节点间的连通关系；</li><li>有些问题可以抽象用并查集来解决；</li><li>节点用数组表示！！！<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span> &#123;<br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 连接分量的数目</span><br>    <span class="hljs-type">int</span> count;<br>    <span class="hljs-comment">// 记录每棵树的节点个数</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; size;<br>    <span class="hljs-comment">// 记录每个节点的父节点</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; parent;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">UnionFind</span>(<span class="hljs-type">int</span> n) : <span class="hljs-built_in">count</span>(n) &#123;<br>        parent.<span class="hljs-built_in">resize</span>(n);<br>        size.<span class="hljs-built_in">resize</span>(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            parent[i] = i;<br>            size[i] = i;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Count</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 找到该节点所在树的根节点</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findRoot</span> <span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (x != parent[x]) &#123;<br>            <span class="hljs-comment">// 路径压缩</span><br>            parent[x] = parent[parent[x]];<br>            x = parent[x];<br>        &#125;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 连接两个节点</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unionIt</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q)</span> </span>&#123;<br>        <span class="hljs-type">int</span> rootP = <span class="hljs-built_in">findRoot</span>(p);<br>        <span class="hljs-type">int</span> rootQ = <span class="hljs-built_in">findRoot</span>(q);<br>        <span class="hljs-keyword">if</span> (rootP == rootQ) <span class="hljs-keyword">return</span>;<br>        <br>        <span class="hljs-comment">// 小树接在大树之下，更平衡</span><br>        <span class="hljs-keyword">if</span> (size[rootP] &gt;= size[rootQ]) &#123;<br>            parent[rootQ] = rootP;<br>            size[rootP] += size[rootQ];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            parent[rootP] = rootQ;<br>            size[rootQ] += size[rootP];<br>        &#125;<br>        --count;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 确认两个节点是否连接</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isConnected</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q)</span> </span>&#123;<br>        <span class="hljs-type">int</span> rootP = <span class="hljs-built_in">findRoot</span>(p);<br>        <span class="hljs-type">int</span> rootQ = <span class="hljs-built_in">findRoot</span>(q);<br>        <span class="hljs-keyword">if</span> (rootP == rootQ) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++后端个人书单</title>
    <link href="/2022/07/01/C++%E5%90%8E%E7%AB%AF%E4%B8%AA%E4%BA%BA%E4%B9%A6%E5%8D%95/"/>
    <url>/2022/07/01/C++%E5%90%8E%E7%AB%AF%E4%B8%AA%E4%BA%BA%E4%B9%A6%E5%8D%95/</url>
    
    <content type="html"><![CDATA[<table><thead><tr><th align="center"><strong>类别</strong></th><th align="center"><strong>书名</strong></th><th align="center"><strong>作者</strong></th></tr></thead><tbody><tr><td align="center"><strong><em>数学基础</em></strong></td><td align="center">程序员的数学2 概率统计</td><td align="center">[日]平冈和幸</td></tr><tr><td align="center"></td><td align="center">程序员的数学3 线性代数</td><td align="center">[日]平冈和幸</td></tr><tr><td align="center"><strong><em>C++</em></strong></td><td align="center">C++ Primer（中文版 第五版）</td><td align="center">[美]Stanley B. Lippman</td></tr><tr><td align="center"></td><td align="center">Effective C++</td><td align="center">[美]Scott Meyers</td></tr><tr><td align="center"></td><td align="center">More Effective C++</td><td align="center">[美]Scott Meyers</td></tr><tr><td align="center"></td><td align="center">Effective Modern C++</td><td align="center">[美]Scott Meyers</td></tr><tr><td align="center"></td><td align="center">STL源码刨析</td><td align="center">侯捷</td></tr><tr><td align="center"></td><td align="center">深度探索C++对象模型</td><td align="center">[美]Stanley B. Lippman</td></tr><tr><td align="center"><strong><em>数据机构与算法</em></strong></td><td align="center">数据机构与算法分析：C++语言描述（第四版）</td><td align="center">[美]Mark Allen Weiss</td></tr><tr><td align="center"></td><td align="center">算法（第4版）</td><td align="center">[美]Robert Sedgewick</td></tr><tr><td align="center"></td><td align="center">编程珠玑 第2版</td><td align="center">[美]Jon,Bentley</td></tr><tr><td align="center"></td><td align="center">剑指Offer 第2版</td><td align="center">何海涛</td></tr><tr><td align="center"></td><td align="center">labuladong的算法小抄</td><td align="center">付东来</td></tr><tr><td align="center"><strong><em>计算机网络</em></strong></td><td align="center">图解TCP&#x2F;IP 第5版</td><td align="center">[日]竹下隆史</td></tr><tr><td align="center"></td><td align="center">图解HTTP</td><td align="center">[日]上野</td></tr><tr><td align="center"></td><td align="center">计算机网络：自顶向下方法</td><td align="center">[美]James F. kurose</td></tr><tr><td align="center"><strong><em>操作系统</em></strong></td><td align="center">操作系统导论</td><td align="center">[美]Remzi · H.Arpaci-Dusseau</td></tr><tr><td align="center"></td><td align="center">程序员的自我修养 ——链接、转载与库</td><td align="center">俞甲子</td></tr><tr><td align="center"></td><td align="center">鸟哥的Linux私房菜基础学习篇（第四版）</td><td align="center">鸟哥</td></tr><tr><td align="center"></td><td align="center">深入理解计算机系统（原书第3版）</td><td align="center">[美]Randal E. Bryant</td></tr><tr><td align="center"><strong><em>数据库</em></strong></td><td align="center">SQL必知必会 第5版</td><td align="center">[美]Ben,Forta</td></tr><tr><td align="center"></td><td align="center">MySQL是怎样运行的</td><td align="center">小孩子4919</td></tr><tr><td align="center"></td><td align="center">高性能MySQL（第3版）</td><td align="center">Baron Schwartz</td></tr><tr><td align="center"></td><td align="center">MySQL技术内幕：lnnoDB存储引擎（第2版）</td><td align="center">姜承尧</td></tr><tr><td align="center"></td><td align="center">Redis设计与实现</td><td align="center">黄健宏</td></tr><tr><td align="center"><strong><em>设计模式</em></strong></td><td align="center">大话设计模式</td><td align="center">程杰</td></tr><tr><td align="center"><strong><em>网络编程</em></strong></td><td align="center">Linux高性能服务器编程</td><td align="center">游双</td></tr><tr><td align="center"></td><td align="center">linux多线程服务端编程</td><td align="center">陈硕</td></tr><tr><td align="center"><strong><em>应用</em></strong></td><td align="center">数据密集型应用系统设计</td><td align="center">[美]Martin Kleppmann</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>计算机学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习路线</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo常用命令</title>
    <link href="/2022/07/01/hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/07/01/hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="前置安装"><a href="#前置安装" class="headerlink" title="前置安装"></a>前置安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm i -g hexo-cli<br><br>npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 新建一个名为new_post的post</span><br>hexo n new_post<br><br><span class="hljs-comment"># 清楚缓存</span><br>hexo clear<br><br><span class="hljs-comment"># 生成</span><br>hexo g<br><br><span class="hljs-comment"># 发布到本地</span><br>hexo s<br><br><span class="hljs-comment"># 发布到github</span><br>hexo d<br></code></pre></td></tr></table></figure><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 本地发布</span><br>hexo clear &amp;&amp; hexo g &amp;&amp; hexo s<br><br><span class="hljs-comment"># github发布</span><br>hexo clear &amp;&amp; hexo g &amp;&amp; hexo d<br><br><span class="hljs-comment"># 删除文章</span><br>删除 <span class="hljs-string">&quot;sourc/_posts&quot;</span> 文件夹中相应的md文件<br></code></pre></td></tr></table></figure><h2 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h2><p>格式举例如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">title:</span> <span class="hljs-string">C++给常用数据结构传入排序算法</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2022-07-01 16:22:30</span><br><span class="hljs-attr">tags:</span> <br>  <span class="hljs-bullet">-</span> <span class="hljs-string">刷题</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">C++</span><br><span class="hljs-attr">categories:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">C++</span><br><span class="hljs-attr">index_img:</span> <span class="hljs-string">/post_img/02.jpg</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++给常用数据结构传入排序算法</title>
    <link href="/2022/07/01/C++%E7%BB%99%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BC%A0%E5%85%A5%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2022/07/01/C++%E7%BB%99%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BC%A0%E5%85%A5%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>在刷<a href="https://leetcode-cn.com/problems/top-k-frequent-elements/">leetcode347题</a>时，遇到c++自定义操作的知识点，总结如下：</p><h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><p><strong>在类中</strong>定义了如下比较函数，但<strong>定义有序容器时</strong>编译不通过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">myComparison</span><span class="hljs-params">(<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; lhs, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; rhs)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> lhs.second &gt; rhs.second;<br>&#125;<br><br>priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;,<br>  <span class="hljs-keyword">decltype</span>(myComparison)*&gt; <span class="hljs-built_in">pri_que</span>(myComparison);<br></code></pre></td></tr></table></figure><p>编译报错如下：</p><blockquote><p>error: reference to non-static member function must be called 即必须调用对非静态成员函数的引用</p></blockquote><h3 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h3><p>所以比较函数定义错误，正确解法如下：</p><h4 id="1-定义为静态成员函数"><a href="#1-定义为静态成员函数" class="headerlink" title="1.定义为静态成员函数"></a>1.定义为静态成员函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">myComparison</span><span class="hljs-params">(<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; lhs, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; rhs)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> lhs.second &gt; rhs.second;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-将比较函数定义在类外面"><a href="#2-将比较函数定义在类外面" class="headerlink" title="2.将比较函数定义在类外面"></a>2.将比较函数定义在类外面</h4><p>注意函数声明在类前。</p><h4 id="3-运用仿函数"><a href="#3-运用仿函数" class="headerlink" title="3.运用仿函数"></a>3.运用仿函数</h4><p>注意添加const。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">myComparison</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; lhs, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; rhs)</span> <span class="hljs-type">const</span> </span>&#123;<br><span class="hljs-keyword">return</span> lhs.second &gt; rhs.second;<br>&#125;<br>&#125;;<br><br>priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, myComparison&gt; pri_que;<br></code></pre></td></tr></table></figure><hr><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><h4 id="1-容器的操作自定义处"><a href="#1-容器的操作自定义处" class="headerlink" title="1.容器的操作自定义处"></a>1.容器的操作自定义处</h4><blockquote><p>priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, decltype(myComparison)*&gt; pri_que(myComparison);</p></blockquote><ul><li>为了使用自己定义的操作，在定义容器时必须提供两个类型：<strong>关键字类型</strong>即<code>pair&lt;int, int&gt;</code>，<strong>比较操作类型</strong>即指向myComparison的指针<code>decltype(myComparison)*</code>；</li><li>此处使用<code>decltype</code>指出自定义操作的类型，但当使用decltype来获取一个函数指针类型时，须加上一个<code>*</code>号来表示使用一个给定函数类型的指针；</li><li>定义有序容器时，<code>vector&lt;pair&lt;int, int&gt;&gt;</code>表示<strong>基于vector构造</strong>优先队列；</li><li><code>pri_que(myComparison)</code>表示用myComparison来初始化pri_que对象，即向pri_que添加元素时，调用myComparison来排序；</li><li>用<code>pri_que(myComparison)</code>代替<code>pri_que(&amp;myComparison)</code>因为使用函数名字会自动转化为指针；</li></ul><h4 id="2-比较函数自定义处"><a href="#2-比较函数自定义处" class="headerlink" title="2.比较函数自定义处"></a>2.比较函数自定义处</h4><blockquote><p>return lhs.second &gt; rhs.second;</p></blockquote><ul><li><code>&gt;</code>此比较符号表示在优先队列中左大于右就会建立小顶堆；</li></ul><h3 id="扩展："><a href="#扩展：" class="headerlink" title="扩展："></a>扩展：</h3><h4 id="1-向算法传递函数"><a href="#1-向算法传递函数" class="headerlink" title="1.向算法传递函数"></a>1.向算法传递函数</h4><p>即使用标准库的算法时，传入参数使用自己的操作，示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isShorter</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s1, <span class="hljs-type">const</span> string&amp; s2)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> s1.<span class="hljs-built_in">size</span>() &lt; s2.<span class="hljs-built_in">size</span>();<br>&#125;<br><span class="hljs-built_in">sort</span>(words.<span class="hljs-built_in">begin</span>(), words.<span class="hljs-built_in">end</span>(), isShorter);<br></code></pre></td></tr></table></figure><h4 id="2-在算法中使用lambda表达式"><a href="#2-在算法中使用lambda表达式" class="headerlink" title="2.在算法中使用lambda表达式"></a>2.在算法中使用lambda表达式</h4><p>即编写与isShorter函数功能相同的lambda表达式，示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">sort</span>(words.<span class="hljs-built_in">begin</span>(), words.<span class="hljs-built_in">end</span>(),<br>    [](<span class="hljs-type">const</span> string&amp; s1, <span class="hljs-type">const</span> string&amp; s2)<br>     &#123;<span class="hljs-keyword">return</span> s1.<span class="hljs-built_in">size</span>() &lt; s2.<span class="hljs-built_in">size</span>();&#125;);<br></code></pre></td></tr></table></figure><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul><li><a href="https://programmercarl.com/">代码随想录</a>博客</li><li>《C++primer》</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
