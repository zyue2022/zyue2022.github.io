<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>C++11多线程编程笔记</title>
    <link href="/2022/07/12/C++11%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/07/12/C++11%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="线程创建、启动、结束"><a href="#线程创建、启动、结束" class="headerlink" title="线程创建、启动、结束"></a>线程创建、启动、结束</h2><ul><li>线程类的参数是一个可调用对象，如函数(可以是类中的成员函数)、函数指针、仿函数、lambda表达式、bind创建的对象；</li><li><code>jion()</code> 是阻塞主线程并等待子线程执行完，当子线程执行完毕，join()就执行完毕，主线程继续往下执行，join意为汇合，子线程和主线程回合；</li><li><code>detach()</code> 是线程分离，主线程不再与子线程汇合，不再等待子线程，detach后，子线程和主线程失去关联，驻留在后台，由C++运行时库接管；</li><li><code>joinable()</code>判断是否可以成功使用join()或者detach()，返回true就可以调用，如果返回false，证明调用过join()或者detach()；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">childFunc</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//子线程代码逻辑</span><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//创建子线程，线程执行起点是childFunc，然后执行线程</span><br>    <span class="hljs-function">thread <span class="hljs-title">childThread</span><span class="hljs-params">(childFunc)</span></span>;<br><br>    <span class="hljs-comment">//阻塞主线程并等待子线程执行完毕</span><br>    childThread.<span class="hljs-built_in">join</span>();<br><br>    <span class="hljs-comment">//线程分离，由C++运行时库回收子线程</span><br>    <span class="hljs-comment">//childThread.detach();</span><br><br>    <span class="hljs-keyword">if</span> (childThread.<span class="hljs-built_in">joinable</span>()) &#123;<br>        <span class="hljs-comment">//可以调用可以调用join()或者detach()</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//不能调用可以调用join()或者detach()</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>TODO: 补充如何给子线程传参：类中的成员函数、函数指针、仿函数、lambda表达式、bind创建的对象</p></blockquote><h2 id="mutex互斥量"><a href="#mutex互斥量" class="headerlink" title="mutex互斥量"></a>mutex互斥量</h2><ul><li>互斥量是个类对象，我也称为互斥锁；</li><li>多个线程尝试用lock()成员函数来加锁，只有一个线程能锁定成功；</li><li>如果没有锁成功，那么流程将卡在lock()这里不断尝试去加锁；</li><li>成员函数lock()和unlock()要成对使用；</li><li>使用互斥量少了达不到效果，多了影响效率；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 定义</span><br>mutex mux;<br><br><span class="hljs-comment">// 一般使用步骤</span><br><span class="hljs-number">1.</span>加锁mux.<span class="hljs-built_in">lock</span>();<br><span class="hljs-number">2.</span>操作共享数据<br><span class="hljs-number">3.</span>解锁mux.<span class="hljs-built_in">unlock</span>();<br></code></pre></td></tr></table></figure><h2 id="std-lock-函数模板"><a href="#std-lock-函数模板" class="headerlink" title="std::lock()函数模板"></a>std::lock()函数模板</h2><ul><li><code>std::lock(mutex1,mutex2...); </code>一次锁定多个互斥量（一般这种情况很少），用于处理多个互斥量；</li><li>如果互斥量中某一个没锁住，它就等待所有互斥量都锁住，才能继续执行；</li><li>如果有一个没锁住，就会把已经锁住的释放掉；</li><li>要么互斥量都锁住，要么都没锁住，防止死锁；</li></ul><h2 id="lock-guard类模板"><a href="#lock-guard类模板" class="headerlink" title="lock_guard类模板"></a>lock_guard类模板</h2><ul><li>可以取代使用<code>mux</code>互斥量的lock()和unlock()成员函数；</li><li>lock_guard构造函数执行了mutex::lock()，在作用域结束时，调用析构函数，执行mutex::unlock()；</li><li>所有使用时注意<strong>作用域</strong>范围；</li><li>若使用第二个参数<code>std::adopt_lock</code>，则表示这个互斥量已经lock()，构造时不需要再lock()；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">lock_guard&lt;mutex&gt; <span class="hljs-title">guard</span><span class="hljs-params">(mux)</span></span>;<br><span class="hljs-comment">// 或</span><br><span class="hljs-function">lock_guard&lt;mutex&gt; <span class="hljs-title">guard</span><span class="hljs-params">(mux,adopt_lock)</span></span>;<br></code></pre></td></tr></table></figure><h2 id="unique-lock类模板"><a href="#unique-lock类模板" class="headerlink" title="unique_lock类模板"></a>unique_lock类模板</h2><ul><li>类似lock_guard，但有更多用法；</li><li><strong>无需自己unlock()</strong>;</li><li>其第二个参数有：<br>   1. <code>adopt_lock</code>; 同lock_guard中的，前提是已经lock()；<br>   2. <code>try_to_lock</code>; 尝试用去锁定，如果没有锁定成功，会立即返回，不会阻塞在那里，前提是没有lock()；<br>   3. <code>defer_lock</code>; 初始化一个没有加锁的互斥量mutex，以便后序调用其它方法，前提是没有lock()；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">unique_lock&lt;mutex&gt; <span class="hljs-title">uniLock</span><span class="hljs-params">(mux)</span></span>; <span class="hljs-comment">// 相当于把mux和uniLock绑定在了一起，uniLock拥有mux的所有权</span><br><span class="hljs-comment">// 或</span><br><span class="hljs-function">unique_lock&lt;mutex&gt; <span class="hljs-title">uniLock</span><span class="hljs-params">(myMutex, defer_lock)</span></span>;<br><br>uniLock.<span class="hljs-built_in">lock</span>();   <span class="hljs-comment">// 加锁</span><br>uniLock.<span class="hljs-built_in">unlock</span>(); <span class="hljs-comment">// 解锁</span><br><br><span class="hljs-comment">// 尝试给互斥量加锁，如果拿不到锁，返回false，否则返回true</span><br>uniLock.<span class="hljs-built_in">try_lock</span>(); <br><br><span class="hljs-comment">// 解除绑定，返回它所管理的mutex对象的指针，并释放所有权，所有权由ptx接管</span><br>mutex* ptx = uniLock.<span class="hljs-built_in">release</span>();<br><br><span class="hljs-comment">// uniLock可以把自己对mux的所有权转移，但是不能复制</span><br><span class="hljs-function">unique_lock&lt;mutex&gt; <span class="hljs-title">uniLock2</span><span class="hljs-params">(std::move(uniLock))</span></span>;<br></code></pre></td></tr></table></figure><h2 id="单例类与共享数据"><a href="#单例类与共享数据" class="headerlink" title="单例类与共享数据"></a>单例类与共享数据</h2><p><strong>单例设计模式：</strong> </p><p>定义：单例模式保证一个类仅有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享。</p><p>实现思路：私有化它的构造函数，以防止外界创建单例类的对象；使用类的私有静态指针变量指向类的唯一实例，并用一个公有的静态方法获取该实例。</p><h3 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h3><p>用到的时候再创建，需要锁；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>mutex myMutex;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//双重判断 提高效率</span><br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-function">lock_guard&lt;mutex&gt; <span class="hljs-title">myLockGua</span><span class="hljs-params">(myMutex)</span></span>;<br>            <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">NULL</span>) &#123;<br>                instance = <span class="hljs-keyword">new</span> Singleton;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>    <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Singleton</span>() &#123;&#125;<br>    <span class="hljs-type">static</span> Singleton* instance;<br>&#125;;<br>Singleton* Singleton::instance = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><h3 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h3><p>一开始就创建，所以不需要锁；</p><blockquote><p>饿汉模式的问题在于非静态对象（函数外的static对象）在不同编译单元中的初始化顺序是未定义的。如果在初始化完成之前调用 getInstance() 方法会返回一个未定义的实例。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>mutex myMutex;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton2</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton2* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> instance; &#125;<br>    <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Singleton2</span>() &#123;&#125;<br>    <span class="hljs-type">static</span> Singleton2* instance;<br>&#125;;<br>Singleton2* Singleton2::instance = <span class="hljs-keyword">new</span> Singleton2;<br></code></pre></td></tr></table></figure><h3 id="使用call-once函数模板"><a href="#使用call-once函数模板" class="headerlink" title="使用call_once函数模板"></a>使用<strong>call_once</strong>函数模板</h3><p>参数：第一个参数为标记，第二个参数是一个函数名；<br>功能：能够保证函数只被调用一次，具备互斥量的能力，而且比互斥量消耗的资源更少，更高效。</p><blockquote><p>标记为std::once_flag，call_once()就是通过标记来决定函数是否执行，调用成功后，就把标记设置为一种已调用状态；</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>once_flag g_flag;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//call_once保证其只被调用一次</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">CreateInstance</span><span class="hljs-params">()</span> </span>&#123; instance = <span class="hljs-keyword">new</span> Singleton; &#125;<br><br>    <span class="hljs-comment">//两个线程同时执行到这里，其中一个线程要等另外一个线程执行完毕</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton *<span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-built_in">call_once</span>(g_flag, CreateInstance);<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Singleton</span>() &#123;&#125;<br>    <span class="hljs-type">static</span> Singleton *instance;<br>&#125;;<br>Singleton *Singleton::instance = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><h3 id="借助局部静态对象实现"><a href="#借助局部静态对象实现" class="headerlink" title="借助局部静态对象实现"></a>借助局部静态对象实现</h3><blockquote><p>《Effective C++》（Item 04）中提出一种更优雅的单例模式实现，使用函数内的局部静态对象，这种方法在C++11及之后不用加锁和解锁操作。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">single</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">single</span>() &#123;&#125;<br>    ~<span class="hljs-built_in">single</span>() &#123;&#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> single* <span class="hljs-title">getinstance</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-function">single* <span class="hljs-title">single::getinstance</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">static</span> single obj;<br>    <span class="hljs-keyword">return</span> &amp;obj;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><ul><li><code>std::condition_variable</code>实际上是一个和条件相关的类，就是等待一个条件达成；</li><li>条件变量的作用是阻塞线程，然后等待通知将其唤醒；</li><li>可以通过判断某个函数是否符合某种条件来决定是阻塞线程等待通知还是唤醒线程，由此实现线程间的同步；</li><li>condition_variable的等待函数有三个，分别是wait()——等待、wait_for()——等待一段时间、wait_until()——等待至某一时刻；</li><li>另外针对每个函数condition_variable还提供了有条件等待和无条件等待两种方式；</li><li>如果阻塞，则阻塞到其他某个线程调用<code>notify_one()</code>或<code>notify_all</code>成员函数为止，就被唤醒；</li><li>只要执行到wait后面就一定加锁成功；</li></ul><h3 id="无条件等待"><a href="#无条件等待" class="headerlink" title="无条件等待"></a>无条件等待</h3><ol><li><code>void wait(unique_lock&amp; lck)</code>会无条件的阻塞当前线程然后等待通知，前提是此时对象lck已经成功获取了锁；</li><li>等待(休眠)时会调用lck.unlock()释放锁，使其它线程可以获取锁。一旦得到通知(由其他线程显式地通知)，函数就会释放阻塞并调用lck.lock()，使lck保持与调用函数时相同的状态，然后函数返回；</li><li>wati()函数因为没有条件判断，因此有时候会产生<strong>虚假唤醒</strong>，而有条件的等待可以很好的解决这一问题；</li><li>效果跟有条件等待的第二个参数返回false一样；</li><li>无条件等待被唤醒后wait()不断尝试获取互斥量锁，如果获取不到那么流程就卡在wait()这里等待加锁，当获取到了，wait()就继续执行；</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>std::mutex                   mux;<br><span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">uniLock</span><span class="hljs-params">(mux)</span></span>;<br>std::condition_variable      condition;<br><br>condition.<span class="hljs-built_in">wait</span>(uniLock);<br></code></pre></td></tr></table></figure><h3 id="有条件等待"><a href="#有条件等待" class="headerlink" title="有条件等待"></a>有条件等待</h3><ol><li><code>void wait (unique_lock&amp; lck, Predicate pred)</code>为有条件的等待；</li><li>pred是一个可调用的对象或函数，它不接受任何参数，并返回一个可以作为bool的值；</li><li>当pred为false时wait()函数才会使线程等待(休眠)，在收到其他线程通知时只有当pred返回true时才会被唤醒；</li><li>有条件等待被唤醒后，就判断第二个参数(例如lambda表达式)的值：<ul><li>如果为false，那wait又对互斥量解锁，然后又休眠，等待再次被notify唤醒；</li><li>如果为true，则wait返回，流程可以继续执行（<strong>此时互斥量已被锁住</strong>）；</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br>std::mutex                   mux;<br><span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">uniLock</span><span class="hljs-params">(mux)</span></span>;<br>std::condition_variable      condition;<br><br>condition.<span class="hljs-built_in">wait</span>(uniLock, [<span class="hljs-keyword">this</span>] &#123;<br>    <span class="hljs-comment">// 等待消息队列不为空</span><br>    <span class="hljs-keyword">if</span> (!msgRecvQueue.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;);<br><span class="hljs-comment">// 如果第二个参数的lambda表达式返回值是false，那么wait()将解锁互斥量，并阻塞;</span><br><span class="hljs-comment">// 如果第二个参数的lambda表达式返回值是true，那么wait()直接返回并继续执行;</span><br></code></pre></td></tr></table></figure><h2 id="future类模板"><a href="#future类模板" class="headerlink" title="future类模板"></a>future类模板</h2><ul><li><code>std::future</code>的<code>get()</code>成员函数是<strong>转移</strong>数据，不能多次get；</li><li><code>std::future_status</code> status &#x3D; result.<strong>wait_for</strong>(std::chrono::seconds(几秒)) 可以卡住当前流程，等待std::async()的异步任务运行一段时间，然后返回其状态std::future_status，如果std::async()的参数是std::launch::deferred（延迟执行），则不会卡住主流程；</li><li>std::future_status是枚举类型，表示异步任务的执行状态，取值有std::future_status::timeout、std::future_status::ready、std::future_status::deferred；</li></ul><h3 id="async函数模板"><a href="#async函数模板" class="headerlink" title="async函数模板"></a>async函数模板</h3><ul><li><code>std::async</code>是一个函数模板，用来启动一个异步任务（启动一个异步任务，就是自动创建一个线程，并开始执行对应的线程入口函数）；</li><li>启动一个异步任务之后，async返回一个<code>std::future</code>对象，这个对象是个类模板，这个std::future对象中就含有线程入口函数所返回的结果，可以调用future对象的成员函数get()来获取结果；</li><li>std::future提供了一种访问异步操作结果的机制，可以理解为理解future中保存着一个值，这个值是在将来的某个时刻能够拿到；</li><li>std::future对象的<code>get()</code>成员函数会等待线程执行结束并返回结果，拿不到结果它就会一直等待；</li><li>std::future对象的<code>wait()</code>成员函数，用于等待线程返回，本身并不返回结果，这个效果和 std::thread 的join()更像；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mythread</span><span class="hljs-params">(<span class="hljs-type">int</span> mypar)</span> </span>&#123;<br>        cout &lt;&lt; mypar &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> mypar;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mythread</span><span class="hljs-params">(<span class="hljs-type">int</span> mypar)</span> </span>&#123;<br>cout &lt;&lt; mypar &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;mythread() start&quot;</span> &lt;&lt; <span class="hljs-string">&quot;threadid = &quot;</span> &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() &lt;&lt; endl;<br>std::<span class="hljs-function">chrono::milliseconds <span class="hljs-title">dura</span><span class="hljs-params">(<span class="hljs-number">5000</span>)</span></span>;<br>std::this_thread::<span class="hljs-built_in">sleep_for</span>(dura);<br>cout &lt;&lt; <span class="hljs-string">&quot;mythread() end&quot;</span> &lt;&lt; <span class="hljs-string">&quot;threadid = &quot;</span> &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    A a;<br>    <span class="hljs-type">int</span> tmp = <span class="hljs-number">12</span>;<br><br>    <span class="hljs-comment">//普通函数作为异步任务参数</span><br>    std::future&lt;<span class="hljs-type">int</span>&gt; result1 = std::<span class="hljs-built_in">async</span>(mythread);<br>    cout &lt;&lt; result1.<span class="hljs-built_in">get</span>() &lt;&lt; endl;  <span class="hljs-comment">//卡在这里等待mythread()执行完毕，拿到结果</span><br><br>    <span class="hljs-comment">//类成员函数作为异步任务参数</span><br>    <span class="hljs-comment">//第二个参数是对象引用才能保证线程里执行的是同一个对象</span><br>    std::future&lt;<span class="hljs-type">int</span>&gt; result2 = std::<span class="hljs-built_in">async</span>(&amp;A::mythread, &amp;a, tmp);<br>    cout &lt;&lt; result2.<span class="hljs-built_in">get</span>() &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>参数<code>std::lunch::deferred</code>表示线程入口函数的调用会被延迟，一直到std::future的wait()或者get()函数被调用时（由主线程调用）才会执行，如果wait()或者get()没有被调用，则根本就不会创建新线程执行；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::future&lt;<span class="hljs-type">int</span>&gt; result1 = std::<span class="hljs-built_in">async</span>(std::launch::deferred ,mythread);<br></code></pre></td></tr></table></figure><ul><li>参数<code>std::launch::async</code>，在调用async函数的时候就开始创建新线程;</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::future&lt;<span class="hljs-type">int</span>&gt; result1 = std::<span class="hljs-built_in">async</span>(std::launch::async ,mythread);<br></code></pre></td></tr></table></figure><h3 id="packaged-task类模板"><a href="#packaged-task类模板" class="headerlink" title="packaged_task类模板"></a>packaged_task类模板</h3><ul><li><code>std::packaged_task</code>的模板参数是各种<strong>可调用对象</strong>，通过packaged_task把各种可调用对象包装起来，方便将来作为线程入口函数来调用；</li><li>packaged_task包装起来的可调用对象还可以直接调用，从这个角度来讲，packaged_task对象也是一个可调用对象；</li><li>通过调用<code>get_future()</code>成员函数得到future对象；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mythread</span><span class="hljs-params">(<span class="hljs-type">int</span> mypar)</span> </span>&#123;<br><span class="hljs-comment">// ......</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;main&quot;</span> &lt;&lt; <span class="hljs-string">&quot;threadid = &quot;</span> &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() &lt;&lt; endl;<br><span class="hljs-comment">// 我们把函数mythread通过packaged_task包装起来</span><br>    <span class="hljs-comment">// 参数是一个int，返回值类型是int</span><br>    <span class="hljs-function">std::packaged_task&lt;<span class="hljs-title">int</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>&gt; <span class="hljs-title">mypt</span><span class="hljs-params">(mythread)</span></span>;<br>    <span class="hljs-comment">// t1是线程</span><br><span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(std::ref(mypt), <span class="hljs-number">1</span>)</span></span>;<br>t1.<span class="hljs-built_in">join</span>();<br>    <span class="hljs-comment">// 用std::future对象接收线程入口函数的返回结果</span><br>std::future&lt;<span class="hljs-type">int</span>&gt; result = mypt.<span class="hljs-built_in">get_future</span>(); <br>cout &lt;&lt; result.<span class="hljs-built_in">get</span>() &lt;&lt; endl;<br>   <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 可调用对象可由函数换成lambda表达式</span><br><span class="hljs-function">std::packaged_task&lt;<span class="hljs-title">int</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>&gt; <span class="hljs-title">mypt</span><span class="hljs-params">([](<span class="hljs-type">int</span> mypar) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">    cout &lt;&lt; mypar &lt;&lt; endl;</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-comment">// ......</span></span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;)</span></span>; <br></code></pre></td></tr></table></figure><h3 id="promise类模板"><a href="#promise类模板" class="headerlink" title="promise类模板"></a>promise类模板</h3><ul><li>我们能够在某个线程中给它赋值，然后我们可以在其他线程中，把这个值取出来；</li><li>即通过<code>std::promise</code>保存一个值，在将来某个时刻把一个future绑定到这个promise上，来得到绑定的值;</li><li>通过调用<code>get_future()</code>成员函数得到future对象；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mythread</span><span class="hljs-params">(std::promise&lt;<span class="hljs-type">int</span>&gt; &amp;tmp, <span class="hljs-type">int</span> clac)</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;mythread() start&quot;</span> &lt;&lt; <span class="hljs-string">&quot;threadid = &quot;</span> &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() &lt;&lt; endl;<br>std::<span class="hljs-function">chrono::milliseconds <span class="hljs-title">dura</span><span class="hljs-params">(<span class="hljs-number">5000</span>)</span></span>;<br>std::this_thread::<span class="hljs-built_in">sleep_for</span>(dura);<br>cout &lt;&lt; <span class="hljs-string">&quot;mythread() end&quot;</span> &lt;&lt; <span class="hljs-string">&quot;threadid = &quot;</span> &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() &lt;&lt; endl;<br><span class="hljs-type">int</span> result = clac;<br>tmp.<span class="hljs-built_in">set_value</span>(result); <span class="hljs-comment">//结果保存到了tmp这个对象中</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br> <br>vector&lt;std::packaged_task&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>)&gt;&gt; task_vec;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>std::promise&lt;<span class="hljs-type">int</span>&gt; myprom;<br><span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(mythread, std::ref(myprom), <span class="hljs-number">180</span>)</span></span>;<br>t1.<span class="hljs-built_in">join</span>(); <span class="hljs-comment">//在这里线程已经执行完了</span><br>std::future&lt;<span class="hljs-type">int</span>&gt; fu1 = myprom.<span class="hljs-built_in">get_future</span>(); <span class="hljs-comment">//promise和future绑定，用于获取线程返回值</span><br><span class="hljs-keyword">auto</span> result = fu1.<span class="hljs-built_in">get</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;result = &quot;</span> &lt;&lt; result &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>使用thread时，必须 join() 或者 detach() 否则程序会报异常</p></blockquote><h2 id="shared-future类模板"><a href="#shared-future类模板" class="headerlink" title="shared_future类模板"></a>shared_future类模板</h2><p>std::shared_future 的 get() 成员函数是<strong>复制</strong>数据；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::future&lt;<span class="hljs-type">int</span>&gt; result = mypt.<span class="hljs-built_in">get_future</span>();<br><br> <span class="hljs-comment">//判断future中的值是不是一个有效值</span><br><span class="hljs-type">bool</span> ifcanget = result.<span class="hljs-built_in">valid</span>();<br><br><span class="hljs-comment">//执行完毕后result_s里有值，而result里空了</span><br><span class="hljs-function">std::shared_future&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result_s</span><span class="hljs-params">(result.share())</span></span>; <br><br><span class="hljs-comment">//或通过get_future返回值直接构造一个shared_future对象</span><br><span class="hljs-function">std::shared_future&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result_s</span><span class="hljs-params">(mypt.get_future())</span></span>;<br><br><span class="hljs-comment">// 可以多次get，因为是赋值</span><br><span class="hljs-keyword">auto</span> myresult1 = result_s.<span class="hljs-built_in">get</span>();<br><span class="hljs-keyword">auto</span> myresult2 = result_s.<span class="hljs-built_in">get</span>();<br></code></pre></td></tr></table></figure><h2 id="atomic类模板"><a href="#atomic类模板" class="headerlink" title="atomic类模板"></a>atomic类模板</h2><ul><li>在多线程中，如果想要执行<strong>不会被打断的程序执行片段</strong>，一般需要使用互斥量；</li><li>可以把<code>std::atomic</code><strong>原子操作</strong>理解成一种：不需要用到互斥量加锁的多线程并发编程方式；</li><li>从效率上来说，原子操作要比互斥量的方式效率要高；</li><li>互斥量的加锁一般是针对一个代码段，而原子操作针对的一般都是<strong>一个变量</strong>；</li><li>std::atomic是用来封装某个类型的值，原子操作一般用于计数或者统计；</li><li>原子操作实质上是不允许在进行原子对象操作时进行CPU的上下文切换；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atomic&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>std::atomic&lt;<span class="hljs-type">int</span>&gt; g_count = <span class="hljs-number">0</span>;  <span class="hljs-comment">//封装了一个类型为int的 对象（值）</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mythread1</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000</span>; i++) &#123;<br>        g_count++;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(mythread1)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(mythread1)</span></span>;<br>    t1.<span class="hljs-built_in">join</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br>    cout &lt;&lt; g_count &lt;&lt; endl;  <span class="hljs-comment">//得到2000000</span><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>C++11</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++11多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LRU算法</title>
    <link href="/2022/07/02/LRU%E7%AE%97%E6%B3%95/"/>
    <url>/2022/07/02/LRU%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>一种按时序来淘汰的缓存淘汰策略！！！</p></blockquote><p>LRU的全称是Least Recently Used，即最近最少使用，我们认为最近使用过的数据是有用的，很久没有使用过的数据是无用的，内存满了就先删除那些很久没有用过的数据。</p><ul><li>显然cache里面的元素要有时序，支持快速查找，支持在任意位置插入和删除元素；</li><li>用节点来表示每一个键值对key-value；</li><li>可以结合双向链表与哈希表，链表里面是节点，哈希表存储key及链表中对应的节点；</li><li>双向链表中靠头部元素是最久未使用的，靠尾部元素是最近使用的；</li><li>添加元素时先查看缓存容量，只能从尾部插入；</li><li>若添加新元素时遇到相同key值，只需更新value值和将链表中节点移动到尾部；</li><li>缓存容量不足时从链表头部删除节点，并且删除umap中对应节点；</li><li>访问某元素后要将该节点位置移动到链表尾部；</li><li>umap中节点的变动只发生在添加新节点和缓存容量不够时；</li><li>注意移除与删除列表中节点的区别；</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-type">int</span> key, value;<br>    Node* prev;<br>    Node* next;<br>    <span class="hljs-comment">//必须添加下面两个构造函数</span><br>    <span class="hljs-built_in">Node</span>() : <span class="hljs-built_in">key</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">value</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">prev</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>    <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> v) : <span class="hljs-built_in">key</span>(k), <span class="hljs-built_in">value</span>(v), <span class="hljs-built_in">prev</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">NodeList</span> &#123;<br>    Node* head;<br>    Node* tail;<br>    <span class="hljs-built_in">NodeList</span>() &#123;<br>        <span class="hljs-comment">//必须要new</span><br>        head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();<br>        tail = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();<br>        head-&gt;next = tail;<br>        tail-&gt;prev = head;<br>    &#125;<br>    <span class="hljs-comment">//添加节点到链表尾部</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addToTail</span><span class="hljs-params">(Node* node)</span> </span>&#123;<br>        node-&gt;prev = tail-&gt;prev;<br>        tail-&gt;prev-&gt;next = node;<br>        node-&gt;next = tail;<br>        tail-&gt;prev = node;<br>    &#125;<br>    <span class="hljs-comment">//从链表中移除某个节点，前提是这个节点必须存在于链表中</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(Node* node)</span> </span>&#123;<br>        node-&gt;prev-&gt;next = node-&gt;next;<br>        node-&gt;next-&gt;prev = node-&gt;prev;<br>    &#125;<br>    <span class="hljs-comment">//删除链表中最久未使用的节点，即靠近头部的那个节点</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cleanOneCache</span><span class="hljs-params">()</span> </span>&#123;<br>        Node* tmp = head-&gt;next;<br>        <span class="hljs-type">int</span> key = tmp-&gt;key;<br>        <span class="hljs-built_in">remove</span>(tmp);<br>        <span class="hljs-keyword">delete</span> tmp;<br>        <span class="hljs-keyword">return</span> key;<br>    &#125;<br>    <span class="hljs-comment">//使某个被访问的元素到链表尾部</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">makeItRecently</span><span class="hljs-params">(Node* node)</span></span>&#123;<br>        <span class="hljs-built_in">remove</span>(node);<br>        <span class="hljs-built_in">addToTail</span>(node);<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    NodeList list;<br>    unordered_map&lt;<span class="hljs-type">int</span>, Node*&gt; umap;<br>    <span class="hljs-type">int</span> capacity;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">LRUCache</span>(<span class="hljs-type">int</span> cap) &#123;<br>        capacity = cap;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(umap.<span class="hljs-built_in">find</span>(key) == umap.<span class="hljs-built_in">end</span>()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Node* node = umap[key];<br>            <span class="hljs-type">int</span> value = node-&gt;value;<br>            <span class="hljs-comment">//更新链表中节点位置</span><br>            list.<span class="hljs-built_in">makeItRecently</span>(node);<br>            <span class="hljs-keyword">return</span> value;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(umap.<span class="hljs-built_in">find</span>(key) != umap.<span class="hljs-built_in">end</span>()) &#123;<br>            Node* cur = umap[key];<br>            <span class="hljs-comment">//更新节点中的value值</span><br>            cur-&gt;value = value;<br>            <span class="hljs-comment">//更新链表中节点位置</span><br>            list.<span class="hljs-built_in">makeItRecently</span>(cur);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//先查看缓存容量是否充足</span><br>            <span class="hljs-keyword">if</span>(capacity == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>            <span class="hljs-keyword">if</span>(umap.<span class="hljs-built_in">size</span>() == capacity) &#123;<br>                <span class="hljs-type">int</span> k = list.<span class="hljs-built_in">cleanOneCache</span>();<br>                umap.<span class="hljs-built_in">erase</span>(k);<br>            &#125;<br>            <span class="hljs-comment">//添加新节点到链表和umap中</span><br>            Node* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(key, value);<br>            list.<span class="hljs-built_in">addToTail</span>(node);<br>            umap[key] = node;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/2022/07/02/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>/2022/07/02/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<ul><li>并查集用来表示各节点间的连通关系；</li><li>有些问题可以抽象用并查集来解决；</li><li>节点用数组表示！！！<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span> &#123;<br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 连接分量的数目</span><br>    <span class="hljs-type">int</span> count;<br>    <span class="hljs-comment">// 记录每棵树的节点个数</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; size;<br>    <span class="hljs-comment">// 记录每个节点的父节点</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; parent;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">UnionFind</span>(<span class="hljs-type">int</span> n) : <span class="hljs-built_in">count</span>(n) &#123;<br>        parent.<span class="hljs-built_in">resize</span>(n);<br>        size.<span class="hljs-built_in">resize</span>(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            parent[i] = i;<br>            size[i] = i;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Count</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 找到该节点所在树的根节点</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findRoot</span> <span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (x != parent[x]) &#123;<br>            <span class="hljs-comment">// 路径压缩</span><br>            parent[x] = parent[parent[x]];<br>            x = parent[x];<br>        &#125;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 连接两个节点</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unionIt</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q)</span> </span>&#123;<br>        <span class="hljs-type">int</span> rootP = <span class="hljs-built_in">findRoot</span>(p);<br>        <span class="hljs-type">int</span> rootQ = <span class="hljs-built_in">findRoot</span>(q);<br>        <span class="hljs-keyword">if</span> (rootP == rootQ) <span class="hljs-keyword">return</span>;<br>        <br>        <span class="hljs-comment">// 小树接在大树之下，更平衡</span><br>        <span class="hljs-keyword">if</span> (size[rootP] &gt;= size[rootQ]) &#123;<br>            parent[rootQ] = rootP;<br>            size[rootP] += size[rootQ];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            parent[rootP] = rootQ;<br>            size[rootQ] += size[rootP];<br>        &#125;<br>        --count;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 确认两个节点是否连接</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isConnected</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q)</span> </span>&#123;<br>        <span class="hljs-type">int</span> rootP = <span class="hljs-built_in">findRoot</span>(p);<br>        <span class="hljs-type">int</span> rootQ = <span class="hljs-built_in">findRoot</span>(q);<br>        <span class="hljs-keyword">if</span> (rootP == rootQ) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++后端个人书单</title>
    <link href="/2022/07/01/C++%E5%90%8E%E7%AB%AF%E4%B8%AA%E4%BA%BA%E4%B9%A6%E5%8D%95/"/>
    <url>/2022/07/01/C++%E5%90%8E%E7%AB%AF%E4%B8%AA%E4%BA%BA%E4%B9%A6%E5%8D%95/</url>
    
    <content type="html"><![CDATA[<table><thead><tr><th align="center"><strong>类别</strong></th><th align="center"><strong>书名</strong></th><th align="center"><strong>作者</strong></th></tr></thead><tbody><tr><td align="center"><strong><em>数学基础</em></strong></td><td align="center">程序员的数学2 概率统计</td><td align="center">[日]平冈和幸</td></tr><tr><td align="center"></td><td align="center">程序员的数学3 线性代数</td><td align="center">[日]平冈和幸</td></tr><tr><td align="center"><strong><em>C++</em></strong></td><td align="center">C++ Primer（中文版 第五版）</td><td align="center">[美]Stanley B. Lippman</td></tr><tr><td align="center"></td><td align="center">Effective C++</td><td align="center">[美]Scott Meyers</td></tr><tr><td align="center"></td><td align="center">More Effective C++</td><td align="center">[美]Scott Meyers</td></tr><tr><td align="center"></td><td align="center">Effective Modern C++</td><td align="center">[美]Scott Meyers</td></tr><tr><td align="center"></td><td align="center">STL源码刨析</td><td align="center">侯捷</td></tr><tr><td align="center"></td><td align="center">深度探索C++对象模型</td><td align="center">[美]Stanley B. Lippman</td></tr><tr><td align="center"><strong><em>数据机构与算法</em></strong></td><td align="center">数据机构与算法分析：C++语言描述（第四版）</td><td align="center">[美]Mark Allen Weiss</td></tr><tr><td align="center"></td><td align="center">算法（第4版）</td><td align="center">[美]Robert Sedgewick</td></tr><tr><td align="center"></td><td align="center">编程珠玑 第2版</td><td align="center">[美]Jon,Bentley</td></tr><tr><td align="center"></td><td align="center">剑指Offer 第2版</td><td align="center">何海涛</td></tr><tr><td align="center"></td><td align="center">labuladong的算法小抄</td><td align="center">付东来</td></tr><tr><td align="center"><strong><em>计算机网络</em></strong></td><td align="center">图解TCP&#x2F;IP 第5版</td><td align="center">[日]竹下隆史</td></tr><tr><td align="center"></td><td align="center">图解HTTP</td><td align="center">[日]上野</td></tr><tr><td align="center"></td><td align="center">计算机网络：自顶向下方法</td><td align="center">[美]James F. kurose</td></tr><tr><td align="center"><strong><em>操作系统</em></strong></td><td align="center">操作系统导论</td><td align="center">[美]Remzi · H.Arpaci-Dusseau</td></tr><tr><td align="center"></td><td align="center">程序员的自我修养 ——链接、转载与库</td><td align="center">俞甲子</td></tr><tr><td align="center"></td><td align="center">鸟哥的Linux私房菜基础学习篇（第四版）</td><td align="center">鸟哥</td></tr><tr><td align="center"></td><td align="center">深入理解计算机系统（原书第3版）</td><td align="center">[美]Randal E. Bryant</td></tr><tr><td align="center"><strong><em>数据库</em></strong></td><td align="center">SQL必知必会 第5版</td><td align="center">[美]Ben,Forta</td></tr><tr><td align="center"></td><td align="center">MySQL是怎样运行的</td><td align="center">小孩子4919</td></tr><tr><td align="center"></td><td align="center">高性能MySQL（第3版）</td><td align="center">Baron Schwartz</td></tr><tr><td align="center"></td><td align="center">MySQL技术内幕：lnnoDB存储引擎（第2版）</td><td align="center">姜承尧</td></tr><tr><td align="center"></td><td align="center">Redis设计与实现</td><td align="center">黄健宏</td></tr><tr><td align="center"><strong><em>设计模式</em></strong></td><td align="center">大话设计模式</td><td align="center">程杰</td></tr><tr><td align="center"><strong><em>网络编程</em></strong></td><td align="center">Linux高性能服务器编程</td><td align="center">游双</td></tr><tr><td align="center"></td><td align="center">linux多线程服务端编程</td><td align="center">陈硕</td></tr><tr><td align="center"><strong><em>应用</em></strong></td><td align="center">数据密集型应用系统设计</td><td align="center">[美]Martin Kleppmann</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>计算机学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习路线</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo常用命令</title>
    <link href="/2022/07/01/hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/07/01/hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="前置安装"><a href="#前置安装" class="headerlink" title="前置安装"></a>前置安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm i -g hexo-cli<br><br>npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 新建一个名为new_post的post</span><br>hexo n new_post<br><br><span class="hljs-comment"># 清楚缓存</span><br>hexo clear<br><br><span class="hljs-comment"># 生成</span><br>hexo g<br><br><span class="hljs-comment"># 发布到本地</span><br>hexo s<br><br><span class="hljs-comment"># 发布到github</span><br>hexo d<br></code></pre></td></tr></table></figure><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 本地发布</span><br>hexo clear &amp;&amp; hexo g &amp;&amp; hexo s<br><br><span class="hljs-comment"># github发布</span><br>hexo clear &amp;&amp; hexo g &amp;&amp; hexo d<br><br><span class="hljs-comment"># 删除文章</span><br>删除 <span class="hljs-string">&quot;sourc/_posts&quot;</span> 文件夹中相应的md文件<br></code></pre></td></tr></table></figure><h2 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h2><p>格式举例如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">title:</span> <span class="hljs-string">C++给常用数据结构传入排序算法</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2022-07-01 16:22:30</span><br><span class="hljs-attr">tags:</span> <br>  <span class="hljs-bullet">-</span> <span class="hljs-string">刷题</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">C++</span><br><span class="hljs-attr">categories:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">C++</span><br><span class="hljs-attr">index_img:</span> <span class="hljs-string">/post_img/02.jpg</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++给常用数据结构传入排序算法</title>
    <link href="/2022/07/01/C++%E7%BB%99%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BC%A0%E5%85%A5%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2022/07/01/C++%E7%BB%99%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BC%A0%E5%85%A5%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>在刷<a href="https://leetcode-cn.com/problems/top-k-frequent-elements/">leetcode347题</a>时，遇到c++自定义操作的知识点，总结如下：</p><h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><p><strong>在类中</strong>定义了如下比较函数，但<strong>定义有序容器时</strong>编译不通过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">myComparison</span><span class="hljs-params">(<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; lhs, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; rhs)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> lhs.second &gt; rhs.second;<br>&#125;<br><br>priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;,<br>  <span class="hljs-keyword">decltype</span>(myComparison)*&gt; <span class="hljs-built_in">pri_que</span>(myComparison);<br></code></pre></td></tr></table></figure><p>编译报错如下：</p><blockquote><p>error: reference to non-static member function must be called 即必须调用对非静态成员函数的引用</p></blockquote><h3 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h3><p>所以比较函数定义错误，正确解法如下：</p><h4 id="1-定义为静态成员函数"><a href="#1-定义为静态成员函数" class="headerlink" title="1.定义为静态成员函数"></a>1.定义为静态成员函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">myComparison</span><span class="hljs-params">(<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; lhs, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; rhs)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> lhs.second &gt; rhs.second;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-将比较函数定义在类外面"><a href="#2-将比较函数定义在类外面" class="headerlink" title="2.将比较函数定义在类外面"></a>2.将比较函数定义在类外面</h4><p>注意函数声明在类前。</p><h4 id="3-运用仿函数"><a href="#3-运用仿函数" class="headerlink" title="3.运用仿函数"></a>3.运用仿函数</h4><p>注意添加const。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">myComparison</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; lhs, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; rhs)</span> <span class="hljs-type">const</span> </span>&#123;<br><span class="hljs-keyword">return</span> lhs.second &gt; rhs.second;<br>&#125;<br>&#125;;<br><br>priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, myComparison&gt; pri_que;<br></code></pre></td></tr></table></figure><hr><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><h4 id="1-容器的操作自定义处"><a href="#1-容器的操作自定义处" class="headerlink" title="1.容器的操作自定义处"></a>1.容器的操作自定义处</h4><blockquote><p>priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, decltype(myComparison)*&gt; pri_que(myComparison);</p></blockquote><ul><li>为了使用自己定义的操作，在定义容器时必须提供两个类型：<strong>关键字类型</strong>即<code>pair&lt;int, int&gt;</code>，<strong>比较操作类型</strong>即指向myComparison的指针<code>decltype(myComparison)*</code>；</li><li>此处使用<code>decltype</code>指出自定义操作的类型，但当使用decltype来获取一个函数指针类型时，须加上一个<code>*</code>号来表示使用一个给定函数类型的指针；</li><li>定义有序容器时，<code>vector&lt;pair&lt;int, int&gt;&gt;</code>表示<strong>基于vector构造</strong>优先队列；</li><li><code>pri_que(myComparison)</code>表示用myComparison来初始化pri_que对象，即向pri_que添加元素时，调用myComparison来排序；</li><li>用<code>pri_que(myComparison)</code>代替<code>pri_que(&amp;myComparison)</code>因为使用函数名字会自动转化为指针；</li></ul><h4 id="2-比较函数自定义处"><a href="#2-比较函数自定义处" class="headerlink" title="2.比较函数自定义处"></a>2.比较函数自定义处</h4><blockquote><p>return lhs.second &gt; rhs.second;</p></blockquote><ul><li><code>&gt;</code>此比较符号表示在优先队列中左大于右就会建立小顶堆；</li></ul><h3 id="扩展："><a href="#扩展：" class="headerlink" title="扩展："></a>扩展：</h3><h4 id="1-向算法传递函数"><a href="#1-向算法传递函数" class="headerlink" title="1.向算法传递函数"></a>1.向算法传递函数</h4><p>即使用标准库的算法时，传入参数使用自己的操作，示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isShorter</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s1, <span class="hljs-type">const</span> string&amp; s2)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> s1.<span class="hljs-built_in">size</span>() &lt; s2.<span class="hljs-built_in">size</span>();<br>&#125;<br><span class="hljs-built_in">sort</span>(words.<span class="hljs-built_in">begin</span>(), words.<span class="hljs-built_in">end</span>(), isShorter);<br></code></pre></td></tr></table></figure><h4 id="2-在算法中使用lambda表达式"><a href="#2-在算法中使用lambda表达式" class="headerlink" title="2.在算法中使用lambda表达式"></a>2.在算法中使用lambda表达式</h4><p>即编写与isShorter函数功能相同的lambda表达式，示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">sort</span>(words.<span class="hljs-built_in">begin</span>(), words.<span class="hljs-built_in">end</span>(),<br>    [](<span class="hljs-type">const</span> string&amp; s1, <span class="hljs-type">const</span> string&amp; s2)<br>     &#123;<span class="hljs-keyword">return</span> s1.<span class="hljs-built_in">size</span>() &lt; s2.<span class="hljs-built_in">size</span>();&#125;);<br></code></pre></td></tr></table></figure><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul><li><a href="https://programmercarl.com/">代码随想录</a>博客</li><li>《C++primer》</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
