<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Makefile使用</title>
    <link href="/2022/07/23/Makefile%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/07/23/Makefile%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul><li>当一个工程里面的源文件非常多时，手动敲命令就比较麻烦，就可以使用makefile；</li><li>Makefile 文件定义了一系列的规则来指定哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为 Makefile 文件就像一个 Shell 脚本一样，也可以执行操作系统的命令；</li><li>Makefile 带来的好处就是“自动化编译” ，一旦写好，只需要一个 make 命令，整个工程完全自动编译；</li><li><strong>make</strong> 是一个命令工具，是一个解释 Makefile 文件中指令的命令工具；</li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="文件命名"><a href="#文件命名" class="headerlink" title="文件命名"></a>文件命名</h3><p>makefile 或者 Makefile</p><h3 id="Makefile-规则"><a href="#Makefile-规则" class="headerlink" title="Makefile 规则"></a>Makefile 规则</h3><ul><li><p>一个 Makefile 文件中可以有一个或者多个规则</p></li><li><ul><li>目标 … : 依赖 …</li><li>命令（Shell 命令）</li><li>…</li></ul></li><li><p>目标：最终要生成的文件（伪目标除外）</p></li><li><p>依赖：生成目标所需要的文件或是目标</p></li><li><p>命令：通过执行命令对依赖操作生成目标（命令前必须 Tab 缩进）</p></li><li><p>Makefile 中的其它规则一般都是为第一条规则服务的</p></li><li><p>自定义变量</p></li><li><ul><li>定义：变量名&#x3D;变量值，例如 var&#x3D;hello</li><li>使用：获取变量的值，即<code> $(var)</code></li></ul></li><li><p>预定义变量</p></li><li><ul><li>AR : 归档维护程序的名称，默认值为 ar</li><li>CC : C 编译器的名称，默认值为 cc</li><li>CXX : C++ 编译器的名称，默认值为 g++</li><li>……</li></ul></li></ul><h2 id="简单举例"><a href="#简单举例" class="headerlink" title="简单举例"></a>简单举例</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs makefile">CXX = g++<br>CFLAGS = -std=c++17 -O2 -g -Wall<br><br>TARGET = serverApp<br>OBJS = ../code/buffer/*.cpp ../code/http/*.cpp ../code/logsys/*.cpp \<br>       ../code/pool/*.cpp ../code/server/*.cpp ../code/timer/*.cpp \<br>       ../code/json/*.cpp ../main.cpp<br><br><span class="hljs-section">all: </span><br><span class="hljs-variable">$(CXX)</span> <span class="hljs-variable">$(CFLAGS)</span> <span class="hljs-variable">$(OBJS)</span> -o ../<span class="hljs-variable">$(TARGET)</span>  -pthread -lmysqlclient<br><br><span class="hljs-section">clean:</span><br>rm -rf ../<span class="hljs-variable">$(TARGET)</span><br></code></pre></td></tr></table></figure><p>一般我们写好makefile后只需运行：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">make</span><br></code></pre></td></tr></table></figure><p>若想清理生成的文件：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">make clean</span><br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Makefile</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GNU编译工具使用</title>
    <link href="/2022/07/23/GNU%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/07/23/GNU%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">sudo apt update<br># 通过以下命令安装编译器和调试器<br>sudo apt install build-essential gdb<br><br># 查看版本号<br>gcc --version<br>g++ --version<br>gdb --version<br></code></pre></td></tr></table></figure><h2 id="gcc-x2F-g-基本用法"><a href="#gcc-x2F-g-基本用法" class="headerlink" title="gcc&#x2F;g++基本用法"></a>gcc&#x2F;g++基本用法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">gcc filename -o outputfileName<br><br><span class="hljs-meta"># gdb支持</span><br>gcc filename -g -o outputfileName<br></code></pre></td></tr></table></figure><h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><blockquote><p>生成**.i** 文件</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># -E 选项指示编译器仅对输入文件进行预处理</span><br>g++ -E test.cpp -o test.i<br></code></pre></td></tr></table></figure><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><blockquote><p>生成**.s** 文件</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># -S 编译选项告诉 g++ 在为 C++ 代码产生了汇编语言文件后停止编译</span><br><span class="hljs-comment"># g++ 产生的汇编语言文件的缺省扩展名是 .s </span><br>g++ -S test.i -o test.s<br></code></pre></td></tr></table></figure><h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><blockquote><p>生成**.o** 文件</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># -c 选项告诉 g++ 仅把源代码编译为机器语言的目标代码</span><br><span class="hljs-comment"># 缺省时 g++ 建立的目标代码文件有一个 .o 的扩展名。</span><br>g++ -c test.s -o test.o<br></code></pre></td></tr></table></figure><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><blockquote><p>生成<strong>可执行</strong> 文件</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># -o 编译选项来为将产生的可执行文件用指定的文件名</span><br>g++ test.o -o <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><h2 id="重要参数"><a href="#重要参数" class="headerlink" title="重要参数"></a>重要参数</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">-E 预处理指定的源文件，不进行编译<br>-S 编译指定的源文件，但是不进行汇编<br>-c 编译、汇编指定的源文件，但是不进行链接<br>[file2] -o [file1] 将文件 file2 编译成可执行文件 file1，指定输出文件名<br>-I directory 指定 include 包含文件的搜索目录<br>-g 在编译的时候，生成调试信息，该程序可以被调试器调试<br>-D 在程序编译的时候，指定一个宏<br>-w 不生成任何警告信息<br>-Wall 生成所有警告信息<br>-O[n] n的取值范围：0~3，编译器的优化选项的4个级别，-O0表示没有优化，-O1为缺省值，-O3优化级别最高<br>-l 在程序编译的时候，指定使用的库<br>-L 指定编译的时候，搜索的库的路径<br>-fPIC/fpic 生成与位置无关的代码<br>-shared 生成共享目标文件，通常用在建立共享库时<br>-std 指定C方言，如:-std=c++11<br></code></pre></td></tr></table></figure><h2 id="静态库与动态库"><a href="#静态库与动态库" class="headerlink" title="静态库与动态库"></a>静态库与动态库</h2><ul><li>库文件是计算机上的一类文件，可以简单的把库文件看成一种代码仓库，它提供给使用者一些可以直接拿来用的变量、函数或类。</li><li>库是特殊的一种程序，只是库不能单独运行。</li><li>库文件有两种，静态库和动态库（共享库），区别是：静态库在程序的链接阶段被<strong>复制</strong>到了程序中；动态库在链接阶段没有被复制到程序中，而是程序在运行时由系统动态加载到<strong>内存</strong>中供程序调用。</li><li>库的好处：代码保密、方便部署和分发。</li></ul><h3 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">命名规则：<br>◆ Linux : libxxx.a<br>lib : 前缀（固定）<br>xxx : 库的名字，自己起<br>.a  : 后缀（固定）<br>◆ Windows : libxxx.lib<br><br>制作：<br><span class="hljs-comment"># gcc 获得.o 文件</span><br><span class="hljs-comment"># 将.o 文件打包，使用 ar 工具（archive）</span><br>ar rcs libxxx.a xxx.o xxx.o<br></code></pre></td></tr></table></figure><h3 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">命名规则：<br>◆ Linux : libxxx.so<br>lib : 前缀（固定）<br>xxx : 库的名字，自己起<br>.so : 后缀（固定）<br>在Linux下是一个可执行文件<br>◆ Windows : libxxx.dll<br><br>制作：<br><span class="hljs-comment"># gcc 得到 .o 文件，得到和位置无关的代码</span><br>gcc -c –fpic/-fPIC a.c b.c<br><span class="hljs-comment"># gcc 得到动态库</span><br>gcc -shared a.o b.o -o libcalc.so<br></code></pre></td></tr></table></figure><h2 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h2><p>功能：</p><ul><li>设置断点(断点可以是条件表达式)</li><li>使程序在指定的代码行上暂停执行，便于观察</li><li>单步执行程序，便于调试</li><li>查看程序中变量值的变化</li><li>动态改变程序的执行环境</li><li>分析崩溃程序产生的core文件</li></ul><blockquote><p>指令可以简写，是第一个字符</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 启动</span><br>gdb outputfileName<br><br><span class="hljs-comment"># 退出</span><br>quit<br><br><span class="hljs-comment"># GDB 使用帮助</span><br><span class="hljs-built_in">help</span><br><br><span class="hljs-comment"># 查看当前文件代码</span><br>list/l （从默认位置显示）<br>list/l 行号 （从指定的行显示）<br>list/l 函数名（从指定的函数显示）<br><br><span class="hljs-comment"># 设置断点</span><br>b/break 行号<br>b/break 函数名<br>b/break 文件名:行号<br>b/break 文件名:函数<br><span class="hljs-comment"># 删除断点</span><br>d/del/delete 断点编号<br><span class="hljs-comment"># 设置断点无效</span><br>dis/disable 断点编号<br><span class="hljs-comment"># 设置断点生效</span><br>ena/enable 断点编号<br><span class="hljs-comment"># 设置条件断点（一般用在循环的位置）</span><br>b/break 10 <span class="hljs-keyword">if</span> i==5<br><br><span class="hljs-comment"># 运行</span><br>start（程序停在第一行）<br>run（遇到断点才停）<br><br><span class="hljs-comment"># 暂停后继续，到下一个断点停</span><br>c/continue<br><br><span class="hljs-comment"># 通过命令&#x27;next&#x27; 和&#x27;step&#x27; 逐行运行程序。</span><br><span class="hljs-comment"># Next 将控件严格保持在当前范围内</span><br>n/next <span class="hljs-comment"># 向下执行一行代码（不会进入函数体）</span><br><br><span class="hljs-comment"># 向下单步调试（遇到函数进入函数体）</span><br>s/step<br>finish（跳出函数体）<br><br><span class="hljs-comment"># 变量操作</span><br>p/print 变量名（打印变量值）<br>ptype 变量名（打印变量类型）<br><br><span class="hljs-comment"># 修改变量</span><br><span class="hljs-built_in">set</span> &lt;var&gt; = &lt;value&gt;<br><br><span class="hljs-comment"># 设置观察点，每当发生更改时，程序都会暂停并为您提供更改的详细信息。</span><br><span class="hljs-comment"># 只能在变量处于范围内时为其设置观察点</span><br>watch &lt;var&gt;<br><br></code></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://b23.tv/tWqKrC">https://b23.tv/tWqKrC</a></p></li><li><p>牛客网C++教学视频</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>GNU</tag>
      
      <tag>GCC</tag>
      
      <tag>G++</tag>
      
      <tag>GDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux下Vim编辑器的使用</title>
    <link href="/2022/07/23/Linux%E4%B8%8BVim%E7%BC%96%E8%BE%91%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/07/23/Linux%E4%B8%8BVim%E7%BC%96%E8%BE%91%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="command-mode"><a href="#command-mode" class="headerlink" title="command mode"></a>command mode</h2><blockquote><p> 首先进入的就是命令模式。</p></blockquote><h3 id="模式切换"><a href="#模式切换" class="headerlink" title="模式切换"></a>模式切换</h3><ul><li><strong>i</strong> 切换到输入模式，以输入字符；</li><li><strong>:</strong> 切换到底线命令模式，以在最后一行输入命令；</li></ul><h3 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h3><ul><li><strong>方向键</strong> 移动光标；</li><li><strong>h&#x2F;j&#x2F;k&#x2F;l</strong> 光标左、下、上、右移动一个字符，30j表示下移光标30行；</li><li><strong>pg up&#x2F;dn</strong> 上下翻页；</li><li><strong>ctrl + b&#x2F;f</strong> 上下翻页；</li><li><strong>ctrl + u&#x2F;d</strong> 上下翻半页；</li><li><strong>n + space</strong> 光标向右移动n个字符；</li><li><strong>H&#x2F;M&#x2F;L</strong> 光标移动到整个屏幕的最上方、中间、最下方那一行的第一个字符；</li><li><strong>G&#x2F;gg</strong> 光标移动到最后一行、第一行；</li></ul><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><ul><li><strong>&#x2F;word</strong> 向光标之下搜索word这个字符串，按<strong>n&#x2F;N</strong>后依次找到出现的目标字符串；</li><li><strong>?word</strong> 向光标之上搜索word这个字符串，按<strong>n&#x2F;N</strong>后依次找到出现的目标字符串；</li></ul><h3 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h3><ul><li><strong>x</strong> 删除当前光标所在字符，<strong>X</strong> 删除当前光标前一个字符；</li><li><strong>dd</strong> 剪切光标所在的一行，<strong>ndd</strong> 剪切光标所在的向下n行；</li><li><strong>yy</strong> 复制光标所在的一行，<strong>nyy</strong> 复制光标所在的向下n行；</li><li><strong>p&#x2F;P</strong> 在光标下&#x2F;上一行粘贴；</li><li><strong>u</strong> 复原前一个操作；</li></ul><h2 id="insert-mode"><a href="#insert-mode" class="headerlink" title="insert mode"></a>insert mode</h2><ul><li><strong>enter</strong> 回车键，换行；</li><li><strong>backspace</strong> 退格键，删除光标前一个字符；</li><li><strong>delete</strong> 删除键，删除光标后一个字符；</li><li><strong>方向键</strong> 移动光标；</li><li><strong>home&#x2F;end</strong> 移动光标到行首行尾；</li><li><strong>pg up&#x2F;dn</strong> 上下翻页；</li><li><strong>esc</strong> 退出输入模式，切换到命令模式；</li></ul><h2 id="lastline-mode"><a href="#lastline-mode" class="headerlink" title="lastline mode"></a>lastline mode</h2><blockquote><p>命令在输入回车键后运行。</p></blockquote><ul><li><strong>esc</strong> 退出底线模式，切换到命令模式；</li><li><strong>q</strong> 退出程序；</li><li><strong>q!</strong> 强制退出程序并且不保存；</li><li><strong>w</strong> 保存文件；</li><li><strong>w!</strong> 强制保存文件；</li><li><strong>wq</strong> 保存文件后离开；</li><li><strong>wq!</strong> 强制保存文件后离开；</li><li><strong>w filename</strong> 将编辑过的文件另存为filename这个文件；</li><li><strong>set nu</strong> 显示行号；</li><li><strong>set nonu</strong> 取消显示行号；</li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git使用和常用命令</title>
    <link href="/2022/07/23/Git%E4%BD%BF%E7%94%A8%E5%92%8C%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/07/23/Git%E4%BD%BF%E7%94%A8%E5%92%8C%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h3 id="第一次下载"><a href="#第一次下载" class="headerlink" title="第一次下载"></a>第一次下载</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">apt-get install git<br><br>git config --global user.name <span class="hljs-string">&quot;zyue&quot;</span>        <span class="hljs-comment"># your name</span><br>git config --global user.email <span class="hljs-string">&quot;3506656950@qq.com&quot;</span>    <span class="hljs-comment"># your email</span><br>git config --global core.editor vim            <span class="hljs-comment"># your favourite editor</span><br>git config --global color.ui <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git init<br></code></pre></td></tr></table></figure><h3 id="添加文件到git仓库"><a href="#添加文件到git仓库" class="headerlink" title="添加文件到git仓库"></a>添加文件到git仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 第一步</span><br>git add filename<br><span class="hljs-comment"># 全部文件</span><br>git add .<br><br><span class="hljs-comment"># 第二步</span><br>git commit -m <span class="hljs-string">&quot;此次提交说明&quot;</span><br><br><span class="hljs-comment"># add把要提交的修改放在暂存区，commit一次性把暂存区的所有修改提交到分支</span><br></code></pre></td></tr></table></figure><h3 id="仓库状态"><a href="#仓库状态" class="headerlink" title="仓库状态"></a>仓库状态</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 当前仓库状态</span><br>git status <br><br><span class="hljs-comment"># 比较同一个文件在不同版本中的区别</span><br>git diff filename<br></code></pre></td></tr></table></figure><h3 id="查看所有存档"><a href="#查看所有存档" class="headerlink" title="查看所有存档"></a>查看所有存档</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">log</span> <br><br><span class="hljs-comment"># 输出的 HEAD 表示当前版本</span><br><span class="hljs-comment"># 输出的 HEAD^ 表示上一个版本</span><br><span class="hljs-comment"># 输出的 HEAD^^ 表示上上个版本</span><br><span class="hljs-comment"># 输出的 HEAD~N 表示上N个版本</span><br><br><span class="hljs-comment"># 简化输出</span><br>git <span class="hljs-built_in">log</span> --pretty=oneline<br></code></pre></td></tr></table></figure><h3 id="回退版本"><a href="#回退版本" class="headerlink" title="回退版本"></a>回退版本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset --hard HEAD^<br><span class="hljs-comment"># 或</span><br>git reset --hard 版本号前几位<br><br><span class="hljs-comment"># 注意shell关闭后就回不到将来了</span><br></code></pre></td></tr></table></figure><h3 id="查看历史命令"><a href="#查看历史命令" class="headerlink" title="查看历史命令"></a>查看历史命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reflog<br></code></pre></td></tr></table></figure><h3 id="远程github"><a href="#远程github" class="headerlink" title="远程github"></a>远程github</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建ssh key</span><br>ssh-keygen -t rsa -C <span class="hljs-string">&quot;邮箱账号&quot;</span><br><span class="hljs-comment"># id_rsa.pub是公钥，用于添加远程账户</span><br><br><span class="hljs-comment"># ssh比https方便</span><br>git remote add origin git@github.com:H-ZYUE/learn_Ubuntu2104.git <span class="hljs-comment"># 关联仓库</span><br>git branch -m main <span class="hljs-comment"># 改名当前分支为main，master也可以</span><br>git push -u origin main <span class="hljs-comment"># 第一次加 -u，推送到远程仓库</span><br><br><span class="hljs-comment"># 后续上传</span><br>git push origin main<br><br>git remote <span class="hljs-built_in">rm</span> origin <span class="hljs-comment">#删除原来关联</span><br>git remote -v <span class="hljs-comment">#查看已有关联</span><br><br><span class="hljs-comment"># 从github克隆</span><br>git <span class="hljs-built_in">clone</span> 仓库名字<br></code></pre></td></tr></table></figure><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建并切换分支，dev是分支名</span><br><span class="hljs-comment"># git checkout -b dev</span><br><br><span class="hljs-comment"># -b表示创建并切换，上述等同于如下</span><br><span class="hljs-comment"># git branch dev</span><br><span class="hljs-comment"># git checkout dev </span><br><br><span class="hljs-comment"># 创建并切换到创建的分支</span><br>git switch -c branchName<br><br><span class="hljs-comment"># 切换到已有分支</span><br>git switch branchName<br><br><span class="hljs-comment"># 查看分支，*指示当前分支</span><br>git branch<br><br><span class="hljs-comment"># 当在dev分支完成工作后可以合并分支</span><br><span class="hljs-comment"># 合并指定分支到当前分支</span><br>git merge dev <span class="hljs-comment"># 此时在master分支下</span><br><br><span class="hljs-comment"># 合并完可以删除不需要的分支</span><br>git branch -d dev<br><br><span class="hljs-comment"># 通常使用分支完成某个任务，成功完成任务后合并其到master分支，再删除不需要的分支</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>命令</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>Github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux常用命令笔记</title>
    <link href="/2022/07/23/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/07/23/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="管理用户"><a href="#管理用户" class="headerlink" title="管理用户"></a>管理用户</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 按默认值添加用户</span><br>useradd userName<br><br><span class="hljs-comment"># 在root环境下，root帮userName设置密码</span><br>passwd userName<br><span class="hljs-comment"># 或</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;密码&quot;</span> | passwd --stdin userName<br><br><span class="hljs-comment"># userName这个用户第一次登录时（默认密码是用户名），自己设置自己密码</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;userName&quot;</span> | passwd --stdin userName<br>chage -d 0 userName<br>chage -l userName | <span class="hljs-built_in">head</span> -n 3<br><span class="hljs-comment"># 不过这一般还需改psaawd和shadow权限</span><br><br><span class="hljs-comment"># 删除用户</span><br>userdel -r userName<br><span class="hljs-comment"># 最好删除前找到属于要删用户的文件</span><br>find / -user userName<br></code></pre></td></tr></table></figure><h2 id="权限切换"><a href="#权限切换" class="headerlink" title="权限切换"></a>权限切换</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 普通用户要想使用sudo，先用visudo编辑/etc/sudoers文件</span><br>visudo <span class="hljs-comment"># 会打开sudoers文件</span><br><span class="hljs-comment"># 或</span><br>vim /etc/sudoers<br><br><span class="hljs-comment"># 指定用户sudo，添加下行</span><br>userName ALL=(ALL) ALL<br><span class="hljs-comment"># 指定用户免密sudo，添加下行</span><br>userName ALL=(ALL) NOPASSWD:ALL<br><br><span class="hljs-comment"># 某用户组免密sudo，添加下行</span><br>%groupName ALL=(ALL) NOPASSWD:ALL<br><br><span class="hljs-comment"># 经由 sudo 所执行的指令就好像是 root 亲自执行</span><br>sudo 指令 <span class="hljs-comment"># 此处输入的密码是当前用户的密码，也可以设置成不输入密码执行sudo</span><br><br><span class="hljs-comment"># 系统第一次使用su切换至root权限时，先设置密码</span><br>sudo passwd root<br><br><span class="hljs-comment"># su 是最简单的用户切换命令</span><br>su - <span class="hljs-comment"># 环境和权限都切换到root</span><br><br><span class="hljs-comment"># 使用 exit 命令进行手动切换回原用户</span><br><span class="hljs-built_in">exit</span><br></code></pre></td></tr></table></figure><h2 id="压缩-x2F-解压"><a href="#压缩-x2F-解压" class="headerlink" title="压缩&#x2F;解压"></a>压缩&#x2F;解压</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 对于bzip2的解压缩</span><br><br><span class="hljs-comment"># 压缩</span><br>tar -jcv -f filename.tar.bz2 要被压缩的文件或目录<br><br><span class="hljs-comment"># 解压</span><br>tar -jxv -f filename.tar.bz2 -C 要解压在那个目录的位置<br><br><span class="hljs-comment"># -----------------------------------</span><br>-j <span class="hljs-comment"># bzip2，即*.tar.bz2</span><br>-J <span class="hljs-comment"># xz，即*.tar.xz</span><br>-z <span class="hljs-comment"># gzip，即*.tar.gz</span><br></code></pre></td></tr></table></figure><h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 基于RPM</span><br><span class="hljs-comment"># 安装需root权限</span><br><br><span class="hljs-comment"># yum 在线安装</span><br>yum search appName <span class="hljs-comment"># 在yum服务器上找这个软件</span><br>yum install appName <span class="hljs-comment"># 安装软件</span><br>yum update appName <span class="hljs-comment"># 升级这个软件</span><br>yum remove appName <span class="hljs-comment"># 删除软件</span><br><br><span class="hljs-comment"># rpm 查询与效验，也可以使用.rpm文件安装</span><br>rpm -ivh packageName.rpm <span class="hljs-comment"># 安装</span><br>rpm -qa <span class="hljs-comment"># 查询已安装软件</span><br>rpm -q appName <span class="hljs-comment"># 查询是否安装appName这个软件</span><br>rpm -e appName <span class="hljs-comment"># 删除软件</span><br><br><span class="hljs-comment"># -----------------------------------------------</span><br><span class="hljs-comment"># dpkg系</span><br>sudo apt-get update   <span class="hljs-comment"># 取回更新的软件包列表信息</span><br>sudo apt-get upgrade<span class="hljs-comment"># 升级所有软件包</span><br><br>sudo apt-get install packagename<span class="hljs-comment"># 安装软件包</span><br>sudo apt-get remove packagename  <span class="hljs-comment"># 卸载软件包</span><br>sudo apt-get purge packagename  <span class="hljs-comment"># 卸载并清除软件包的配置</span><br><br>sudo dpkg -i filename.deb <span class="hljs-comment"># 安装本地二进制deb包</span><br>sudo dpkg -r packagename <span class="hljs-comment"># 卸载软件包</span><br><br>sudo apt-get clean            <span class="hljs-comment"># 删除所有已下载的包文件</span><br></code></pre></td></tr></table></figure><h2 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 文件属性：</span><br><span class="hljs-comment"># 读r 4</span><br><span class="hljs-comment"># 写w 2</span><br><span class="hljs-comment"># 执行   x 1</span><br><span class="hljs-comment"># 目录  d</span><br><span class="hljs-comment"># 文件  -</span><br><span class="hljs-comment"># 链接文件   l</span><br><br><span class="hljs-comment"># 修改用户组，-R递归修改</span><br><span class="hljs-built_in">chgrp</span> 用户组名 文件或目录名<br><br><span class="hljs-comment"># 修改拥有者，-R递归修改</span><br><span class="hljs-built_in">chown</span> 用户名 文件或目录名<br><span class="hljs-built_in">chown</span> 用户名:用户组名 文件或目录名 <span class="hljs-comment"># 也可同时修改用户组</span><br><br><span class="hljs-comment"># 修改权限，-R递归修改</span><br><span class="hljs-built_in">chmod</span> 777 文件名<br><span class="hljs-comment"># u,g,o,这3种身份，a是全部</span><br><span class="hljs-built_in">chmod</span> u=rwx,g=rx,0=r 文件名 <span class="hljs-comment"># =是设置</span><br><span class="hljs-built_in">chmod</span> a+w 文件名 <span class="hljs-comment"># +是加入某权限</span><br><span class="hljs-built_in">chmod</span> g-x 文件名 <span class="hljs-comment"># -是取消某权限</span><br><br><span class="hljs-comment"># 文件隐藏属性</span><br><span class="hljs-comment"># 常用的是+i，+a</span><br>chattr +i 文件名 <span class="hljs-comment"># 使此文件无法被修改</span><br>chattr -i 文件名 <span class="hljs-comment"># 使此文件可修改</span><br><span class="hljs-comment"># a是只能添加，不能修改和删除</span><br></code></pre></td></tr></table></figure><h2 id="变量设置"><a href="#变量设置" class="headerlink" title="变量设置"></a>变量设置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看变量，echo有显示打印的意思，$后接变量名</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$PATH</span><br><span class="hljs-comment"># 或</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;PATH&#125;</span><br><br><span class="hljs-comment"># 添加PATH路径</span><br>PATH=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;PATH&#125;</span>:/somedirpath&quot;</span><br><br><span class="hljs-comment"># 设置变量，=号两边无空格</span><br>var=something<br><span class="hljs-comment"># 变量内容有空格时</span><br>var=<span class="hljs-string">&quot;lang is <span class="hljs-variable">$LANG</span>&quot;</span> <span class="hljs-comment"># 双引号保留原有属性</span><br>var=<span class="hljs-string">&#x27;lang is $LANG&#x27;</span> <span class="hljs-comment"># 单引号不保留原有属性</span><br><br><span class="hljs-comment"># 扩为环境变量</span><br><span class="hljs-built_in">export</span> var<br><br><span class="hljs-comment"># 取消变量</span><br><span class="hljs-built_in">unset</span> var<br><br><span class="hljs-comment"># 查看环境变量</span><br><span class="hljs-built_in">env</span> <span class="hljs-comment"># 或export</span><br><br><span class="hljs-comment"># 查看环境变量与自定义变量</span><br><span class="hljs-built_in">set</span><br></code></pre></td></tr></table></figure><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 终端后台</span><br><br><span class="hljs-comment"># 在命令最后加上&amp;，表示后台执行</span><br>somecommand &amp; <br><span class="hljs-comment"># 如果命令有输出，可重定向数据流</span><br><br><span class="hljs-comment"># 将目前任务丢到后台中，暂停</span><br>ctrl-z<br><br><span class="hljs-comment"># 查看后台任务</span><br><span class="hljs-built_in">jobs</span> -l<br><br><span class="hljs-comment"># 将后台任务拿到前台，%可选</span><br><span class="hljs-built_in">fg</span> %jobnumber<br><br><span class="hljs-comment"># 将后台任务状态变成运行中</span><br><span class="hljs-built_in">bg</span> %jobnumber<br><br><span class="hljs-comment"># 删除任务</span><br><span class="hljs-built_in">kill</span> -9 %jobnumber <span class="hljs-comment"># 强制删除</span><br><span class="hljs-built_in">kill</span> -15 %jobnumber <span class="hljs-comment"># 正常删除</span><br><br><span class="hljs-comment"># -------------------------------------------------</span><br><br><span class="hljs-comment"># 系统后台</span><br><span class="hljs-built_in">nohup</span> somecommand &amp; <span class="hljs-comment"># 注销登录后也继续运行</span><br><br><span class="hljs-comment"># -------------------------------------------------</span><br><br><span class="hljs-comment"># 查看自己bash相关进程</span><br>ps -l<br><br><span class="hljs-comment"># 查看系统中所有运行进程</span><br>ps aux<br></code></pre></td></tr></table></figure><h2 id="系统服务"><a href="#系统服务" class="headerlink" title="系统服务"></a>系统服务</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 管理服务unit</span><br>systemctl <span class="hljs-built_in">command</span> unit<br><span class="hljs-comment"># command有(常用)：</span><br>status   <span class="hljs-comment"># 查看状态</span><br>start    <span class="hljs-comment"># 立即启动</span><br>stop     <span class="hljs-comment"># 立即关闭</span><br>restart  <span class="hljs-comment"># 重启</span><br>reload   <span class="hljs-comment"># 重新加载配置文件</span><br><span class="hljs-built_in">enable</span>   <span class="hljs-comment"># 开机自启</span><br><span class="hljs-built_in">disable</span> <span class="hljs-comment"># 不开机自启</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KMP算法</title>
    <link href="/2022/07/23/KMP%E7%AE%97%E6%B3%95/"/>
    <url>/2022/07/23/KMP%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><ul><li>KMP算法用来在<strong>文本串</strong>中匹配<strong>模式串</strong>，查找模式串出现的位置。</li><li>KMP的主要思想是当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。</li><li>需要用到next数组，即前缀表。前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。<ul><li>前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串。</li><li>后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串。</li></ul></li><li>前缀表：<strong>记录下标i之前（包括i）的字符串中，子串(s[0]至s[i])有多大<code>长度</code>的相同长度的前缀、后缀</strong>。</li></ul><h3 id="计算前缀表"><a href="#计算前缀表" class="headerlink" title="计算前缀表"></a>计算前缀表</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// i是后缀末尾，j是前缀末尾</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getNext</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; next, <span class="hljs-type">const</span> string&amp; s)</span> </span>&#123;<br>    <span class="hljs-type">int</span> j   = <span class="hljs-number">0</span>;<br>    next[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// j指向前缀末尾位置，i指向后缀末尾位置</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; s[i] != s[j]) &#123;<br>            j = next[j - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (s[i] == s[j]) &#123;<br>            ++j;<br>        &#125;<br>        next[i] = j;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a>字符串匹配</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">strStr</span><span class="hljs-params">(string haystack, string needle)</span> </span>&#123;<br>    <span class="hljs-type">int</span> m = haystack.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> n = needle.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span> || n &gt; m) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">next</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-built_in">getNext</span>(next, needle);<br><br>    <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// j 是模式串的下标，i 是文本串的下标</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>        <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; haystack[i] != needle[j]) &#123;<br>            <span class="hljs-comment">// 遇到不匹配字符时，跳转到前一个字符的前缀表的记录位置</span><br>            j = next[j - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (haystack[i] == needle[j]) &#123;<br>            <span class="hljs-comment">// 字符匹配</span><br>            ++j;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (j == n) &#123;<br>            <span class="hljs-keyword">return</span> i - n + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-comment">// 可发现匹配过程与创建前缀表的过程相似</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string s1 = <span class="hljs-string">&quot;aabaabaafa&quot;</span>;<br>    string s2 = <span class="hljs-string">&quot;aabaaf&quot;</span>;<br>    cout &lt;&lt; <span class="hljs-built_in">strStr</span>(s1, s2) &lt;&lt; endl;<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h3><p><a href="https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC">代码随想录</a>、<a href="https://leetcode.cn/problems/implement-strstr/">LeetCode 28题</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高性能并发Web服务器</title>
    <link href="/2022/07/18/%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91Web%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2022/07/18/%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91Web%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="WebServer"><a href="#WebServer" class="headerlink" title="WebServer"></a>WebServer</h2><p>高性能并发服务器，由<code>webbench</code>测试可达到上万QPS；</p><p><strong>【关键词】</strong></p><p><strong>C++11、IO多路复用技术Epoll、Reactor高并发模型、线程池、异步日志系统、最小堆定时器、数据库连接池、有限状态机、自增长缓冲区、单例模式、自定义Json解析器</strong></p><hr><ul><li><a href="#webserver">WebServer</a></li><li><a href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B">工作流程</a><ul><li><a href="#%E6%B5%81%E7%A8%8B%E5%9B%BE">流程图</a></li></ul></li><li><a href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%A8%A1%E5%9D%97">线程池模块</a></li><li><a href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E6%A8%A1%E5%9D%97">缓冲区模块</a></li><li><a href="#epoll%E6%A8%A1%E5%9D%97">Epoll模块</a></li><li><a href="#http%E8%BF%9E%E6%8E%A5%E6%A8%A1%E5%9D%97">HTTP连接模块</a></li><li><a href="#http%E8%A7%A3%E6%9E%90%E6%A8%A1%E5%9D%97">HTTP解析模块</a></li><li><a href="#http%E5%93%8D%E5%BA%94%E6%A8%A1%E5%9D%97">HTTP响应模块</a></li><li><a href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E6%A8%A1%E5%9D%97">定时器模块</a></li><li><a href="#%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97">日志模块</a></li><li><a href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E6%A8%A1%E5%9D%97">阻塞队列模块</a></li><li><a href="#mysql%E8%BF%9E%E6%8E%A5%E6%B1%A0%E6%A8%A1%E5%9D%97">MySQL连接池模块</a></li><li><a href="#json%E8%A7%A3%E6%9E%90%E6%A8%A1%E5%9D%97">Json解析模块</a></li><li><a href="#webserver%E6%A8%A1%E5%9D%97">WebServer模块</a></li><li><a href="#%E5%8F%82%E8%80%83%E5%8F%8A%E8%87%B4%E8%B0%A2">参考及致谢</a></li></ul><hr><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><ol><li>本服务器项目采用的是<strong>同步I&#x2F;O</strong>(<code>epoll_wait</code>)实现<code>Reactor</code>事件处理模式；</li><li>主线程负责监听文件描述符上是否有事件发生、接受新连接，工作线程负责读写数据，处理客户请求；</li><li>工作流程是：主线程往 epoll 内核事件表中注册 <strong>监听socket</strong> 上的读就绪事件，而后调用 epoll_wait 等待 socket 上的事件发生，如下是可能事件类型：</li></ol><ul><li><p>若是新连接，主线程就往 epoll 内核事件表中注册该 socket 上的读就绪事件；</p></li><li><p>socket 上是错误事件时，主线程就关闭该连接；</p></li><li><p>socket 上是读事件时， 主线程则将<strong>读任务</strong>放入任务队列，睡眠在请求队列上的某个工作线程被唤醒，它从 socket 读取数据，并处理客户请求(解析HTTP报文，生成HTTP响应)，然后往 epoll 内核事件表中注册该 socket 上的写就绪事件；</p></li><li><p>socket上是写事件时，主线程将<strong>写任务</strong>放入任务队列，睡眠在请求队列上的某个工作线程被唤醒，它往 socket 上写入响应报文，若是长连接就再次注册该 socket 上的读就绪事件，否则关闭连接；</p></li></ul><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img src="/./post_img/flowchart.jpg"></p><hr><h2 id="线程池模块"><a href="#线程池模块" class="headerlink" title="线程池模块"></a>线程池模块</h2><ul><li>池是一组资源的集合，服务器事先初始化好一组线程，即创建好线程池，这称为静态资源；</li><li>当服务器运行的时候，需要处理时就从池中取出一个线程，用完后还回去，无需动态申请和销毁资源，是一种以空间换时间的概念；</li><li>在构造函数中创建一组线程，用<strong>lambda表达式</strong>这种可调用对象作为子线程的工作函数，并设置<strong>线程分离</strong>；</li><li>使用<strong>互斥量</strong>和<strong>条件变量</strong>保证线程同步，需要运行的任务装载在一个队列中，即<strong>任务队列</strong>；</li><li>任务就是<strong>函数模板对象</strong>，类中有一个加入任务的模板成员函数<code>addTask</code>，每加入一个任务，唤醒一个线程；</li><li>子线程的工作逻辑其实就是从任务队列中取出任务然后执行它，若队列为空就休眠等待直到被唤醒；</li><li>还可以拓展的是：添加一个容器来装载各子线程、限制任务队列中最大任务数量；</li></ul><h2 id="缓冲区模块"><a href="#缓冲区模块" class="headerlink" title="缓冲区模块"></a>缓冲区模块</h2><ul><li>利用<code>vector&lt;char&gt;</code>实现的动态增长的缓冲区，用来保存数据以及读写数据；</li><li>一个缓冲区对象主要包括3个部分：已读取段、未读取段、未写入段；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">  已读取段    未读取段  未写入段<br>缓冲区：++++++++++++++-------------xxxxxxxxxxxxx<br>     ^  ^   ^<br>       读指针  写指针   容器结尾处<br></code></pre></td></tr></table></figure><ul><li>自动扩容机制是比较即将写入缓存的数据大小是否小于<strong>已读段加上未写段</strong>的大小，如果满足则将<strong>未读段</strong>移动到最左边，否则重新申请更大的内存；</li><li>缓冲区从<code>sockfd</code>读取数据时采用<strong>分散读</strong><code>readv</code>的方式，一块是指向当前缓冲区，另一块是辅助字符串防止缓冲区装不下，如果装不下后序再扩容缓冲区，然后合并到缓冲区中；</li><li>缓冲区往<code>sockfd</code>发送数据时直接调用<code>write</code>写入当前缓冲区中<strong>未读取段</strong>的数据；</li><li>缓冲区对应操作有：读取数据、返回读写位置、返回各个段信息、写入数据；</li></ul><h2 id="Epoll模块"><a href="#Epoll模块" class="headerlink" title="Epoll模块"></a>Epoll模块</h2><ul><li>用于初始化<code>epoll</code>实例，便于管理；</li><li>功能是在epoll实例中增、删、改socket文件描述符及其监听事件类型；</li></ul><h2 id="HTTP连接模块"><a href="#HTTP连接模块" class="headerlink" title="HTTP连接模块"></a>HTTP连接模块</h2><ul><li>每个HTTP连接对象表示一个客户端连接的各种<strong>属性</strong>，及其操作方法(<strong>读、处理、写</strong>)；</li><li>静态成员变量有：连接用户数、资源目录、epoll触发模式；</li><li>其它成员变量是：连接地址信息、socket文件描述符、连接是否关闭、读写缓冲区(自定义的buffer对象)、HTTP解析类对象、HTTP响应类对象；</li><li>主要操作方法有：初始化每个客户端连接、接收请求信息、发送响应信息、关闭连接；</li><li>简而言之，HTTP连接类对象就是用来接收请求然后回送响应，请求的解析和响应的生成是交给解析类对象和响应类对象去执行的；</li><li>读取请求数据是直接read客户端连接的socket文件描述符，读到<strong>读缓冲区</strong>里面；</li><li>请求的解析是调用解析类对象的成员函数，解析结果交给响应类对象去制作响应报文；</li><li>发送响应数据是采用<strong>聚集写</strong><code>writev</code>的方式，在一次函数调用中写多个非连续缓冲区，并且再循环里面调整区块一与区块二的基址和长度，区块一对应<strong>写缓冲区</strong>，区块二对应客户端请求的<strong>资源文件</strong>，区块的基址及长度由响应类对象的返回结果配置；</li></ul><h2 id="HTTP解析模块"><a href="#HTTP解析模块" class="headerlink" title="HTTP解析模块"></a>HTTP解析模块</h2><ul><li>HTTP解析类对象用来解析<strong>读缓冲区</strong>中的HTTP请求报文，支持解析GET和POST请求；</li><li>采用了<strong>正则表达式</strong>和<strong>有限状态机</strong>来解析；</li><li>有限状态机是逻辑单元内部的一种高效编程方法，报文的每种数据类型字段可以映射为逻辑单元的一种执行状态，可以根据它来编写相应的解析逻辑，并转移到相应状态继续解析；</li><li>一个类对象包含：当前解析状态(枚举变量)、协议版本、HTTP请求方法(GET或POST)、请求资源路径、请求头、请求体、是否长连接等等；</li><li>请求体和请求体的信息采用<strong>有序容器</strong><code>&lt;key:string, value:string&gt;</code>记录；</li><li>一个客户端连接可能有多次请求(<strong>长连接</strong>)，所以需要保存上次解析状态，用以指示是否为新的HTTP请求，当上一次的请求为完成状态时，会再次初始化解析类对象，以重新开始解析一个HTTP请求；</li><li>如果是GET请求，就不会解析<strong>请求体</strong>，如果是POST请求，还要从请求体中解析出账户与密码，然后MySQL连接池取出一个连接，调用API执行SQL语句，分别处理登录和注册的情况；</li><li>解析类对象中成员函数由HTTP连接类对象调用，读缓冲区作为主体解析函数的引用形式的形参传入；</li></ul><h2 id="HTTP响应模块"><a href="#HTTP响应模块" class="headerlink" title="HTTP响应模块"></a>HTTP响应模块</h2><ul><li>HTTP响应类对象负责根据解析结果，拼接响应报文到<strong>写缓冲区</strong>中；</li><li>使用了<strong>哈希表</strong>方便组装需要返回的状态码、头部字段信息；</li><li>成员变量有：请求资源文件(发送文件)的路径、是否长连接、状态码、内存映射区、文件信息；</li><li>操作方法有：往写缓冲区添加状态行、报文头部、报文正文(资源文件)；</li><li>资源文件通过<strong>内存映射</strong>方法映射到内存中，提高速度，当然会检查文件是否存在以及权限；</li><li>响应类对象中成员函数也由HTTP连接类对象调用，写缓冲区作为响应制作函数的引用形式的形参传入，如果有请求资源文件，还会返回文件映射在内存中的地址给连接类对象；</li></ul><h2 id="定时器模块"><a href="#定时器模块" class="headerlink" title="定时器模块"></a>定时器模块</h2><ul><li>每个连接对应一个<code>TimeNodo</code>节点，里面封装了超时时间、回调函数等信息；</li><li>采用最小堆数据结构管理所有连接的超时信息，即维护一个<strong>最小堆定时器</strong>；</li><li>最小堆是采用<code>vertor&lt;TimeNode&gt;</code>数组实现的，堆顶元素就是最先超时的连接；</li><li>数组下标从0开始，0下标即对应堆顶节点，对于堆中某一节点，令它在数组中下标为<code>k</code>，则左子节点为<code>2*k + 1</code>，右子节点为<code>2*k + 2</code>，父节点为<code>(k - 1) / 2</code>；</li><li>插入节点时，插入到数组中的最后一个节点的后面，然后与该节点的父节点比较大小，如果插入的元素小于父节点元素，那么与父节点交换位置。重复上述步骤直到大于父节点元素或者到达堆顶。该过程叫做<strong>上浮</strong>，即插入时上浮；</li><li>移除节点时，将该节点与末尾节点交换，然后当前节点(之前的尾部节点)与子节点中的较小者比较，如果当前节点大于较小子节点，那么与较小子节点交换位置，重复上述步骤直到小于较小子节点或者到达倒数第二个节点为止。最后再删除末尾节点。该过程叫做<strong>下沉</strong>，即移除元素时下沉;</li><li>最小堆定时器的操作有：添加节点、删除所有超时节点(断开超时连接)、调整节点的过期时间；</li></ul><h2 id="日志模块"><a href="#日志模块" class="headerlink" title="日志模块"></a>日志模块</h2><ul><li>日志模块用于同步或异步记录服务器运行信息，具有按天分类，超行分类功能；</li><li><strong>同步日志</strong>是日志写入函数与工作线程串行执行，由于涉及到I&#x2F;O操作，当单条日志比较大的时候，同步模式会阻塞整个处理流程，服务器的并发能力将有所下降；</li><li><strong>异步日志</strong>是将所写的日志内容先存入阻塞队列，写线程从阻塞队列中取出内容，写入日志；</li><li>异步日志用到了<strong>阻塞队列</strong>，还有<strong>单例模式</strong>，保证日志类对象只有一个实例对象，采用<strong>局部静态变量懒汉模式</strong>的方法实现；</li><li>日志有4个级别可选，分别是DEBUG、INFO、WARN、ERROR，分别对应级别0~3，比如设置级别为0时每个级别的信息都记录，设置为3时只记录错误信息；</li><li>成员变量有：是否开启日志记录、是否开启异步、日志文件路径、行数、时间、阻塞队列的智能指针、异步写入线程、自定义缓冲区，是否启用异步写入由阻塞队列的大小判断，如果阻塞队列大小不为0就是异步写入；</li><li>写入函数中将日志数据格式化并添加到我们<strong>自定义的缓冲区</strong>对象，若是同步写入就直接将缓存区中数据写入到磁盘日志文件，若是异步写入则调用生产者将其加入到阻塞队列，由写线程调用消费者负责写入到磁盘文件；</li><li>日志的格式用到了可变参数列表，<code>fputs</code>是将字符串写入流，FILE对象标识了要被写入字符串的流，<code>fflush</code>是强制将<strong>系统缓冲区</strong>数据刷新进参数指定的流中，防止数据丢失;</li><li>统一使用宏定义<code>LOG_BASE</code>写日志，宏中由单例模式的<code>instance</code>取得日志类对象实例的引用，再由其调用写入函数；</li><li>日志文件保存在工作目录的log文件夹，文件夹和日志文件如果不存在会自动创建；</li></ul><h2 id="阻塞队列模块"><a href="#阻塞队列模块" class="headerlink" title="阻塞队列模块"></a>阻塞队列模块</h2><ul><li>封装生产者-消费者模式，配合日志模块异步运行时使用；</li><li>对于<strong>生产者-消费者</strong>模型，以多线程为例，生产者线程与消费者线程共享一个缓冲区，其中生产者线程往缓冲区中push内容，消费者线程从缓冲区中pop内容；</li><li>为了实现线程间数据同步，将生产者-消费者模型进行封装，其中<strong>共享缓冲区</strong>采用队列<code>queue&lt;string&gt;</code>实现，称为<strong>阻塞队列</strong>，有最大缓存容量限制；</li><li>使用<strong>互斥量</strong>、<strong>条件变量</strong>(生产者条件变量、消费者条件变量)保证线程安全，工作线程将要写的内容push进队列，写线程从队列中pop出内容，</li><li>类的成员函数中，pop和push函数由Log类中调用，flush函数用于唤醒一个消费者；</li></ul><h2 id="MySQL连接池模块"><a href="#MySQL连接池模块" class="headerlink" title="MySQL连接池模块"></a>MySQL连接池模块</h2><ul><li>类似线程池，在程序初始化时创建多个数据库连接，并把他们集中管理，保证较快的数据库读写速度；</li><li>具体就是工作线程从数据库连接池取得一个连接，访问数据库中的数据，访问完毕后将连接交还连接池；</li><li>本项目中使用局部静态变量懒汉方法<strong>单例模式</strong>和<strong>队列</strong>创建数据库连接池，实现对数据库连接资源的复用；</li><li>项目中的数据库模块分为两部分，其一是数据库连接池的定义，其二是利用连接池完成登录和注册的校验功能，<strong>校验逻辑</strong>其实是在<strong>HTTP解析类</strong>中进行的；</li><li>数据库连接池的功能主要有：初始化、获取连接、释放连接、销毁连接池；</li><li>运用RAII机制封装了一个<code>connRAII</code>类，用于从MySQL连接池取出连接，连接就通过析构函数中自动回池；</li><li>因为连接总数一定且有限，所以使用<strong>互斥量</strong>和<strong>信号量</strong>来同步线程，将信号量初始化为数据库的连接总数；</li><li>每次取出连接使信号量原子减1，释放连接使信号量原子加1，若连接池内没有连接了，则阻塞等待；</li></ul><h2 id="Json解析模块"><a href="#Json解析模块" class="headerlink" title="Json解析模块"></a>Json解析模块</h2><ul><li>自定义简易Json解析模块，读取本地配置文件来初始化服务器；</li><li>详见<a href="https://github.com/zyue2022/lightJson">lightJson</a>;</li></ul><h2 id="WebServer模块"><a href="#WebServer模块" class="headerlink" title="WebServer模块"></a>WebServer模块</h2><ul><li>该模块就是服务器程序的核心模块，联系起各个子功能模块，主线程就是运行它；</li><li>WebServer类中成员变量有：定时器类对象、线程池类对象、Epoller类对象、HTTP连接类对象、本地的监听文件描述符及端口、资源路径；</li><li>操作方法有设置文件描述符非阻塞、设置事件触发模式、初始化本地监听文件描述符(创建、绑定、监听)、设置优雅关闭及端口复用、添加客户端连接到epoll实例、关闭客户端连接、处理连接的读写、设置及调整连接的超时时间等等；</li><li>构造函数中根据传入参数初始化Webserver对象实例，包括初始化监听文件描述符、epoll实例、数据库连接池、线程池、日志系统实例、最小堆定时器、设置好文件描述符的事件触发模式及事件类型；</li><li>事件类型<code>EPOLLONESHOT</code>是为了保证当前连接在同一时刻只被一个线程处理，注册了 EPOLLONESHOT 事件的 socket 一旦被某个线程处理完毕， 还需要重置这个socket 上的 EPOLLONESHOT 事件；</li><li>HTTP连接类对象是装载在哈希表中的，这样可以在有新连接到来时再实例化一个连接对象；</li><li>整体工作逻辑是在循环中监听所有socket上的事件，对不同事件类型做不同处理，同时关闭超时连接；</li></ul><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">举例：客户端请求网页，webserver类工作流程如下<br><span class="hljs-number">1.</span> 检测到读就绪时，调用<span class="hljs-keyword">http</span>连接类的读方法，将请求报文读到读缓冲区；<br><span class="hljs-number">2.</span> 调用<span class="hljs-keyword">http</span>连接类中的处理方法，其中：<br>- <span class="hljs-keyword">http</span>连接类调用自己成员中的<span class="hljs-keyword">http</span>解析类，解析读缓冲区中请求报文；<br>- <span class="hljs-keyword">http</span>连接类调用自己成员中的<span class="hljs-keyword">http</span>响应类，制作响应报文到写缓冲区中，并进行请求资源文件的内存映射；<br>- <span class="hljs-keyword">http</span>连接类向对应文件描述符注册写就绪事件；<br><span class="hljs-number">3.</span> 检测到写就绪，调用<span class="hljs-keyword">http</span>连接类的写方法，将响应报文和内存中映射的资源文件发给客户端；<br></code></pre></td></tr></table></figure><hr><h2 id="参考及致谢"><a href="#参考及致谢" class="headerlink" title="参考及致谢"></a>参考及致谢</h2><ul><li><strong>《Linux高性能服务器编程》游双</strong></li><li><a href="https://www.nowcoder.com/study/live/504">牛客网C++课程 - 项目实战</a></li><li><a href="https://github.com/markparticle/WebServer">@markparticle</a>、<a href="https://github.com/InnovatorZhang/my-WebServer">@InnovatorZhang</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>并发服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++11多线程编程笔记</title>
    <link href="/2022/07/12/C++11%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/07/12/C++11%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="线程创建、启动、结束"><a href="#线程创建、启动、结束" class="headerlink" title="线程创建、启动、结束"></a>线程创建、启动、结束</h2><ul><li>线程类的参数是一个可调用对象，如函数(可以是类中的成员函数)、函数指针、仿函数、lambda表达式、bind创建的对象；</li><li><code>jion()</code> 是阻塞主线程并等待子线程执行完，当子线程执行完毕，join()就执行完毕，主线程继续往下执行，join意为汇合，子线程和主线程回合；</li><li><code>detach()</code> 是线程分离，主线程不再与子线程汇合，不再等待子线程，detach后，子线程和主线程失去关联，驻留在后台，由C++运行时库接管；</li><li><code>joinable()</code>判断是否可以成功使用join()或者detach()，返回true就可以调用，如果返回false，证明调用过join()或者detach()；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">childFunc</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//子线程代码逻辑</span><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//创建子线程，线程执行起点是childFunc，然后执行线程</span><br>    <span class="hljs-function">thread <span class="hljs-title">childThread</span><span class="hljs-params">(childFunc)</span></span>;<br><br>    <span class="hljs-comment">//阻塞主线程并等待子线程执行完毕</span><br>    childThread.<span class="hljs-built_in">join</span>();<br><br>    <span class="hljs-comment">//线程分离，由C++运行时库回收子线程</span><br>    <span class="hljs-comment">//childThread.detach();</span><br><br>    <span class="hljs-keyword">if</span> (childThread.<span class="hljs-built_in">joinable</span>()) &#123;<br>        <span class="hljs-comment">//可以调用可以调用join()或者detach()</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//不能调用可以调用join()或者detach()</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>TODO: 补充如何给子线程传参：类中的成员函数、函数指针、仿函数、lambda表达式、bind创建的对象</p></blockquote><h2 id="mutex互斥量"><a href="#mutex互斥量" class="headerlink" title="mutex互斥量"></a>mutex互斥量</h2><ul><li>互斥量是个类对象，我也称为互斥锁；</li><li>多个线程尝试用lock()成员函数来加锁，只有一个线程能锁定成功；</li><li>如果没有锁成功，那么流程将卡在lock()这里不断尝试去加锁；</li><li>成员函数lock()和unlock()要成对使用；</li><li>使用互斥量少了达不到效果，多了影响效率；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 定义</span><br>mutex mux;<br><br><span class="hljs-comment">// 一般使用步骤</span><br><span class="hljs-number">1.</span>加锁mux.<span class="hljs-built_in">lock</span>();<br><span class="hljs-number">2.</span>操作共享数据<br><span class="hljs-number">3.</span>解锁mux.<span class="hljs-built_in">unlock</span>();<br></code></pre></td></tr></table></figure><h2 id="std-lock-函数模板"><a href="#std-lock-函数模板" class="headerlink" title="std::lock()函数模板"></a>std::lock()函数模板</h2><ul><li><code>std::lock(mutex1,mutex2...); </code>一次锁定多个互斥量（一般这种情况很少），用于处理多个互斥量；</li><li>如果互斥量中某一个没锁住，它就等待所有互斥量都锁住，才能继续执行；</li><li>如果有一个没锁住，就会把已经锁住的释放掉；</li><li>要么互斥量都锁住，要么都没锁住，防止死锁；</li></ul><h2 id="lock-guard类模板"><a href="#lock-guard类模板" class="headerlink" title="lock_guard类模板"></a>lock_guard类模板</h2><ul><li>可以取代使用<code>mux</code>互斥量的lock()和unlock()成员函数；</li><li>lock_guard构造函数执行了mutex::lock()，在作用域结束时，调用析构函数，执行mutex::unlock()；</li><li>所有使用时注意<strong>作用域</strong>范围；</li><li>若使用第二个参数<code>std::adopt_lock</code>，则表示这个互斥量已经lock()，构造时不需要再lock()；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">lock_guard&lt;mutex&gt; <span class="hljs-title">guard</span><span class="hljs-params">(mux)</span></span>;<br><span class="hljs-comment">// 或</span><br><span class="hljs-function">lock_guard&lt;mutex&gt; <span class="hljs-title">guard</span><span class="hljs-params">(mux,adopt_lock)</span></span>;<br></code></pre></td></tr></table></figure><h2 id="unique-lock类模板"><a href="#unique-lock类模板" class="headerlink" title="unique_lock类模板"></a>unique_lock类模板</h2><ul><li>类似lock_guard，但有更多用法；</li><li><strong>无需自己unlock()</strong>;</li><li>其第二个参数有：<br>   1. <code>adopt_lock</code>; 同lock_guard中的，前提是已经lock()；<br>   2. <code>try_to_lock</code>; 尝试用去锁定，如果没有锁定成功，会立即返回，不会阻塞在那里，前提是没有lock()；<br>   3. <code>defer_lock</code>; 初始化一个没有加锁的互斥量mutex，以便后序调用其它方法，前提是没有lock()；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">unique_lock&lt;mutex&gt; <span class="hljs-title">uniLock</span><span class="hljs-params">(mux)</span></span>; <span class="hljs-comment">// 相当于把mux和uniLock绑定在了一起，uniLock拥有mux的所有权</span><br><span class="hljs-comment">// 或</span><br><span class="hljs-function">unique_lock&lt;mutex&gt; <span class="hljs-title">uniLock</span><span class="hljs-params">(myMutex, defer_lock)</span></span>;<br><br>uniLock.<span class="hljs-built_in">lock</span>();   <span class="hljs-comment">// 加锁</span><br>uniLock.<span class="hljs-built_in">unlock</span>(); <span class="hljs-comment">// 解锁</span><br><br><span class="hljs-comment">// 尝试给互斥量加锁，如果拿不到锁，返回false，否则返回true</span><br>uniLock.<span class="hljs-built_in">try_lock</span>(); <br><br><span class="hljs-comment">// 解除绑定，返回它所管理的mutex对象的指针，并释放所有权，所有权由ptx接管</span><br>mutex* ptx = uniLock.<span class="hljs-built_in">release</span>();<br><br><span class="hljs-comment">// uniLock可以把自己对mux的所有权转移，但是不能复制</span><br><span class="hljs-function">unique_lock&lt;mutex&gt; <span class="hljs-title">uniLock2</span><span class="hljs-params">(std::move(uniLock))</span></span>;<br></code></pre></td></tr></table></figure><h2 id="单例类与共享数据"><a href="#单例类与共享数据" class="headerlink" title="单例类与共享数据"></a>单例类与共享数据</h2><p><strong>单例设计模式：</strong> </p><p>定义：单例模式保证一个类仅有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享。</p><p>实现思路：私有化它的构造函数，以防止外界创建单例类的对象；使用类的私有静态指针变量指向类的唯一实例，并用一个公有的静态方法获取该实例。</p><h3 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h3><p>用到的时候再创建，需要锁；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>mutex myMutex;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//双重判断 提高效率</span><br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-function">lock_guard&lt;mutex&gt; <span class="hljs-title">myLockGua</span><span class="hljs-params">(myMutex)</span></span>;<br>            <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">NULL</span>) &#123;<br>                instance = <span class="hljs-keyword">new</span> Singleton;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>    <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Singleton</span>() &#123;&#125;<br>    <span class="hljs-type">static</span> Singleton* instance;<br>&#125;;<br>Singleton* Singleton::instance = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><h3 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h3><p>一开始就创建，所以不需要锁；</p><blockquote><p>饿汉模式的问题在于非静态对象（函数外的static对象）在不同编译单元中的初始化顺序是未定义的。如果在初始化完成之前调用 getInstance() 方法会返回一个未定义的实例。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>mutex myMutex;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton2</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton2* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> instance; &#125;<br>    <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Singleton2</span>() &#123;&#125;<br>    <span class="hljs-type">static</span> Singleton2* instance;<br>&#125;;<br>Singleton2* Singleton2::instance = <span class="hljs-keyword">new</span> Singleton2;<br></code></pre></td></tr></table></figure><h3 id="使用call-once函数模板"><a href="#使用call-once函数模板" class="headerlink" title="使用call_once函数模板"></a>使用<strong>call_once</strong>函数模板</h3><p>参数：第一个参数为标记，第二个参数是一个函数名；<br>功能：能够保证函数只被调用一次，具备互斥量的能力，而且比互斥量消耗的资源更少，更高效。</p><blockquote><p>标记为std::once_flag，call_once()就是通过标记来决定函数是否执行，调用成功后，就把标记设置为一种已调用状态；</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>once_flag g_flag;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//call_once保证其只被调用一次</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">CreateInstance</span><span class="hljs-params">()</span> </span>&#123; instance = <span class="hljs-keyword">new</span> Singleton; &#125;<br><br>    <span class="hljs-comment">//两个线程同时执行到这里，其中一个线程要等另外一个线程执行完毕</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton *<span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-built_in">call_once</span>(g_flag, CreateInstance);<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Singleton</span>() &#123;&#125;<br>    <span class="hljs-type">static</span> Singleton *instance;<br>&#125;;<br>Singleton *Singleton::instance = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><h3 id="借助局部静态对象实现"><a href="#借助局部静态对象实现" class="headerlink" title="借助局部静态对象实现"></a>借助局部静态对象实现</h3><blockquote><p>《Effective C++》（Item 04）中提出一种更优雅的单例模式实现，使用函数内的局部静态对象，这种方法在C++11及之后不用加锁和解锁操作。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">single</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">single</span>() &#123;&#125;<br>    ~<span class="hljs-built_in">single</span>() &#123;&#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> single* <span class="hljs-title">getinstance</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-function">single* <span class="hljs-title">single::getinstance</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">static</span> single obj;<br>    <span class="hljs-keyword">return</span> &amp;obj;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><ul><li><code>std::condition_variable</code>实际上是一个和条件相关的类，就是等待一个条件达成；</li><li>条件变量的作用是阻塞线程，然后等待通知将其唤醒；</li><li>可以通过判断某个函数是否符合某种条件来决定是阻塞线程等待通知还是唤醒线程，由此实现线程间的同步；</li><li>condition_variable的等待函数有三个，分别是wait()——等待、wait_for()——等待一段时间、wait_until()——等待至某一时刻；</li><li>另外针对每个函数condition_variable还提供了有条件等待和无条件等待两种方式；</li><li>如果阻塞，则阻塞到其他某个线程调用<code>notify_one()</code>或<code>notify_all</code>成员函数为止，就被唤醒；</li><li>只要执行到wait后面就一定加锁成功；</li></ul><h3 id="无条件等待"><a href="#无条件等待" class="headerlink" title="无条件等待"></a>无条件等待</h3><ol><li><code>void wait(unique_lock&amp; lck)</code>会无条件的阻塞当前线程然后等待通知，前提是此时对象lck已经成功获取了锁；</li><li>等待(休眠)时会调用lck.unlock()释放锁，使其它线程可以获取锁。一旦得到通知(由其他线程显式地通知)，函数就会释放阻塞并调用lck.lock()，使lck保持与调用函数时相同的状态，然后函数返回；</li><li>wati()函数因为没有条件判断，因此有时候会产生<strong>虚假唤醒</strong>，而有条件的等待可以很好的解决这一问题；</li><li>效果跟有条件等待的第二个参数返回false一样；</li><li>无条件等待被唤醒后wait()不断尝试获取互斥量锁，如果获取不到那么流程就卡在wait()这里等待加锁，当获取到了，wait()就继续执行；</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>std::mutex                   mux;<br><span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">uniLock</span><span class="hljs-params">(mux)</span></span>;<br>std::condition_variable      condition;<br><br>condition.<span class="hljs-built_in">wait</span>(uniLock);<br></code></pre></td></tr></table></figure><h3 id="有条件等待"><a href="#有条件等待" class="headerlink" title="有条件等待"></a>有条件等待</h3><ol><li><code>void wait (unique_lock&amp; lck, Predicate pred)</code>为有条件的等待；</li><li>pred是一个可调用的对象或函数，它不接受任何参数，并返回一个可以作为bool的值；</li><li>当pred为false时wait()函数才会使线程等待(休眠)，在收到其他线程通知时只有当pred返回true时才会被唤醒；</li><li>有条件等待被唤醒后，就判断第二个参数(例如lambda表达式)的值：<ul><li>如果为false，那wait又对互斥量解锁，然后又休眠，等待再次被notify唤醒；</li><li>如果为true，则wait返回，流程可以继续执行（<strong>此时互斥量已被锁住</strong>）；</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br>std::mutex                   mux;<br><span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">uniLock</span><span class="hljs-params">(mux)</span></span>;<br>std::condition_variable      condition;<br><br>condition.<span class="hljs-built_in">wait</span>(uniLock, [<span class="hljs-keyword">this</span>] &#123;<br>    <span class="hljs-comment">// 等待消息队列不为空</span><br>    <span class="hljs-keyword">if</span> (!msgRecvQueue.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;);<br><span class="hljs-comment">// 如果第二个参数的lambda表达式返回值是false，那么wait()将解锁互斥量，并阻塞;</span><br><span class="hljs-comment">// 如果第二个参数的lambda表达式返回值是true，那么wait()直接返回并继续执行;</span><br></code></pre></td></tr></table></figure><h2 id="future类模板"><a href="#future类模板" class="headerlink" title="future类模板"></a>future类模板</h2><ul><li><code>std::future</code>的<code>get()</code>成员函数是<strong>转移</strong>数据，不能多次get；</li><li><code>std::future_status</code> status &#x3D; result.<strong>wait_for</strong>(std::chrono::seconds(几秒)) 可以卡住当前流程，等待std::async()的异步任务运行一段时间，然后返回其状态std::future_status，如果std::async()的参数是std::launch::deferred（延迟执行），则不会卡住主流程；</li><li>std::future_status是枚举类型，表示异步任务的执行状态，取值有std::future_status::timeout、std::future_status::ready、std::future_status::deferred；</li></ul><h3 id="async函数模板"><a href="#async函数模板" class="headerlink" title="async函数模板"></a>async函数模板</h3><ul><li><code>std::async</code>是一个函数模板，用来启动一个异步任务（启动一个异步任务，就是自动创建一个线程，并开始执行对应的线程入口函数）；</li><li>启动一个异步任务之后，async返回一个<code>std::future</code>对象，这个对象是个类模板，这个std::future对象中就含有线程入口函数所返回的结果，可以调用future对象的成员函数get()来获取结果；</li><li>std::future提供了一种访问异步操作结果的机制，可以理解为理解future中保存着一个值，这个值是在将来的某个时刻能够拿到；</li><li>std::future对象的<code>get()</code>成员函数会等待线程执行结束并返回结果，拿不到结果它就会一直等待；</li><li>std::future对象的<code>wait()</code>成员函数，用于等待线程返回，本身并不返回结果，这个效果和 std::thread 的join()更像；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mythread</span><span class="hljs-params">(<span class="hljs-type">int</span> mypar)</span> </span>&#123;<br>        cout &lt;&lt; mypar &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> mypar;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mythread</span><span class="hljs-params">(<span class="hljs-type">int</span> mypar)</span> </span>&#123;<br>cout &lt;&lt; mypar &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;mythread() start&quot;</span> &lt;&lt; <span class="hljs-string">&quot;threadid = &quot;</span> &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() &lt;&lt; endl;<br>std::<span class="hljs-function">chrono::milliseconds <span class="hljs-title">dura</span><span class="hljs-params">(<span class="hljs-number">5000</span>)</span></span>;<br>std::this_thread::<span class="hljs-built_in">sleep_for</span>(dura);<br>cout &lt;&lt; <span class="hljs-string">&quot;mythread() end&quot;</span> &lt;&lt; <span class="hljs-string">&quot;threadid = &quot;</span> &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    A a;<br>    <span class="hljs-type">int</span> tmp = <span class="hljs-number">12</span>;<br><br>    <span class="hljs-comment">//普通函数作为异步任务参数</span><br>    std::future&lt;<span class="hljs-type">int</span>&gt; result1 = std::<span class="hljs-built_in">async</span>(mythread);<br>    cout &lt;&lt; result1.<span class="hljs-built_in">get</span>() &lt;&lt; endl;  <span class="hljs-comment">//卡在这里等待mythread()执行完毕，拿到结果</span><br><br>    <span class="hljs-comment">//类成员函数作为异步任务参数</span><br>    <span class="hljs-comment">//第二个参数是对象引用才能保证线程里执行的是同一个对象</span><br>    std::future&lt;<span class="hljs-type">int</span>&gt; result2 = std::<span class="hljs-built_in">async</span>(&amp;A::mythread, &amp;a, tmp);<br>    cout &lt;&lt; result2.<span class="hljs-built_in">get</span>() &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>参数<code>std::lunch::deferred</code>表示线程入口函数的调用会被延迟，一直到std::future的wait()或者get()函数被调用时（由主线程调用）才会执行，如果wait()或者get()没有被调用，则根本就不会创建新线程执行；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::future&lt;<span class="hljs-type">int</span>&gt; result1 = std::<span class="hljs-built_in">async</span>(std::launch::deferred ,mythread);<br></code></pre></td></tr></table></figure><ul><li>参数<code>std::launch::async</code>，在调用async函数的时候就开始创建新线程;</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::future&lt;<span class="hljs-type">int</span>&gt; result1 = std::<span class="hljs-built_in">async</span>(std::launch::async ,mythread);<br></code></pre></td></tr></table></figure><h3 id="packaged-task类模板"><a href="#packaged-task类模板" class="headerlink" title="packaged_task类模板"></a>packaged_task类模板</h3><ul><li><code>std::packaged_task</code>的模板参数是各种<strong>可调用对象</strong>，通过packaged_task把各种可调用对象包装起来，方便将来作为线程入口函数来调用；</li><li>packaged_task包装起来的可调用对象还可以直接调用，从这个角度来讲，packaged_task对象也是一个可调用对象；</li><li>通过调用<code>get_future()</code>成员函数得到future对象；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mythread</span><span class="hljs-params">(<span class="hljs-type">int</span> mypar)</span> </span>&#123;<br><span class="hljs-comment">// ......</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;main&quot;</span> &lt;&lt; <span class="hljs-string">&quot;threadid = &quot;</span> &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() &lt;&lt; endl;<br><span class="hljs-comment">// 我们把函数mythread通过packaged_task包装起来</span><br>    <span class="hljs-comment">// 参数是一个int，返回值类型是int</span><br>    <span class="hljs-function">std::packaged_task&lt;<span class="hljs-title">int</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>&gt; <span class="hljs-title">mypt</span><span class="hljs-params">(mythread)</span></span>;<br>    <span class="hljs-comment">// t1是线程</span><br><span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(std::ref(mypt), <span class="hljs-number">1</span>)</span></span>;<br>t1.<span class="hljs-built_in">join</span>();<br>    <span class="hljs-comment">// 用std::future对象接收线程入口函数的返回结果</span><br>std::future&lt;<span class="hljs-type">int</span>&gt; result = mypt.<span class="hljs-built_in">get_future</span>(); <br>cout &lt;&lt; result.<span class="hljs-built_in">get</span>() &lt;&lt; endl;<br>   <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 可调用对象可由函数换成lambda表达式</span><br><span class="hljs-function">std::packaged_task&lt;<span class="hljs-title">int</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>&gt; <span class="hljs-title">mypt</span><span class="hljs-params">([](<span class="hljs-type">int</span> mypar) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">    cout &lt;&lt; mypar &lt;&lt; endl;</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-comment">// ......</span></span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;)</span></span>; <br></code></pre></td></tr></table></figure><h3 id="promise类模板"><a href="#promise类模板" class="headerlink" title="promise类模板"></a>promise类模板</h3><ul><li>我们能够在某个线程中给它赋值，然后我们可以在其他线程中，把这个值取出来；</li><li>即通过<code>std::promise</code>保存一个值，在将来某个时刻把一个future绑定到这个promise上，来得到绑定的值;</li><li>通过调用<code>get_future()</code>成员函数得到future对象；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mythread</span><span class="hljs-params">(std::promise&lt;<span class="hljs-type">int</span>&gt; &amp;tmp, <span class="hljs-type">int</span> clac)</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;mythread() start&quot;</span> &lt;&lt; <span class="hljs-string">&quot;threadid = &quot;</span> &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() &lt;&lt; endl;<br>std::<span class="hljs-function">chrono::milliseconds <span class="hljs-title">dura</span><span class="hljs-params">(<span class="hljs-number">5000</span>)</span></span>;<br>std::this_thread::<span class="hljs-built_in">sleep_for</span>(dura);<br>cout &lt;&lt; <span class="hljs-string">&quot;mythread() end&quot;</span> &lt;&lt; <span class="hljs-string">&quot;threadid = &quot;</span> &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() &lt;&lt; endl;<br><span class="hljs-type">int</span> result = clac;<br>tmp.<span class="hljs-built_in">set_value</span>(result); <span class="hljs-comment">//结果保存到了tmp这个对象中</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br> <br>vector&lt;std::packaged_task&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>)&gt;&gt; task_vec;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>std::promise&lt;<span class="hljs-type">int</span>&gt; myprom;<br><span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(mythread, std::ref(myprom), <span class="hljs-number">180</span>)</span></span>;<br>t1.<span class="hljs-built_in">join</span>(); <span class="hljs-comment">//在这里线程已经执行完了</span><br>std::future&lt;<span class="hljs-type">int</span>&gt; fu1 = myprom.<span class="hljs-built_in">get_future</span>(); <span class="hljs-comment">//promise和future绑定，用于获取线程返回值</span><br><span class="hljs-keyword">auto</span> result = fu1.<span class="hljs-built_in">get</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;result = &quot;</span> &lt;&lt; result &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>使用thread时，必须 join() 或者 detach() 否则程序会报异常</p></blockquote><h2 id="shared-future类模板"><a href="#shared-future类模板" class="headerlink" title="shared_future类模板"></a>shared_future类模板</h2><p>std::shared_future 的 get() 成员函数是<strong>复制</strong>数据；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::future&lt;<span class="hljs-type">int</span>&gt; result = mypt.<span class="hljs-built_in">get_future</span>();<br><br> <span class="hljs-comment">//判断future中的值是不是一个有效值</span><br><span class="hljs-type">bool</span> ifcanget = result.<span class="hljs-built_in">valid</span>();<br><br><span class="hljs-comment">//执行完毕后result_s里有值，而result里空了</span><br><span class="hljs-function">std::shared_future&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result_s</span><span class="hljs-params">(result.share())</span></span>; <br><br><span class="hljs-comment">//或通过get_future返回值直接构造一个shared_future对象</span><br><span class="hljs-function">std::shared_future&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result_s</span><span class="hljs-params">(mypt.get_future())</span></span>;<br><br><span class="hljs-comment">// 可以多次get，因为是赋值</span><br><span class="hljs-keyword">auto</span> myresult1 = result_s.<span class="hljs-built_in">get</span>();<br><span class="hljs-keyword">auto</span> myresult2 = result_s.<span class="hljs-built_in">get</span>();<br></code></pre></td></tr></table></figure><h2 id="atomic类模板"><a href="#atomic类模板" class="headerlink" title="atomic类模板"></a>atomic类模板</h2><ul><li>在多线程中，如果想要执行<strong>不会被打断的程序执行片段</strong>，一般需要使用互斥量；</li><li>可以把<code>std::atomic</code><strong>原子操作</strong>理解成一种：不需要用到互斥量加锁的多线程并发编程方式；</li><li>从效率上来说，原子操作要比互斥量的方式效率要高；</li><li>互斥量的加锁一般是针对一个代码段，而原子操作针对的一般都是<strong>一个变量</strong>；</li><li>std::atomic是用来封装某个类型的值，原子操作一般用于计数或者统计；</li><li>原子操作实质上是不允许在进行原子对象操作时进行CPU的上下文切换；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atomic&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>std::atomic&lt;<span class="hljs-type">int</span>&gt; g_count = <span class="hljs-number">0</span>;  <span class="hljs-comment">//封装了一个类型为int的 对象（值）</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mythread1</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000</span>; i++) &#123;<br>        g_count++;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(mythread1)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(mythread1)</span></span>;<br>    t1.<span class="hljs-built_in">join</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br>    cout &lt;&lt; g_count &lt;&lt; endl;  <span class="hljs-comment">//得到2000000</span><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>C++11</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++11多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LRU算法</title>
    <link href="/2022/07/02/LRU%E7%AE%97%E6%B3%95/"/>
    <url>/2022/07/02/LRU%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>一种按时序来淘汰的缓存淘汰策略！！！</p></blockquote><p>LRU的全称是Least Recently Used，即最近最少使用，我们认为最近使用过的数据是有用的，很久没有使用过的数据是无用的，内存满了就先删除那些很久没有用过的数据。</p><ul><li>显然cache里面的元素要有时序，支持快速查找，支持在任意位置插入和删除元素；</li><li>用节点来表示每一个键值对key-value；</li><li>可以结合双向链表与哈希表，链表里面是节点，哈希表存储key及链表中对应的节点；</li><li>双向链表中靠头部元素是最久未使用的，靠尾部元素是最近使用的；</li><li>添加元素时先查看缓存容量，只能从尾部插入；</li><li>若添加新元素时遇到相同key值，只需更新value值和将链表中节点移动到尾部；</li><li>缓存容量不足时从链表头部删除节点，并且删除umap中对应节点；</li><li>访问某元素后要将该节点位置移动到链表尾部；</li><li>umap中节点的变动只发生在添加新节点和缓存容量不够时；</li><li>注意移除与删除列表中节点的区别；</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-type">int</span> key, value;<br>    Node* prev;<br>    Node* next;<br>    <span class="hljs-comment">//必须添加下面两个构造函数</span><br>    <span class="hljs-built_in">Node</span>() : <span class="hljs-built_in">key</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">value</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">prev</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>    <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> v) : <span class="hljs-built_in">key</span>(k), <span class="hljs-built_in">value</span>(v), <span class="hljs-built_in">prev</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">NodeList</span> &#123;<br>    Node* head;<br>    Node* tail;<br>    <span class="hljs-built_in">NodeList</span>() &#123;<br>        <span class="hljs-comment">//必须要new</span><br>        head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();<br>        tail = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();<br>        head-&gt;next = tail;<br>        tail-&gt;prev = head;<br>    &#125;<br>    <span class="hljs-comment">//添加节点到链表尾部</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addToTail</span><span class="hljs-params">(Node* node)</span> </span>&#123;<br>        node-&gt;prev = tail-&gt;prev;<br>        tail-&gt;prev-&gt;next = node;<br>        node-&gt;next = tail;<br>        tail-&gt;prev = node;<br>    &#125;<br>    <span class="hljs-comment">//从链表中移除某个节点，前提是这个节点必须存在于链表中</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(Node* node)</span> </span>&#123;<br>        node-&gt;prev-&gt;next = node-&gt;next;<br>        node-&gt;next-&gt;prev = node-&gt;prev;<br>    &#125;<br>    <span class="hljs-comment">//删除链表中最久未使用的节点，即靠近头部的那个节点</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cleanOneCache</span><span class="hljs-params">()</span> </span>&#123;<br>        Node* tmp = head-&gt;next;<br>        <span class="hljs-type">int</span> key = tmp-&gt;key;<br>        <span class="hljs-built_in">remove</span>(tmp);<br>        <span class="hljs-keyword">delete</span> tmp;<br>        <span class="hljs-keyword">return</span> key;<br>    &#125;<br>    <span class="hljs-comment">//使某个被访问的元素到链表尾部</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">makeItRecently</span><span class="hljs-params">(Node* node)</span></span>&#123;<br>        <span class="hljs-built_in">remove</span>(node);<br>        <span class="hljs-built_in">addToTail</span>(node);<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    NodeList list;<br>    unordered_map&lt;<span class="hljs-type">int</span>, Node*&gt; umap;<br>    <span class="hljs-type">int</span> capacity;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">LRUCache</span>(<span class="hljs-type">int</span> cap) &#123;<br>        capacity = cap;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(umap.<span class="hljs-built_in">find</span>(key) == umap.<span class="hljs-built_in">end</span>()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Node* node = umap[key];<br>            <span class="hljs-type">int</span> value = node-&gt;value;<br>            <span class="hljs-comment">//更新链表中节点位置</span><br>            list.<span class="hljs-built_in">makeItRecently</span>(node);<br>            <span class="hljs-keyword">return</span> value;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(umap.<span class="hljs-built_in">find</span>(key) != umap.<span class="hljs-built_in">end</span>()) &#123;<br>            Node* cur = umap[key];<br>            <span class="hljs-comment">//更新节点中的value值</span><br>            cur-&gt;value = value;<br>            <span class="hljs-comment">//更新链表中节点位置</span><br>            list.<span class="hljs-built_in">makeItRecently</span>(cur);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//先查看缓存容量是否充足</span><br>            <span class="hljs-keyword">if</span>(capacity == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>            <span class="hljs-keyword">if</span>(umap.<span class="hljs-built_in">size</span>() == capacity) &#123;<br>                <span class="hljs-type">int</span> k = list.<span class="hljs-built_in">cleanOneCache</span>();<br>                umap.<span class="hljs-built_in">erase</span>(k);<br>            &#125;<br>            <span class="hljs-comment">//添加新节点到链表和umap中</span><br>            Node* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(key, value);<br>            list.<span class="hljs-built_in">addToTail</span>(node);<br>            umap[key] = node;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/2022/07/02/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>/2022/07/02/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<ul><li>并查集用来表示各节点间的连通关系；</li><li>有些问题可以抽象用并查集来解决；</li><li>节点用数组表示！！！<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span> &#123;<br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 连接分量的数目</span><br>    <span class="hljs-type">int</span> count;<br>    <span class="hljs-comment">// 记录每棵树的节点个数</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; size;<br>    <span class="hljs-comment">// 记录每个节点的父节点</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; parent;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">UnionFind</span>(<span class="hljs-type">int</span> n) : <span class="hljs-built_in">count</span>(n) &#123;<br>        parent.<span class="hljs-built_in">resize</span>(n);<br>        size.<span class="hljs-built_in">resize</span>(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            parent[i] = i;<br>            size[i] = i;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Count</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 找到该节点所在树的根节点</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findRoot</span> <span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (x != parent[x]) &#123;<br>            <span class="hljs-comment">// 路径压缩</span><br>            parent[x] = parent[parent[x]];<br>            x = parent[x];<br>        &#125;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 连接两个节点</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unionIt</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q)</span> </span>&#123;<br>        <span class="hljs-type">int</span> rootP = <span class="hljs-built_in">findRoot</span>(p);<br>        <span class="hljs-type">int</span> rootQ = <span class="hljs-built_in">findRoot</span>(q);<br>        <span class="hljs-keyword">if</span> (rootP == rootQ) <span class="hljs-keyword">return</span>;<br>        <br>        <span class="hljs-comment">// 小树接在大树之下，更平衡</span><br>        <span class="hljs-keyword">if</span> (size[rootP] &gt;= size[rootQ]) &#123;<br>            parent[rootQ] = rootP;<br>            size[rootP] += size[rootQ];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            parent[rootP] = rootQ;<br>            size[rootQ] += size[rootP];<br>        &#125;<br>        --count;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 确认两个节点是否连接</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isConnected</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q)</span> </span>&#123;<br>        <span class="hljs-type">int</span> rootP = <span class="hljs-built_in">findRoot</span>(p);<br>        <span class="hljs-type">int</span> rootQ = <span class="hljs-built_in">findRoot</span>(q);<br>        <span class="hljs-keyword">if</span> (rootP == rootQ) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++后端个人书单</title>
    <link href="/2022/07/01/C++%E5%90%8E%E7%AB%AF%E4%B8%AA%E4%BA%BA%E4%B9%A6%E5%8D%95/"/>
    <url>/2022/07/01/C++%E5%90%8E%E7%AB%AF%E4%B8%AA%E4%BA%BA%E4%B9%A6%E5%8D%95/</url>
    
    <content type="html"><![CDATA[<table><thead><tr><th align="center"><strong>类别</strong></th><th align="center"><strong>书名</strong></th><th align="center"><strong>作者</strong></th></tr></thead><tbody><tr><td align="center"><strong><em>数学基础</em></strong></td><td align="center">程序员的数学2 概率统计</td><td align="center">[日]平冈和幸</td></tr><tr><td align="center"></td><td align="center">程序员的数学3 线性代数</td><td align="center">[日]平冈和幸</td></tr><tr><td align="center"><strong><em>C++</em></strong></td><td align="center">C++ Primer（中文版 第五版）</td><td align="center">[美]Stanley B. Lippman</td></tr><tr><td align="center"></td><td align="center">Effective C++</td><td align="center">[美]Scott Meyers</td></tr><tr><td align="center"></td><td align="center">More Effective C++</td><td align="center">[美]Scott Meyers</td></tr><tr><td align="center"></td><td align="center">Effective Modern C++</td><td align="center">[美]Scott Meyers</td></tr><tr><td align="center"></td><td align="center">STL源码刨析</td><td align="center">侯捷</td></tr><tr><td align="center"></td><td align="center">深度探索C++对象模型</td><td align="center">[美]Stanley B. Lippman</td></tr><tr><td align="center"><strong><em>数据机构与算法</em></strong></td><td align="center">数据机构与算法分析：C++语言描述（第四版）</td><td align="center">[美]Mark Allen Weiss</td></tr><tr><td align="center"></td><td align="center">算法（第4版）</td><td align="center">[美]Robert Sedgewick</td></tr><tr><td align="center"></td><td align="center">编程珠玑 第2版</td><td align="center">[美]Jon,Bentley</td></tr><tr><td align="center"></td><td align="center">剑指Offer 第2版</td><td align="center">何海涛</td></tr><tr><td align="center"></td><td align="center">labuladong的算法小抄</td><td align="center">付东来</td></tr><tr><td align="center"><strong><em>计算机网络</em></strong></td><td align="center">图解TCP&#x2F;IP 第5版</td><td align="center">[日]竹下隆史</td></tr><tr><td align="center"></td><td align="center">图解HTTP</td><td align="center">[日]上野</td></tr><tr><td align="center"></td><td align="center">计算机网络：自顶向下方法</td><td align="center">[美]James F. kurose</td></tr><tr><td align="center"><strong><em>操作系统</em></strong></td><td align="center">操作系统导论</td><td align="center">[美]Remzi · H.Arpaci-Dusseau</td></tr><tr><td align="center"></td><td align="center">程序员的自我修养 ——链接、转载与库</td><td align="center">俞甲子</td></tr><tr><td align="center"></td><td align="center">鸟哥的Linux私房菜基础学习篇（第四版）</td><td align="center">鸟哥</td></tr><tr><td align="center"></td><td align="center">深入理解计算机系统（原书第3版）</td><td align="center">[美]Randal E. Bryant</td></tr><tr><td align="center"><strong><em>数据库</em></strong></td><td align="center">SQL必知必会 第5版</td><td align="center">[美]Ben,Forta</td></tr><tr><td align="center"></td><td align="center">MySQL是怎样运行的</td><td align="center">小孩子4919</td></tr><tr><td align="center"></td><td align="center">高性能MySQL（第3版）</td><td align="center">Baron Schwartz</td></tr><tr><td align="center"></td><td align="center">MySQL技术内幕：lnnoDB存储引擎（第2版）</td><td align="center">姜承尧</td></tr><tr><td align="center"></td><td align="center">Redis设计与实现</td><td align="center">黄健宏</td></tr><tr><td align="center"><strong><em>设计模式</em></strong></td><td align="center">大话设计模式</td><td align="center">程杰</td></tr><tr><td align="center"><strong><em>网络编程</em></strong></td><td align="center">Linux高性能服务器编程</td><td align="center">游双</td></tr><tr><td align="center"></td><td align="center">linux多线程服务端编程</td><td align="center">陈硕</td></tr><tr><td align="center"><strong><em>应用</em></strong></td><td align="center">数据密集型应用系统设计</td><td align="center">[美]Martin Kleppmann</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>计算机学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习路线</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo常用命令</title>
    <link href="/2022/07/01/hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/07/01/hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="前置安装"><a href="#前置安装" class="headerlink" title="前置安装"></a>前置安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm i -g hexo-cli<br><br>npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 新建一个名为new_post的post</span><br>hexo n new_post<br><br><span class="hljs-comment"># 清楚缓存</span><br>hexo clear<br><br><span class="hljs-comment"># 生成</span><br>hexo g<br><br><span class="hljs-comment"># 发布到本地</span><br>hexo s<br><br><span class="hljs-comment"># 发布到github</span><br>hexo d<br></code></pre></td></tr></table></figure><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 本地发布</span><br>hexo clear &amp;&amp; hexo g &amp;&amp; hexo s<br><br><span class="hljs-comment"># github发布</span><br>hexo clear &amp;&amp; hexo g &amp;&amp; hexo d<br><br><span class="hljs-comment"># 删除文章</span><br>删除 <span class="hljs-string">&quot;sourc/_posts&quot;</span> 文件夹中相应的md文件<br></code></pre></td></tr></table></figure><h2 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h2><p>格式举例如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">title:</span> <span class="hljs-string">C++给常用数据结构传入排序算法</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2022-07-01 16:22:30</span><br><span class="hljs-attr">tags:</span> <br>  <span class="hljs-bullet">-</span> <span class="hljs-string">刷题</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">C++</span><br><span class="hljs-attr">categories:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">C++</span><br><span class="hljs-attr">index_img:</span> <span class="hljs-string">/post_img/02.jpg</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++给常用数据结构传入排序算法</title>
    <link href="/2022/07/01/C++%E7%BB%99%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BC%A0%E5%85%A5%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2022/07/01/C++%E7%BB%99%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BC%A0%E5%85%A5%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>在刷<a href="https://leetcode-cn.com/problems/top-k-frequent-elements/">leetcode347题</a>时，遇到c++自定义操作的知识点，总结如下：</p><h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><p><strong>在类中</strong>定义了如下比较函数，但<strong>定义有序容器时</strong>编译不通过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">myComparison</span><span class="hljs-params">(<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; lhs, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; rhs)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> lhs.second &gt; rhs.second;<br>&#125;<br><br>priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;,<br>  <span class="hljs-keyword">decltype</span>(myComparison)*&gt; <span class="hljs-built_in">pri_que</span>(myComparison);<br></code></pre></td></tr></table></figure><p>编译报错如下：</p><blockquote><p>error: reference to non-static member function must be called 即必须调用对非静态成员函数的引用</p></blockquote><h3 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h3><p>所以比较函数定义错误，正确解法如下：</p><h4 id="1-定义为静态成员函数"><a href="#1-定义为静态成员函数" class="headerlink" title="1.定义为静态成员函数"></a>1.定义为静态成员函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">myComparison</span><span class="hljs-params">(<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; lhs, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; rhs)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> lhs.second &gt; rhs.second;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-将比较函数定义在类外面"><a href="#2-将比较函数定义在类外面" class="headerlink" title="2.将比较函数定义在类外面"></a>2.将比较函数定义在类外面</h4><p>注意函数声明在类前。</p><h4 id="3-运用仿函数"><a href="#3-运用仿函数" class="headerlink" title="3.运用仿函数"></a>3.运用仿函数</h4><p>注意添加const。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">myComparison</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; lhs, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; rhs)</span> <span class="hljs-type">const</span> </span>&#123;<br><span class="hljs-keyword">return</span> lhs.second &gt; rhs.second;<br>&#125;<br>&#125;;<br><br>priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, myComparison&gt; pri_que;<br></code></pre></td></tr></table></figure><hr><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><h4 id="1-容器的操作自定义处"><a href="#1-容器的操作自定义处" class="headerlink" title="1.容器的操作自定义处"></a>1.容器的操作自定义处</h4><blockquote><p>priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, decltype(myComparison)*&gt; pri_que(myComparison);</p></blockquote><ul><li>为了使用自己定义的操作，在定义容器时必须提供两个类型：<strong>关键字类型</strong>即<code>pair&lt;int, int&gt;</code>，<strong>比较操作类型</strong>即指向myComparison的指针<code>decltype(myComparison)*</code>；</li><li>此处使用<code>decltype</code>指出自定义操作的类型，但当使用decltype来获取一个函数指针类型时，须加上一个<code>*</code>号来表示使用一个给定函数类型的指针；</li><li>定义有序容器时，<code>vector&lt;pair&lt;int, int&gt;&gt;</code>表示<strong>基于vector构造</strong>优先队列；</li><li><code>pri_que(myComparison)</code>表示用myComparison来初始化pri_que对象，即向pri_que添加元素时，调用myComparison来排序；</li><li>用<code>pri_que(myComparison)</code>代替<code>pri_que(&amp;myComparison)</code>因为使用函数名字会自动转化为指针；</li></ul><h4 id="2-比较函数自定义处"><a href="#2-比较函数自定义处" class="headerlink" title="2.比较函数自定义处"></a>2.比较函数自定义处</h4><blockquote><p>return lhs.second &gt; rhs.second;</p></blockquote><ul><li><code>&gt;</code>此比较符号表示在优先队列中左大于右就会建立小顶堆；</li></ul><h3 id="扩展："><a href="#扩展：" class="headerlink" title="扩展："></a>扩展：</h3><h4 id="1-向算法传递函数"><a href="#1-向算法传递函数" class="headerlink" title="1.向算法传递函数"></a>1.向算法传递函数</h4><p>即使用标准库的算法时，传入参数使用自己的操作，示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isShorter</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s1, <span class="hljs-type">const</span> string&amp; s2)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> s1.<span class="hljs-built_in">size</span>() &lt; s2.<span class="hljs-built_in">size</span>();<br>&#125;<br><span class="hljs-built_in">sort</span>(words.<span class="hljs-built_in">begin</span>(), words.<span class="hljs-built_in">end</span>(), isShorter);<br></code></pre></td></tr></table></figure><h4 id="2-在算法中使用lambda表达式"><a href="#2-在算法中使用lambda表达式" class="headerlink" title="2.在算法中使用lambda表达式"></a>2.在算法中使用lambda表达式</h4><p>即编写与isShorter函数功能相同的lambda表达式，示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">sort</span>(words.<span class="hljs-built_in">begin</span>(), words.<span class="hljs-built_in">end</span>(),<br>    [](<span class="hljs-type">const</span> string&amp; s1, <span class="hljs-type">const</span> string&amp; s2)<br>     &#123;<span class="hljs-keyword">return</span> s1.<span class="hljs-built_in">size</span>() &lt; s2.<span class="hljs-built_in">size</span>();&#125;);<br></code></pre></td></tr></table></figure><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul><li><a href="https://programmercarl.com/">代码随想录</a>博客</li><li>《C++primer》</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
